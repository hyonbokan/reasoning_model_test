{
  "detected_findings": [
    {
      "finding_id": "VULN-001",
      "contract_file": "LandManager.sol",
      "vulnerability_class": "state_update_error",
      "primary_code_location": {
        "file": "LandManager.sol",
        "element_name": "transferToUnoccupiedPlot",
        "unique_snippet": "// missing: toilerState[tokenId].plotId = plotId;",
        "rationale": "After a plot transfer, the contract updates latestTaxRate and occupancy mappings but never mutates the cached plotId inside toilerState."
      },
      "related_code_locations": [
        {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "plotOccupied[_toiler.landlord][plotId] = Plot({ occupied: true, tokenId: tokenId });",
          "rationale": "Shows new plot becoming occupied while cached plotId stays stale."
        }
      ],
      "specifics": {
        "issue_type": "state_update_error",
        "missing_or_incorrect": "`toilerState[tokenId].plotId` is left pointing at the old plot.",
        "consequences": "Subsequent farming uses an outdated plot id. Rewards may be calculated with an obsolete tax rate or cause the `dirty` flag to never toggle when plots are reduced, leading to permanent reward denial or mis-allocation."
      },
      "detailed_description": "`transferToUnoccupiedPlot` intends to move a staked Munchable to another free plot owned by the same landlord. It correctly flips the old plot to unoccupied and the new one to occupied and refreshes `latestTaxRate`, but it does **not** update `toilerState[tokenId].plotId` to the new `plotId`. This leaves internal state inconsistent: the storage struct still references the old plot while the occupancy mapping and emitted events say otherwise. Any later logic that relies on `toilerState[tokenId].plotId`—most importantly the `_farmPlots` reward engine—will behave as if the Munchable remained on the old plot. This violates the documented invariant and can corrupt reward accounting.",
      "exploit_scenario": "1. Player stakes a Munchable on plot #1.\n2. Later calls `transferToUnoccupiedPlot` to move it to plot #2.\n3. Because `plotId` inside `toilerState` is not updated, farming keeps using the stale id. If the landlord later deletes plot #1 (by reducing locked value), the `dirty` flag is never set, halting rewards, or rewards may be routed with the wrong tax parameters.",
      "impact": "medium",
      "likelihood": "high",
      "severity": "high",
      "supporting_evidence": [
        {
          "context_source": "invariants",
          "context_type": "invariant_rule",
          "details": "\"After transfer, toilerState.plotId updated\" explicitly required."
        }
      ],
      "violated_invariants": [
        "After transfer, toilerState.plotId updated"
      ],
      "related_static_analysis_finding_ids": []
    },
    {
      "finding_id": "VULN-002",
      "contract_file": "LandManager.sol",
      "vulnerability_class": "logic_edge_case",
      "primary_code_location": {
        "file": "LandManager.sol",
        "element_name": "stakeMunchable",
        "unique_snippet": "if (munchablesStaked[mainAccount].length > 10) revert TooManyStakedMunchiesError();",
        "rationale": "Boundary check allows exactly 11 NFTs because it reverts only when length is already > 10, not when the new insertion will exceed 10."
      },
      "related_code_locations": [],
      "specifics": {
        "issue_type": "logic_edge_case",
        "edge_condition": "`munchablesStaked[mainAccount].length == 10`",
        "faulty_branch": "The function pushes a new tokenId, resulting in length 11, violating the documented limit ≤10."
      },
      "detailed_description": "The game design caps the number of concurrently staked Munchables per account at 10. However, `stakeMunchable` reverts only when the current length is **greater than** 10. When the length is exactly 10 the check passes, the function pushes the new `tokenId`, and the array grows to 11, breaking the intended ceiling and contradicting the stated invariant.",
      "exploit_scenario": "A user continuously stakes until they hold 11 Munchables:\n• After 10 NFTs are staked, the length equals 10.\n• Calling `stakeMunchable` again bypasses the guard and pushes the 11th NFT.\n• The extra NFT now earns Schnibbles unfairly compared to other players limited to 10.",
      "impact": "low",
      "likelihood": "high",
      "severity": "medium",
      "supporting_evidence": [
        {
          "context_source": "invariants",
          "context_type": "invariant_rule",
          "details": "Invariant \"munchablesStaked[mainAccount].length <= 10\" is violated."
        }
      ],
      "violated_invariants": [
        "Stake does not increase staked munchables beyond limit"
      ],
      "related_static_analysis_finding_ids": []
    }
  ],
  "detection_summary_notes": "Primary risks stem from state-tracking errors in plot transfer and an off-by-one boundary check while staking. Both lead to invariant violations; the first poses moderate reward-accounting corruption, while the second grants minor unfair advantage."
}