{
  "results": [
    {
      "Issue": "ILOManager.initialize can be called by anyone before owner → full project takeover",
      "Severity": "High",
      "Contracts": [
        "ILOManager.sol"
      ],
      "Description": "The initialization routine that wires all critical parameters (platform/performance fee, fee-taker, pool implementation, factory addresses **and transfers ownership**) is completely **un-restricted**:\n\n```solidity\nfunction initialize(\n    address initialOwner,\n    address _feeTaker,\n    ...\n) external override whenNotInitialized() {\n    PLATFORM_FEE = platformFee;\n    PERFORMANCE_FEE = performanceFee;\n    FEE_TAKER = _feeTaker;\n    transferOwnership(initialOwner);   // <-- ownership handed over\n    ...\n}\n```\nBecause `initialize` lacks an `onlyOwner` (or any) access-control modifier, the **first account that calls it after deployment becomes the contract owner and decides all critical addresses and fees**. An attacker who front-runs the legitimate deployer can:\n• Set themselves as `initialOwner` (gaining `onlyOwner` powers)\n• Redirect all fees via `FEE_TAKER`\n• Point `ILO_POOL_IMPLEMENTATION` to malicious byte-code\n• Manipulate `PLATFORM_FEE` / `PERFORMANCE_FEE`\n\nImpact: Full permanent compromise of every ILO project created through this manager, loss of user funds, protocol shutdown.\n\nLikelihood: High – the race happens right after deployment and nothing prevents a public call.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Ownership assigned with tx.origin – wrong or unsafe owner after deployment",
      "Severity": "Medium",
      "Contracts": [
        "ILOManager.sol"
      ],
      "Description": "Constructor sets the owner to `tx.origin` instead of `msg.sender`:\n\n```solidity\nconstructor () {\n    transferOwnership(tx.origin);\n}\n```\nIf the contract is deployed **via any other contract or multisig**, `tx.origin` will be the **EOA that triggered the deployment transaction**, **not** the factory or multisig. This can:\n• Accidentally grant ownership to an unattended EOA rather than the intended governance multisig.\n• Break trust assumptions when the deployer is a contract (e.g., a factory or DAO executor).\n• Enable phishing / social-engineering attacks during scripted deployments.\n\nWhile a legitimate deployer may later call `initialize` to move ownership, the incorrect initial owner still briefly exists and can carry out privileged actions (e.g., `setPlatformFee`) before initialization is executed.\n",
      "Recommendation": ""
    },
    {
      "Issue": "claim() distributes 100 % of accumulated fees even when only part of liquidity is unlocked",
      "Severity": "Medium",
      "Contracts": [
        "ILOPool.sol"
      ],
      "Description": "When an investor claims **partially-vested** liquidity, the contract burns `liquidity2Claim` (only the unlocked portion) **but calculates fee rewards with the ENTIRE position’s liquidity**:\n\n```solidity\nuint128 liquidity2Claim = _claimableLiquidity(tokenId);\n...\nuint128 positionLiquidity = position.liquidity;          // full liquidity\n...\nuint256 fees0 = FullMath.mulDiv(\n        feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,\n        positionLiquidity,                              // <-- should be liquidity2Claim\n        FixedPoint128.Q128\n);\n```\nAs a consequence, a holder who unlocks just 10 % of their liquidity can still withdraw **100 % of the fees generated by the total (100 %) liquidity to date**, leaving future vesting periods without their proportional share.\n\nImpact: Over-payment to early claimers, economic loss for later vesting tranches and project allocations; the vesting invariant \"fees follow liquidity\" is broken.\n\nLikelihood: Medium – any rational investor will exploit this once identified.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Self-whitelist ETH refund uses `transfer`, blocking contracts with code",
      "Severity": "Low",
      "Contracts": [
        "Whitelist.sol"
      ],
      "Description": "The payable `receive()` function refunds the sent ETH with the 2300-gas `transfer`:\n\n```solidity\nreceive() external payable {\n    ...\n    payable(_msgSender()).transfer(msg.value); // 2300 gas\n}\n```\nIf a user is a smart contract whose fallback needs more than 2300 gas (e.g., a multisig), the refund will **revert**, preventing self-whitelisting and potentially locking ETH in the Whitelist contract.\n\nImpact: DoS for contract wallets and possible accidental ETH lock-up (although the amount is usually small).\n\nLikelihood: Medium – many modern wallets are contracts (Gnosis Safe, Argent, etc.) whose fallback consumes >2300 gas.\n",
      "Recommendation": ""
    }
  ]
}