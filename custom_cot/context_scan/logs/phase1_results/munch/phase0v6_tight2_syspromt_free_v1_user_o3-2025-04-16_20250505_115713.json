{
  "results": [
    {
      "Issue": "transferToUnoccupiedPlot leaves toilerState.plotId unchanged, permanently locking plots",
      "Severity": "High",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "When moving a staked NFT to a new plot, the contract updates the Plot occupancy mapping but forgets to update the canonical record in `toilerState`.  \n```solidity\n// inside transferToUnoccupiedPlot\nplotOccupied[_toiler.landlord][oldPlotId] = Plot({ occupied: false, tokenId: 0 });\nplotOccupied[_toiler.landlord][plotId]      = Plot({ occupied: true,  tokenId: tokenId });\n// MISSING: toilerState[tokenId].plotId = plotId;\n```\nBecause `toilerState[tokenId].plotId` remains at the **old** value:\n1. Any subsequent `unstakeMunchable` will mark the OLD plot as vacant again, but **never** clears the NEW plot.  \n2. The NEW plot keeps `occupied = true` while holding a token that has already been withdrawn, rendering that plot unusable for future staking (permanent DoS on that plot).\n3. Events and reward-calculation logic (_farmPlots) reference the stale plot id, leading to accounting errors and unexpected `dirty` flags.\nAttackers (or even normal users) can therefore lock any landlord’s plot for good by: stake → transferToUnoccupiedPlot → unstake.  All calls are public and require no special privileges, so likelihood is high and impact (permanent loss of plot utility & reward mis-accounting) is high.",
      "Recommendation": ""
    },
    {
      "Issue": "Off-by-one error allows more than the intended 10 staked munchables per player",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "The limit check in `stakeMunchable` uses a strict greater-than comparison:\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n...\nmunchablesStaked[mainAccount].push(tokenId);\n```\nIf a player currently has exactly 10 staked NFTs, the condition evaluates to false, the push is performed, and the length becomes **11** – violating the documented maximum (invariant inv-4).  This weakens economic assumptions about reward distribution loops and gas limits.  Given staking is public, the likelihood is high; impact is comparatively low, so severity is medium per the matrix.",
      "Recommendation": ""
    },
    {
      "Issue": "Division by zero possible when PRICE_PER_PLOT is misconfigured",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "The helper used by several user-facing functions performs a direct division:\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n}\n```\nIf an administrator (or a bug in `ConfigStorage`) sets `PRICE_PER_PLOT` to **0**, every call to `_getNumPlots` reverts with a division-by-zero error.  This bricks `stakeMunchable`, `transferToUnoccupiedPlot`, `_farmPlots`, and effectively halts the entire land-staking subsystem (DoS).  While configuration mistakes are uncommon, the impact is medium and the likelihood low, giving an overall low severity.",
      "Recommendation": ""
    },
    {
      "Issue": "Use of transferFrom instead of safeTransferFrom for ERC-721 transfers",
      "Severity": "Best Practices",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "Both staking and unstaking rely on the raw `transferFrom` function:\n```solidity\nmunchNFT.transferFrom(mainAccount, address(this), tokenId);\n...\nmunchNFT.transferFrom(address(this), mainAccount, tokenId);\n```\n`safeTransferFrom` is generally recommended because it invokes `onERC721Received` on the receiver, preventing NFTs from being sent to contracts that cannot handle them and slightly reducing re-entrancy surface.  While the current implementation works for EOAs, switching to the safer variant improves robustness and aligns with ERC-721 best practices.",
      "Recommendation": ""
    }
  ]
}