{
  "results": [
    {
      "Issue": "plotId not updated in toilerState after transferToUnoccupiedPlot",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In ```transferToUnoccupiedPlot()``` the contract moves the NFT from the old plot to the new one, but it never updates the stored `plotId` inside the `toilerState` struct:\n```solidity\n// LandManager.sol\nfunction transferToUnoccupiedPlot(uint256 tokenId,uint256 plotId) ... {\n    ...\n    toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate; // plotId NOT updated\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({occupied:false, tokenId:0});\n    plotOccupied[_toiler.landlord][plotId]  = Plot({occupied:true,  tokenId:tokenId});\n    ...\n}\n```\nConsequences:\n• `toilerState[tokenId].plotId` continues to point to the *old* plot.\n• Subsequent farming uses an incorrect plot index and may fail to mark the NFT dirty when it should, producing wrong Schnibbles accounting.\n• Any later logic that relies on `toilerState.plotId` (e.g., invariant 16 from the context summary) is violated, causing inconsistent state and potential reward manipulation.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Landlord can be forced to 0 % tax until metadata is triggered",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`stakeMunchable()` allows a player to stake on any landlord even when that landlord has never executed `triggerPlotMetadata()` or had `updatePlotMetadata()` called by `AccountManager`.\n```solidity\n// LandManager.sol – stakeMunchable()\n...\n        toilerState[tokenId] = ToilerState({\n            lastToilDate: block.timestamp,\n            plotId: plotId,\n            landlord: landlord,\n            latestTaxRate: plotMetadata[landlord].currentTaxRate, // ← zero if metadata never initialised\n            dirty: false\n        });\n...\n```\nBecause `currentTaxRate` is un-initialised (default = 0), the first farming cycles grant the renter **zero tax** and the landlord receives nothing. The landlord cannot retroactively recover this loss. Any user can deliberately choose an inactive landlord to enjoy tax-free rewards.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Incorrect inequality allows farming on invalid plot after locks decrease",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In `_farmPlots()` the test that marks a token as `dirty` after the landlord’s number of plots decreases is off by one:\n```solidity\n// LandManager.sol – _farmPlots()\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n```\nValid plots are `0 … N-1`. When the landlord now has only `N` plots, a token that used to occupy plot `N` (exactly equal) should be invalid, but the `<` test does **not** catch it (it should be `<=`). The token continues farming on a non-existent plot, producing Schnibbles that it should not earn.\n",
      "Recommendation": ""
    },
    {
      "Issue": "External ERC-721 transfer executed before state is updated (re-entrancy window)",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`stakeMunchable()` performs `munchNFT.transferFrom()` *before* it records the staking information:\n```solidity\n// LandManager.sol – stakeMunchable()\nmunchNFT.transferFrom(mainAccount, address(this), tokenId); // external call\n\nplotOccupied[landlord][plotId] = Plot({occupied:true, tokenId:tokenId});\n... (state updates follow)\n```\nIf the NFT contract is malicious or implements ERC-721 hooks that call back into `LandManager`, re-entrancy could occur while the contract is still in its pre-stake state (e.g., `plotOccupied` is still free, `munchablesStaked` length unchanged). An attacker could stake the same token multiple times or bypass the \"max 10 staked\" limit.\n\nAlthough assumption 3 states that *MunchNFT is trusted*, following the Checks-Effects-Interactions pattern and/or adding a `ReentrancyGuard` would eliminate this class of bugs and future-proof the code.\n",
      "Recommendation": ""
    }
  ]
}