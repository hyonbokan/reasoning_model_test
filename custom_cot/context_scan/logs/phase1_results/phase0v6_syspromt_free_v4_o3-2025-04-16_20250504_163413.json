{
  "results": [
    {
      "Issue": "Re-entrancy window in stakeMunchable: external NFT transfer executed before any state is updated",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  stakeMunchable() performs an external call to the ERC-721 contract *before* writing any of its own storage.  \n\n```solidity\n// LandManager.sol : stakeMunchable()\n...\nif (!munchNFT.isApprovedForAll(...) && munchNFT.getApproved(tokenId) != address(this)) revert NotApprovedError();\n\nmunchNFT.transferFrom(mainAccount, address(this), tokenId);   // <-- EXTERNAL CALL\n\nplotOccupied[landlord][plotId] = Plot({ occupied: true, tokenId: tokenId });  // state mut./effects only afterwards\nmunchablesStaked[mainAccount].push(tokenId);\n...\n```\n\nHOW  –  A malicious or upgraded `munchNFT` contract can, during `transferFrom`, callback into LandManager and invoke any *non-view* function that is not protected by `forceFarmPlots` or that has the same external visibility (e.g. call stakeMunchable again, unstakeMunchable, transferToUnoccupiedPlot, etc.).  Because LandManager’s own state has **not yet been updated** the re-entrant call observes the contract in its pre-stake state and can break several invariants:\n• Stake the same `tokenId` twice (double-stake).  \n• Bypass the `>10` staked-munchables limit.  \n• Occupy the same plot twice or occupy a plot that is supposed to be checked as already occupied.  \n• Cause unexpected array contents that later lead to out-of-bounds reads in _farmPlots.\n\nWHY IT MATTERS  –  Although the current assumptions state that `MunchNFT` is a trusted ERC-721, upgradeability via ConfigStorage means an administrator (or a compromised admin key) could point `munchNFT` to a hostile contract, enabling high-impact exploits that steal Munchables, break farming accounting or permanently brick accounts.  Even if the admin is benign, leaving an unguarded re-entrancy window violates the checks-effects-interactions pattern and is a critical maintenance risk.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Off-by-one error allows farming on non-existent plot when landlord plot count decreases",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  In _farmPlots() the contract attempts to detect when a staker’s stored plotId is no longer valid because the landlord’s locked value (and thus number of plots) has fallen.  The comparison, however, is incorrect:\n\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {   // should be <=\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n```\n\nHOW  –  Suppose the staker originally occupied plotId = 2 (third plot).  If the landlord later unlocks tokens so that they now own exactly 2 plots (valid indices 0 and 1), then `_getNumPlots(landlord)` returns 2.  The check `2 < 2` is **false**, meaning the contract *fails* to flag the toiler as dirty even though the plot no longer exists.\n\nWHY IT MATTERS  –  The staker will continue accruing Schnibbles on a plot the landlord no longer owns, defeating the economic intent of the land-size restriction and potentially over-diluting rewards.  The landlord is also denied the ability to free that plot ID for future use.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Landlord can avoid paying any tax by never initialising plotMetadata",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  stakeMunchable() records the currentTaxRate from `plotMetadata[landlord]` without verifying that metadata has ever been initialised.  If `lastUpdated` is still zero, `currentTaxRate` is the Solidity default **0**.\n\n```solidity\n// stakeMunchable()\n...\nlatestTaxRate: plotMetadata[landlord].currentTaxRate,   // == 0 if metadata never triggered\n...\n```\n\nHOW  –  A landlord can simply skip calling triggerPlotMetadata() (or an AccountManager call to updatePlotMetadata never happens).  All early stakers will lock‐in a tax rate of 0, meaning **100 %** of Schnibbles go to the stakers until the next explicit farm call updates `latestTaxRate`.\n\nWHY IT MATTERS  –  The incentive mechanism is undermined; landlords lose expected income while stakers gain an unintended advantage.  Because the contract emits no event or revert in this case, the issue may remain unnoticed.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Division-by-zero possibility if PRICE_PER_PLOT mis-configured",
      "Severity": "Info",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  _getNumPlots() divides by `PRICE_PER_PLOT` taken from ConfigStorage without a non-zero check:\n\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;  // DIVIDE BY 0\n}\n```\n\nHOW  –  If an administrator mistakenly sets `PRICE_PER_PLOT` to 0 in the config store, *every* call that queries or uses the plot count will revert, freezing stake/unstake/farm operations.\n\nWHY IT MATTERS  –  While the risk depends on correct governance, misconfiguration is a common source of outages.  A single bad config update bricks all land-related functionality until another upgrade transaction is executed.\n",
      "Recommendation": ""
    }
  ]
}