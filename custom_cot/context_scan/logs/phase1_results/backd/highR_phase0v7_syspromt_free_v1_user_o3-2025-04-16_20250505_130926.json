{
  "results": [
    {
      "Issue": "StakerVault totals not updated on transfer/transferFrom causing reward distortion",
      "Severity": "Medium",
      "Contracts": [
        "StakerVault.sol"
      ],
      "Description": "In StakerVault.sol both transfer() and transferFrom() move users’ balances but do **not** update the book-keeping variables that separate “strategy” stake from regular pool stake:\n\n```solidity\n// inside transfer() – no change to _poolTotalStaked / strategiesTotalStaked\nbalances[msg.sender] -= amount;\nbalances[account] += amount;\n\n// inside transferFrom() – same omission\nbalances[src] = srcTokens.uncheckedSub(amount);\nbalances[dst] = balances[dst] + amount;\n```\n\nWhen tokens move **between a strategy address and a non-strategy address** these counters become inconsistent:\n1.  strategy → user : `strategiesTotalStaked` still contains the tokens while `_poolTotalStaked` stays unchanged ⇒ denominator used by gauges is **too low** – an attacker can inflate his rewards.\n2.  user → strategy : tokens are still counted in `_poolTotalStaked` although they should be excluded ⇒ denominator is **too high** – honest users receive less.\n\nBecause gauges base their integral calculations on `_poolTotalStaked`, a malicious actor can transfer large amounts from a whitelisted strategy to his own address just before calling `userCheckpoint/claimRewards`, artificially boosting the integral and minting an outsized share of inflation.  The extra mint may even hit the hard cap inside `Minter` and cause `mint()` to revert, resulting in a DoS for other stakers.\n\nThis breaks project invariants 11 & 12 (total staked accounting) and leads to unfair or failing reward distribution.",
      "Recommendation": ""
    },
    {
      "Issue": "KeeperGauge.claimRewards can revert due to division by zero for epochs with no reported fees",
      "Severity": "Medium",
      "Contracts": [
        "KeeperGauge.sol"
      ],
      "Description": "In KeeperGauge `_calcTotalClaimable()` each epoch performs\n\n```solidity\nkeeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])\n```\n\nIf **no fee handler called `reportFees()` in an epoch**, `perPeriodTotalFees[i]` is zero.  A division by zero reverts, blocking:\n* `claimRewards()` – keepers cannot claim any rewards covering that epoch.\n* `claimableRewards()` view – will also revert for off-chain callers.\n\nThis permanently bricks reward claiming for the affected gauge once such an epoch exists, locking inflation tokens contrary to invariant-24 and disrupting the protocol.",
      "Recommendation": ""
    },
    {
      "Issue": "BkdLocker.migrate allows setting rewardToken to the zero address",
      "Severity": "Low",
      "Contracts": [
        "BkdLocker.sol"
      ],
      "Description": "`migrate()` lacks a non-zero check:\n\n```solidity\nfunction migrate(address newRewardToken) external onlyGovernance {\n    // no zero-address validation\n    rewardToken = newRewardToken;\n}\n```\n\nSetting `rewardToken = address(0)` bricks `depositFees()` and `claimFees()` (both treat the token as an ERC20 and will revert), effectively freezing all future fee distribution.",
      "Recommendation": ""
    },
    {
      "Issue": "Anyone can execute previously-prepared config changes, potentially front-running governance timing expectations",
      "Severity": "Info",
      "Contracts": [
        "AddressProvider.sol",
        "Controller.sol",
        "Preparable.sol"
      ],
      "Description": "`executeAddress()` in AddressProvider and `executeKeeperRequiredStakedBKD()` in Controller expose the raw `_executeAddress/UInt256` calls **without any access control**:\n\n```solidity\nfunction executeAddress(bytes32 key) external returns (address) { ... }\n\nfunction executeKeeperRequiredStakedBKD() external { _executeUInt256(...); }\n```\n\nAfter the mandatory delay anyone can finalize a pending change before governance intended to, which may lead to unintended state at a specific block (e.g. during a migration or vote).  Although the value itself is pre-committed, the exact execution time could be important for dependent contracts or off-chain coordination.",
      "Recommendation": ""
    },
    {
      "Issue": "Fee burning & swapping performed without any minimum-amount/slippage checks",
      "Severity": "Best Practices",
      "Contracts": [
        "FeeBurner.sol",
        "RewardHandler.sol"
      ],
      "Description": "Both `FeeBurner.burnToTarget()` and `RewardHandler.burnFees()` forward tokens and ETH to arbitrary swaps (`ISwapperRouter.swap / swapAll`) while passing **no minimum‐output or price limits**.  An adverse router implementation or MEV sandwich could drain value by returning almost nothing for the swaps.",
      "Recommendation": ""
    }
  ]
}