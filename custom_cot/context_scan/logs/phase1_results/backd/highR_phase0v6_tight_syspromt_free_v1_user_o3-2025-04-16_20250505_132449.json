{
  "results": [
    {
      "Issue": "Unlocking all BKD tokens can revert due to under-flow in _userCheckpoint",
      "Severity": "High",
      "Contracts": [
        "BkdLocker.sol"
      ],
      "Description": "When a user executes a full unlock the following code under-flows and reverts, trapping the user’s balance forever:\n```solidity\n// BkdLocker.sol:_userCheckpoint\ntotalLockedBoosted =\n    totalLockedBoosted +\n    newTotal.scaledMul(newBoost) -\n    balances[user].scaledMul(boostFactors[user]);\n```\nDuring `executeUnlocks()` `newTotal` is `balances[user] - amountBeingUnlocked` **while `balances[user]` is still the old value**.  If the user withdraws everything (`newTotal == 0`) or simply reduces his boosted balance (`newTotal * newBoost < oldBoosted`), the subtraction becomes negative and reverts in Solidity ≥0.8.\n\nMinimal scenario\n1. User has 100 tokens with boost 1.3.\n2. User prepares and executes an unlock of all 100 tokens.\n3. `newTotal == 0`, `newBoost` resolves to `startBoost` (≈1).  Expression becomes `0 - 130`, under-flowing and reverting.\n\nImpact:  Users cannot unlock (partially or totally) once their boosted balance is larger than the new boosted amount – a permanent DoS on withdrawals and on‐chain voting power.\n",
      "Recommendation": ""
    },
    {
      "Issue": "KeeperGauge rewards can be blocked by division-by-zero when no fees were reported for an epoch",
      "Severity": "Medium",
      "Contracts": [
        "KeeperGauge.sol"
      ],
      "Description": "Reward calculation divides by the total fees of an epoch without checking for zero:\n```solidity\n// KeeperGauge.sol:_calcTotalClaimable\nclaimable += keeperRecords[ben].feesInPeriod[i]\n                .scaledDiv(perPeriodTotalFees[i]) // <== may revert\n                .scaledMul(perPeriodTotalInflation[i]);\n```\nIf `advanceEpoch()` is called before *any* keeper reports fees for that epoch, `perPeriodTotalFees[i]` stays **0** while `perPeriodTotalInflation[i]` is already incremented in `poolCheckpoint()`.  Any call to `claimRewards` / `claimableRewards` that touches such an epoch reverts, blocking all keepers from claiming across all epochs after the first empty one.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Silent failure in RoleManager due to unchecked EnumerableSet return values",
      "Severity": "Low",
      "Contracts": [
        "RoleManager.sol"
      ],
      "Description": "`EnumerableSet.add/remove` return a boolean that should be checked.  In `RoleManager` the result is ignored:\n```solidity\nfunction _grantRole(bytes32 role, address account) internal {\n    _roles[role].members[account] = true;\n    _roleMembers[role].add(account); // return value ignored\n}\nfunction _revokeRole(bytes32 role, address account) internal {\n    _roles[role].members[account] = false;\n    _roleMembers[role].remove(account); // return value ignored\n}\n```\nIf the add/remove operation fails (e.g. duplicate insert, removal of non-existing element) the mapping and the set diverge, breaking invariants `inv-1/2/3` and potentially allowing governance to be fully revoked or duplicated.\n",
      "Recommendation": ""
    },
    {
      "Issue": "claim(address) in VestedEscrow can revert when called on behalf of another user",
      "Severity": "Low",
      "Contracts": [
        "VestedEscrow.sol"
      ],
      "Description": "`claim(address _recipient)` is meant to let a third party claim for a user, but the internal call still keys off `msg.sender`:\n```solidity\nfunction claim(address _recipient) public override {\n    _claimUntil(_recipient, block.timestamp);\n}\n...\nfunction _claimUntil(address _recipient, uint256 _time) internal {\n    uint256 claimable = _balanceOf(msg.sender, _time); // should use _recipient\n    ...\n    rewardToken.safeTransferFrom(holdingContract[msg.sender], _recipient, claimable);\n}\n```\nAs a consequence the function only works when `msg.sender == _recipient`.  Any other caller hits an empty holding contract and reverts, defeating the purpose of the overload and breaking integrations (e.g. gauge zaps, delegation contracts).\n",
      "Recommendation": ""
    }
  ]
}