{
  "results": [
    {
      "Issue": "addStrategy does not re-classify existing stake, breaking _poolTotalStaked invariant",
      "Severity": "Medium",
      "Contracts": [
        "StakerVault.sol"
      ],
      "Description": "When a strategy address that already holds LP tokens inside the vault is registered via\n```solidity\nfunction addStrategy(address strategy) external override returns (bool) {\n    require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);\n    strategies[strategy] = true;          // <-- ONLY flag is flipped\n    return true;\n}\n```\nno accounting adjustment is made.  Any tokens that the address had staked *before* it became a\n`strategy` remain counted in `_poolTotalStaked`, while future stakes are added to\n`strategiesTotalStaked`:\n```solidity\nif (strategies[account]) {\n    strategiesTotalStaked += staked;\n} else {\n    _poolTotalStaked += staked;           // <- mis-classified old balance\n}\n```\nThis violates invariant-12 ( *“Sum of _poolTotalStaked and strategiesTotalStaked equals total of balances”* ) and makes the vault report an inflated `_poolTotalStaked`.  Gauges that divide inflation by this value (e.g. `LpGauge._poolCheckpoint`) under-reward normal LP stakers while strategies keep the same influence.  The error is permanent because there is no way to migrate the pre-existing balance between the two buckets once the flag is set.",
      "Recommendation": ""
    },
    {
      "Issue": "Weight decrease can revert due to unchecked underflow in InflationManager",
      "Severity": "Medium",
      "Contracts": [
        "InflationManager.sol"
      ],
      "Description": "`_executeKeeperPoolWeight`, `_executeLpPoolWeight`, and `_executeAmmTokenWeight` try to\nre-compute global weight totals with manual subtraction and then *cap* negatives to zero:\n```solidity\ntotalKeeperPoolWeight = totalKeeperPoolWeight\n                        - currentUInts256[key]          // may underflow\n                        + pendingUInts256[key];\n// attempt to floor-to-zero afterwards (never reached when revert already happened)\n```\nSince Solidity ≥0.8 reverts on arithmetic underflow **before** the assignment, calling Governance\ncan no longer set a weight to a value smaller than the current one whenever\n`totalKeeperPoolWeight < currentUInts256[key]` (common when removing / delisting gauges).  This\ncreates a Denial-of-Service for legitimate configuration changes and breaks invariants 18–20 that\nexpect totals to always equal the sum of individual weights.",
      "Recommendation": ""
    },
    {
      "Issue": "External calls before state update enable re-entrancy in StakerVault transfers",
      "Severity": "Low",
      "Contracts": [
        "StakerVault.sol"
      ],
      "Description": "`transfer`, `transferFrom`, `stakeFor` and `unstakeFor` invoke external contracts *(pool\nhandle callbacks or ERC20 transfers)* **before** mutating internal balances:\n```solidity\nILiquidityPool pool = addressProvider.getPoolForToken(token);\npool.handleLpTokenTransfer(src, dst, amount); // external, user-controlled pool\n...\nbalances[src] -= amount;                      // state updated afterwards\n```\nA malicious or compromised `LiquidityPool` (or non-standard token used for `token`) can re-enter\nStakerVault during the external call and execute functions that rely on the yet-to-be-updated\n`balances`, potentially causing double spends or inconsistent accounting.  While Backd pools are\nsupposed to be trusted, nothing in the vault enforces that only whitelisted implementations can be\nset, so this remains a latent risk.",
      "Recommendation": ""
    }
  ]
}