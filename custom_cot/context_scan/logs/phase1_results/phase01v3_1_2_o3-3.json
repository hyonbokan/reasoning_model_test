{
  "findings": [
    {
      "Issue": "Re-entrancy window in unstakeMunchable allows state-inconsistent reentrant staking",
      "Severity": "High",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT: Function ```unstakeMunchable``` resets all bookkeeping (``munchableOwner``, ```plotOccupied```, ```toilerState```, staked list) **before** executing an external call\n```solidity\nmunchNFT.transferFrom(address(this), mainAccount, tokenId);\n```\nBecause ```IERC721.transferFrom``` can execute arbitrary code via hook/callbacks in a malicious / upgraded ERC-721, an attacker can re-enter LandManager while the first call is still in progress.\n\nHOW: During the re-entrant execution, the attacker already owns the NFT again (the ERC-721 owner mapping is updated *inside* the token contract **before** control is handed to hooks). LandManager’s internal state was cleared in the outer call, so the attacker can:\n1. call ```stakeMunchable``` with the same ``tokenId`` – the ownership check passes;\n2. bypass per-account limits (staked list was popped) or take any other action that assumes a clean state.\n\nWHY this matters:\n• Invariant ctx3 (\"munchablesStaked[mainAccount].length <= 10\") can be violated because the pop happened already; the attacker can enqueue the same ID again, ending with duplicates or >10 items.\n• Storage inconsistencies between ```munchablesStaked```, ```munchableOwner```, and ```plotOccupied``` become possible, leading to accounting errors, reward mis-calculation, or future denial-of-service (because ```_removeTokenIdFromStakedList``` may not find the duplicated id).\n• All functions of LandManager are unprotected by a re-entrancy guard, so more complex cross-function attacks are feasible.\n\nThe vulnerable pattern is classic *checks-effects-interactions* violation:\n```solidity\n// effects first …\nplotOccupied[_toiler.landlord][_toiler.plotId] = Plot({occupied:false, tokenId:0});\n... // many state deletions\n// *** EXTERNAL CALL ***\nmunchNFT.transferFrom(address(this), mainAccount, tokenId);   // <-- re-enter possible\n```\nRecommendation: \"\"",
      "Recommendation": ""
    },
    {
      "Issue": "Per-account staking limit enforced with an off-by-one condition",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT: ```stakeMunchable``` intends to cap the number of NFTs a player can stake to *10* (ctx3).\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\nHOW: The check uses **> 10** instead of **>= 10**. Consequently the 11-th stake is still allowed; only the 12-th will revert.\n\nWHY: Violates stated invariant ctx3 and can lead to imbalanced gameplay economics or unexpected gas costs in loops that assume the array length ≤ 10.\n\nFix: change the guard to `>= 10`. Recommendation field left intentionally blank per schema.",
      "Recommendation": ""
    },
    {
      "Issue": "Division-by-zero & mis-configuration risk in _getNumPlots due to un-validated PRICE_PER_PLOT",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT: ```_getNumPlots``` divides by configuration value ```PRICE_PER_PLOT``` without checking for zero.\n```solidity\nreturn lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n```\nIf ```PRICE_PER_PLOT``` is set to 0 (e.g. because the configStorage entry is uninitialised or an admin mistake), every call that relies on the function **reverts**, effectively freezing staking, unstaking and farming (DoS).\n\nHOW: Only the protocol admin can update ConfigStorage, but an error or malicious upgrade is enough. No on-chain guard prevents setting zero.\n\nIMPACT: Total denial-of-service for core gameplay functions.\n\nMitigation: add `require(PRICE_PER_PLOT != 0, \"Price per plot not set\")` in `_reconfigure` or before the division.",
      "Recommendation": ""
    },
    {
      "Issue": "Config keys mismatch sets MIN/MAX tax rates to arbitrary addresses",
      "Severity": "Info",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In `_reconfigure` the contract loads scalar parameters via keys that appear to be meant for **addresses**:\n```solidity\nMIN_TAX_RATE = config.getUint(StorageKey.LockManager);       // LockManager is an address key\nMAX_TAX_RATE = config.getUint(StorageKey.AccountManager);    // AccountManager is an address key\n```\nThis likely returns 20-byte address values (≥ 2¹⁶⁰) which:\n• make `updateTaxRate` almost impossible (newTaxRate would never be within such huge bounds);\n• risk overflow in reward calculation `schnibblesTotal * latestTaxRate / 1e18`, reverting farming.\nWhile only mis-configuration is required to trigger the fault, it is best flagged for correctness.\n\nEnsure dedicated numeric keys exist (e.g., `StorageKey.MinTaxRate` / `MaxTaxRate`) and are read instead of address keys.",
      "Recommendation": ""
    }
  ]
}