{
  "results": [
    {
      "Issue": "toilerState.plotId not updated in transferToUnoccupiedPlot",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "When a staker calls ```solidity\nfunction transferToUnoccupiedPlot(uint256 tokenId,uint256 plotId)\n``` the contract updates the two Plot mappings but **never updates the cached `plotId` stored in `toilerState[tokenId]`**.\n\n```solidity\n// LandManager.sol\n toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate;\n // <missing>  toilerState[tokenId].plotId = plotId;\n```\n\nConsequences:\n• Future reward calculations in `_farmPlots` use the **old plotId**, causing accounting errors.\n• The previous plot is marked un-occupied, so another NFT can now occupy it while `toilerState` still points to it.  This breaks invariants 14–16 and can let two NFTs claim the same rewards bucket.\n• Events emitted after the move (`FarmPlotTaken`) carry a stale `plotId`, misleading off-chain indexers.",
      "Recommendation": ""
    },
    {
      "Issue": "Off-by-one stake limit allows 11 NFTs instead of 10",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "The size check in `stakeMunchable` is\n```solidity\nif (munchablesStaked[mainAccount].length > 10) revert TooManyStakedMunchiesError();\n```\nBecause the check happens **before** the push, a user with exactly 10 staked NFTs can still stake one more (length == 10 → condition false), ending up with **11**.  This violates invariant 4 and may give some users an unintended advantage.",
      "Recommendation": ""
    },
    {
      "Issue": "Division-by-zero risk if PRICE_PER_PLOT is mis-configured",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "All functions that call `_getNumPlots` divide by the config value `PRICE_PER_PLOT`:\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT; // <== potential div/0\n}\n```\nIf the admin (or a compromised ConfigStorage) sets `PRICE_PER_PLOT` to 0 during `_reconfigure`, **every subsequent call to `_getNumPlots` reverts**, effectively bricking staking, farming and many other user actions (denial-of-service).  Nothing prevents such mis-configuration at the contract level.",
      "Recommendation": ""
    },
    {
      "Issue": "Negative bonus values can revert farming",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`_farmPlots` computes rewards as\n```solidity\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\nIf `finalBonus < -100`, the inner expression becomes negative and the cast to `uint256` reverts, permanently preventing the affected user from farming.  Because both `REALM_BONUSES` (int16) and `RARITY_BONUSES` (uint8 cast to int8) are configurable through `ConfigStorage`, a malicious or mistaken admin could set a value ≤ -101, triggering this failure.",
      "Recommendation": ""
    },
    {
      "Issue": "No re-entrancy guard around external calls",
      "Severity": "Info",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "Several functions (`_farmPlots`, `stakeMunchable`, `unstakeMunchable`) perform state changes and then invoke external contracts (`accountManager.updatePlayer`, `munchNFT.transferFrom`).  Although the trusted-contract assumption reduces risk, adding a `nonReentrant` modifier (or OpenZeppelin `ReentrancyGuard`) would harden the contract against future integrations with untrusted contracts or incorrect assumptions.",
      "Recommendation": ""
    }
  ]
}