{
  "results": [
    {
      "Issue": "DAO fees collected on position open are never forwarded to GovNFT and get burned",
      "Severity": "Medium",
      "Contracts": [
        "Trading.sol",
        "GovNFT.sol"
      ],
      "Description": "In Trading.sol the function `_handleOpenFees()` mints the DAO-share of opening fees to the Trading contract itself and then tries to forward them to the GovNFT treasury by calling `gov.distribute(...)`.\\n\\n```solidity\n// Trading.sol  _handleOpenFees()\nIStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n...\n// *** NO approve() call here ***\ngov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n```\\n\\nGovNFT’s `distribute()` pulls the tokens with `transferFrom()` and therefore requires an allowance. Because the Trading contract never executes `approve()` the `transferFrom()` inside GovNFT **always reverts inside the try-catch and silently aborts**, leaving the freshly minted DAO-fee tokens stranded on Trading.\\n\\nLater, when any user action calls `_handleDeposit()`, *all* TigAsset held by the Trading contract (including the stranded DAO fees) are burned unconditionally:\\n\\n```solidity\n// Trading.sol  _handleDeposit()\ntigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this))); // burns DAO fees\n```\\n\\nEffectively, every opened position burns the DAO fee share instead of distributing it to governance. This represents a continuous silent loss of protocol revenue and makes on-chain accounting incorrect.\\n\\nImpact: Medium – DAO/GovNFT income is permanently lost, breaking the economic model, but no user funds are directly at risk.\\nLikelihood: High – the bug is hit on **every** market/limit order open.\\nCombined matrix severity: Medium.",
      "Recommendation": ""
    },
    {
      "Issue": "Unconditional burn of entire TigAsset balance in _handleDeposit may destroy unrelated funds",
      "Severity": "Low",
      "Contracts": [
        "Trading.sol"
      ],
      "Description": "`_handleDeposit()` burns *the full TigAsset balance of the Trading contract* after every deposit, not only the amount just minted for the incoming margin.\\n\\n```solidity\nuint256 _balBefore = tigAsset.balanceOf(address(this));\n...\nIStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n...\ntigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this))); // burns _balBefore + margin\n```\\n\\nIf the contract happens to hold TigAsset for any other reason (e.g. the DAO fees stranded because of the previous issue, or tokens transferred by mistake), those tokens are irreversibly burned on the next user deposit.\\n\\nImpact: Low – the value lost is limited to the Trading contract’s own balance (no direct user loss), yet it further amplifies the revenue-loss problem and makes accounting unpredictable.\\nLikelihood: Medium – triggered whenever Trading ever accumulates extra TigAsset (already the case due to Issue-1).\\nMatrix severity: Low.",
      "Recommendation": ""
    },
    {
      "Issue": "StableVault lacks re-entrancy protection around external token transfers",
      "Severity": "Low",
      "Contracts": [
        "StableVault.sol"
      ],
      "Description": "Both `deposit()` and `withdraw()` perform external ERC-20 calls (`transferFrom`, `transfer`) **before** finishing all logic and without using `ReentrancyGuard`:\\n\\n```solidity\n// deposit()\nIERC20(_token).transferFrom(_msgSender(), address(this), _amount);\nIERC20Mintable(stable).mintFor(_msgSender(), ...);\n\n// withdraw()\nIERC20Mintable(stable).burnFrom(_msgSender(), _amount);\nIERC20(_token).transfer(_msgSender(), _output); // re-entrant call possible here\n```\\n\\nIf an \"evil\" ERC-20 implementation re-enters the vault during `transfer`, the caller could attempt nested `withdraw()` calls and bypass internal accounting, especially because the vault keeps no per-user balance bookkeeping. Although the initial `burnFrom` reduces the attacker’s StableToken balance, a carefully crafted sequence (e.g., withdrawing different tokens or using `depositWithPermit`) can still lead to inconsistent state or denial-of-service.\\n\\nImpact: Low – requires a malicious ERC-20 and only affects the vault’s reserves, but can lead to unexpected token loss or DoS.\\nLikelihood: Low/Medium – custom tokens are common on L2s and could be whitelisted accidentally.\\nMatrix severity: Low.",
      "Recommendation": ""
    },
    {
      "Issue": "maxBridge parameter in GovNFT is never enforced allowing unlimited NFT batches",
      "Severity": "Info",
      "Contracts": [
        "GovNFT.sol"
      ],
      "Description": "`GovNFT.crossChain()` is supposed to restrict the number of NFTs bridged in a single call via `maxBridge`, but no check is implemented:\\n\\n```solidity\nrequire(tokenId.length > 0, \"Not bridging\");\n// missing: require(tokenId.length <= maxBridge, \"Too many\");\n```\\n\\nA user can supply an arbitrarily large `tokenId` array. This may exceed block gas limits, revert, or make the function unusable for others (griefing).\\n\\nWhile not a critical security flaw, it contradicts the documented intent and can degrade usability or availability of the bridge.",
      "Recommendation": ""
    }
  ]
}