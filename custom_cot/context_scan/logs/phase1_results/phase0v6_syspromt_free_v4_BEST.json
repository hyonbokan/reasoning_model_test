{
  "findings": [
    {
      "Issue": "Wrong reward-scaling formula can underflow, overflow or mint huge Schnibbles",
      "Severity": "High",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  In _farmPlots the final reward is calculated as\n```solidity\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nHOW  –  The intention clearly is `schnibblesTotal * (100 + finalBonus) / 100` (keep the original amount plus *percentage* bonus).  Instead the implementation adds the **raw** `schnibblesTotal` (¹) to the *already multiplied* value (²) **and then divides the sum by 100**:\n\n    (¹ 100) + (² 100 * 20) = 2 100  ➜  /100 = **21** (should be 120)\n\nFor positive bonuses users are under-rewarded ≈×0.21. For negative values the first term is only *1×*, while the second term is *-N×100*, so the result quickly becomes a large **negative** `int256`. Casting that negative number to `uint256` silently wraps it to a value close to 2²⁵⁶-1, after which the next line\n```solidity\nschnibblesLandlord = (schnibblesTotal * _toiler.latestTaxRate) / 1e18;\n```\nmultiplies by `latestTaxRate` and **overflows, reverting the whole transaction**.  An attacker (or mis-configured admin) only has to set a `RARITY_BONUSES` entry > 127 (stored as `uint8`, cast to **negative** `int8`) to make `finalBonus` negative and break the farming process for every staked token that carries this rarity.\n\nWHY  –  A single wrong value in ConfigStorage can:\n• Halt the protocol (DoS) because farming reverts on every call.\n• If overflow is avoided (e.g. small negative bonus) the cast creates an astronomically large `schnibblesTotal`, inflating the attacker’s balance and draining Schnibbles economics.\n\n```solidity\nint16 finalBonus = int16(REALM_BONUSES[...]) + int16(int8(RARITY_BONUSES[...]));\n// […]\nschnibblesTotal = uint256((int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100);\n```",
      "Recommendation": ""
    },
    {
      "Issue": "No re-entrancy guard around external calls (accountManager.updatePlayer)",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  Functions `farmPlots`, `stakeMunchable`, `unstakeMunchable`, and `transferToUnoccupiedPlot` make external calls to **AccountManager** (or to ERC-721 contracts) without any `nonReentrant` protection.\n\nHOW  –  `accountManager.updatePlayer(...)` is invoked *after* internal state is mutated but *before* the function completes:\n```solidity\naccountManager.updatePlayer(landlord, landlordMetadata);   // external, untrusted\n```\nIf the AccountManager implementation (or a malicious upgrade of it) calls back into LandManager, the attacker can:\n1. Re-enter `stakeMunchable` / `unstakeMunchable` while the first call is still running.\n2. Bypass business-logic assumptions (e.g., double use of the same `tokenId`, exceeding stake limits, inconsistent `toilerState`).\n\nWHY  –  Although currently `AccountManager` is assumed to be trusted, the missing guard makes the contract fragile to future upgrades or interface integrations and violates the checks-effects-interactions best practice.",
      "Recommendation": ""
    },
    {
      "Issue": "Off-by-one lets a player stake 11 (not 10) Munchables",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  `stakeMunchable` is supposed to cap each player at 10 staked NFTs but checks *strictly greater* (`> 10`) **before** the new token is pushed:\n```solidity\nif (munchablesStaked[mainAccount].length > 10) revert TooManyStakedMunchiesError();\n// push happens afterwards\n```\n\nHOW  –  When a player already has 10 tokens staked, `length` is 10 (not > 10) so the check passes and the 11th token is accepted. Subsequent calls revert forever, effectively making the limit 11.\n\nWHY  –  Breaks documented invariant `inv-4`, causes uneven game balancing and could overflow the `uint8 i` loop counter in `_farmPlots` if the limit is ever raised elsewhere.",
      "Recommendation": ""
    },
    {
      "Issue": "Division by zero if PRICE_PER_PLOT mis-configured",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  `_getNumPlots` performs `lockedValue / PRICE_PER_PLOT`.  `_reconfigure` blindly loads `PRICE_PER_PLOT` from ConfigStorage without verifying it is non-zero.\n\nHOW  –  A single bad config update sets the value to 0, making every call that queries plot counts revert (including `stakeMunchable`, `_farmPlots`, etc.).\n\nWHY  –  Entire protocol becomes unusable until admin intervention.  A safety check prevents accidental bricking.",
      "Recommendation": ""
    },
    {
      "Issue": "Zero-initialised plot metadata lets renters avoid landlord tax",
      "Severity": "Info",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  When a landlord has **never** called `triggerPlotMetadata` and no `updatePlotMetadata` occurred, `plotMetadata[landlord].currentTaxRate` defaults to 0.  Renters can still stake:\n```solidity\nlatestTaxRate = plotMetadata[landlord].currentTaxRate; // == 0\n```\n\nHOW  –  Choose a landlord address that locked Schnibs but never initialised metadata, stake on its plots, and farm indefinitely paying **0% tax** until the landlord (or AccountManager) updates metadata.\n\nWHY  –  Economic imbalance, especially if landlords are unaware or inactive.  Consider forcing metadata initialisation inside `stakeMunchable` or rejecting zero-rate landlords.",
      "Recommendation": ""
    }
  ]
}