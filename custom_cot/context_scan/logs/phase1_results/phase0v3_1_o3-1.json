{
  "findings": [
    {
      "Issue": "plotId not updated in toilerState after plot transfer",
      "Severity": "High",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In `transferToUnoccupiedPlot()` the contract frees the old plot and marks the new plot as occupied, but **never writes the new `plotId` back into the `toilerState` struct**:\n```solidity\n// SNIPPET ↓↓↓\nplotOccupied[_toiler.landlord][plotId] = Plot({\n    occupied: true,\n    tokenId: tokenId\n});\n// <missing>  toilerState[tokenId].plotId = plotId;\nemit FarmPlotLeave(...);\n```\nWHAT  – `toilerState[tokenId].plotId` keeps the *old* value.\nHOW   – Subsequent calls (farming, unstake, second transfer) trust `plotId` when indexing `plotOccupied` or `_getNumPlots()`.  The stale value causes:\n• `unstakeMunchable()` to clear the **wrong** plot.\n• `_farmPlots()` bonus/tax calculations to use a non-existent or already-occupied plot, violating ctx4 / ctx9 invariants.\nWHY  – Direct state inconsistency that can be exploited to steal plots or double-stake.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Staking limit off-by-one allows 11 NFTs (violates ≤10 invariant)",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In `stakeMunchable()` the length check is:\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\nBecause the element is pushed **after** the check, a user that already has exactly 10 tokens will pass the check, then `.push()` makes the length **11**, breaking invariant ctx3 (`length ≤ 10`).  This gives an unfair advantage in farming rewards and may break off-chain assumptions.",
      "Recommendation": ""
    },
    {
      "Issue": "Mis-wired config keys set MIN/MAX/DEFAULT tax rates to unrelated storage slots",
      "Severity": "High",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`_reconfigure()` fetches numerical tax parameters using **address keys**, not the intended dedicated uint keys:\n```solidity\nMIN_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.LockManager); // Should be StorageKey.MinTaxRate\nMAX_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.AccountManager); // Should be StorageKey.MaxTaxRate\nDEFAULT_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.ClaimManager); // Should be StorageKey.DefaultTaxRate\n```\nWHAT  – The returned values are likely zero or garbage (converted contract addresses).\nHOW   – `updateTaxRate()` validates `newTaxRate` against these wrong bounds.  Landlords could set *any* tax (if MIN=0, MAX≈2¹⁶⁰) or be **blocked forever** (if bounds equal 0).\nWHY  – Breaks ctx1 & ctx8 invariants, enables economic abuse or permanent DoS for tax updates.",
      "Recommendation": ""
    },
    {
      "Issue": "Re-entrancy window during `stakeMunchable` (external NFT transfer before state update)",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`stakeMunchable()` calls the external ERC-721 contract **before** it records staking state:\n```solidity\nmunchNFT.transferFrom(mainAccount, address(this), tokenId); // external call\n// state writes happen afterwards\nplotOccupied[landlord][plotId] = ...;\n```\nA malicious ERC-721 implementation could call back into `stakeMunchable()` (or other functions) re-using the same `tokenId` because `munchableOwner` and `plotOccupied` are not yet set, leading to double-stake or state confusion.  No `nonReentrant` guard is present.",
      "Recommendation": ""
    },
    {
      "Issue": "Division by zero possibility in _getNumPlots (PRICE_PER_PLOT unchecked)",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`_getNumPlots()` performs:\n```solidity\nreturn lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n```\n`PRICE_PER_PLOT` is loaded from `StorageKey.NFTOverlord` without any non-zero validation.  An admin mis-configuration (or deliberate attack through an upgradeable ConfigStorage) setting it to **0** bricks every function that relies on plot counting (division by zero -> revert), resulting in protocol-wide DoS.",
      "Recommendation": ""
    }
  ]
}