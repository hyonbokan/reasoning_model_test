{
  "findings": [
    {
      "Issue": "Bonus math in _farmPlots can revert or slash rewards (signed→uint underflow)",
      "Severity": "High",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT  –  _farmPlots() adds realm & rarity bonuses using signed arithmetic and then casts the result to uint256:\n```solidity\nfinalBonus = int16(REALM_BONUSES[...]) + int16(int8(RARITY_BONUSES[...]));\n...\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\nHOW  –  If finalBonus is −100 or smaller, the inner expression becomes negative (e.g., X * (1-100) = −99·X).  Casting a negative int256 to uint256 reverts, aborting the whole farming transaction.  Because both bonus tables are pulled from on-chain config storage, a mis-configuration or a malicious admin can brick farming for **all** players holding the affected NFT.\nWHY  –  • Denial-of-service: any user who farms a token whose bonus ≤ −100 will make `_farmPlots` revert, blocking farming and all state-updates in `forceFarmPlots` guarded functions (stake, unstake, transfer).\n• Silent value slashing: even with positive bonuses the formula divides by 100 **after** adding the bonus, so a +20 bonus yields only 21 % ( (1+20)/100 ) of the base rewards instead of 120 %.  Players and landlords receive far fewer Schnibbles than intended.\n",
      "Recommendation": ""
    },
    {
      "Issue": "transferToUnoccupiedPlot forgets to update toilerState.plotId",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT – After moving a Munchable to a new plot, the contract does **not** write the new `plotId` back to storage:\n```solidity\n// tax-rate refreshed\ntoilerState[tokenId].latestTaxRate = ...;\n// plots swapped, but …\n// MISSING: toilerState[tokenId].plotId = plotId;\n```\nHOW – The occupancy mapping is updated, yet the token’s internal state still points to the **old** plot.  Subsequent farming rounds use the stale plotId, producing wrong Schnibble calculations and incorrectly setting the `dirty` flag.  Because the old plot is marked vacant, the landlord (or another player) can stake a second NFT there, effectively bypassing the «one-NFT-per-plot» invariant.\nWHY – Inconsistent state → double occupation of a single logical plot, mis-accounted rewards, and events that reference the wrong plot ID.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Configurable PRICE_PER_PLOT = 0 breaks contract via div-by-zero",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT – `_getNumPlots()` divides by `PRICE_PER_PLOT` obtained from ConfigStorage without validation:\n```solidity\nreturn lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n```\nHOW – If a malicious or careless admin sets `PRICE_PER_PLOT` to zero during `_reconfigure()`, every call that queries plot counts (staking, farming, etc.) reverts with a division-by-zero, freezing core functionality.\nWHY – Although the config admin is usually trusted, defence-in-depth calls for an explicit non-zero check to prevent total denial-of-service caused by mis-configuration.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Out-of-bounds access on REALM_BONUSES & RARITY_BONUSES arrays",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "WHAT – Indices for the bonus tables are computed from **in-game attributes** that are not range-checked:\n```solidity\nREALM_BONUSES[(uint256(immutableAttributes.realm) * 5) + uint256(landlordMetadata.snuggeryRealm)]\nRARITY_BONUSES[uint256(immutableAttributes.rarity)]\n```\nHOW – If `realm`, `snuggeryRealm`, or `rarity` exceed the array lengths provided by ConfigStorage, the read will revert, halting farming (or any stake/unstake that triggers forceFarmPlots).\nWHY – The attributes come from external contracts; future game updates or bad config values can brick the protocol for specific NFTs or for everyone.\n",
      "Recommendation": ""
    },
    {
      "Issue": "Lack of reentrancy guard around external calls",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "Functions such as `stakeMunchable`, `unstakeMunchable`, and `_farmPlots` perform external calls (`munchNFT.transferFrom`, `accountManager.updatePlayer`) without a `nonReentrant` modifier.  Although state is generally updated before the call, a malicious ERC-721 or AccountManager implementation could re-enter and call functions that rely on intermediate state, potentially leading to inconsistent bookkeeping.  A lightweight `ReentrancyGuard` would harden the contract at minimal gas cost.\n",
      "Recommendation": ""
    }
  ]
}