{
  "results": [
    {
      "Issue": "Off-by-one allows >10 Munchables to be staked (stake limit bypass)",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "Invariant inv-4 states the staked-per-account limit is 10.  However in ```stakeMunchable``` the verification is:\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n...\nmunchablesStaked[mainAccount].push(tokenId);\n```\nWhen a player already has exactly 10 NFTs staked, `length` equals 10 so the require does **not** revert.  The subsequent `push` makes the length 11, exceeding the intended cap and violating invariants inv-4/5/6.  Because this check is executed on every stake, the likelihood is high.  Impact is economic/fairness (players can earn excess Schnibbles), therefore overall severity is Medium according to the matrix.",
      "Recommendation": ""
    },
    {
      "Issue": "Negative bonus can underflow and DOS farming",
      "Severity": "Medium",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In ```_farmPlots``` Schnibbles are calculated as:\n```solidity\nfinalBonus = int16(REALM_BONUSES[...]) + int16(int8(RARITY_BONUSES[...]));\n...\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\nIf `finalBonus` is **negative** and its magnitude is ≥ 1, the numerator becomes negative, and the implicit cast to `uint256` reverts, DoSing farming for the caller and preventing `forceFarmPlots`-protected functions (stake/unstake/transfer) from executing.\n\nThe code does not bound `REALM_BONUSES` or `RARITY_BONUSES`; a configuration mistake (or malicious update) that sets a negative realm bonus (e.g., ‑10) and zero rarity bonus is enough to trigger the revert.  Likelihood is medium (depends on config), impact is medium (users cannot interact).",
      "Recommendation": ""
    },
    {
      "Issue": "Division by zero when PRICE_PER_PLOT is mis-configured",
      "Severity": "Low",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "`_getNumPlots` computes\n```solidity\nreturn lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n```\nIf `PRICE_PER_PLOT` is accidentally set to zero via `ConfigStorage`, every call to `_getNumPlots` (stake, transfer, farming, etc.) reverts with a division-by-zero error, rendering the contract unusable.  While the configuration is assumed trusted (assume-1), defensive code should still guard against catastrophic mis-configuration.",
      "Recommendation": ""
    },
    {
      "Issue": "External token transfer occurs before state is updated (potential re-entrancy)",
      "Severity": "Best Practices",
      "Contracts": [
        "LandManager.sol"
      ],
      "Description": "In ```stakeMunchable``` the call to the external ERC-721 contract is executed *before* internal state is updated:\n```solidity\nmunchNFT.transferFrom(mainAccount, address(this), tokenId);\n// state updates follow\n```\nAlthough the project assumes `MunchNFT` is a well-behaved token (assume-3) and `transferFrom` does **not** invoke callbacks, using the checks-effects-interactions pattern or `ReentrancyGuard` would make the function robust against a future token upgrade or an erroneous address being configured.",
      "Recommendation": ""
    }
  ]
}