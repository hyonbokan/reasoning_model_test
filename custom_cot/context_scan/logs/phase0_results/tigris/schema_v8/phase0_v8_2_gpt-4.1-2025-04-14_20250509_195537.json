{
  "analyzed_contracts": [
    {
      "id": "Trading.sol",
      "file_name": "Trading.sol",
      "core_purpose_raw": "The Trading contract is the main entry point for users to open, modify, and close leveraged perpetual trading positions. It manages market and limit orders, margin adjustments, liquidations, and fee distribution. It interacts with the TradingExtension for price verification and validation, Position for NFT-based position management, PairsContract for asset parameters, GovNFT for governance rewards, and StableVault for margin asset management.",
      "core_purpose_digest": "Main contract for leveraged trading: manages positions, orders, margin, liquidations, and fees.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ITradingExtension",
        "IStable",
        "ExtendedIERC20",
        "ERC20Permit",
        "IPairsContract",
        "IPosition",
        "IGovNFT",
        "IStableVault"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "limit order executor",
        "liquidator",
        "owner",
        "proxy",
        "referrer",
        "trader"
      ],
      "key_state_vars": [
        "allowedVault",
        "blockDelay",
        "blockDelayPassed",
        "closeFees",
        "gov",
        "limitDelay",
        "limitOrderPriceRange",
        "maxWinPercent",
        "openFees",
        "pairsContract",
        "position",
        "proxyApprovals",
        "tradingExtension",
        "vaultFundingPercent"
      ],
      "key_functions": [
        "addMargin",
        "addToPosition",
        "approveProxy",
        "cancelLimitOrder",
        "executeLimitOrder",
        "initiateCloseOrder",
        "initiateLimitOrder",
        "initiateMarketOrder",
        "limitClose",
        "liquidatePosition",
        "removeMargin",
        "setAllowedVault",
        "setBlockDelay",
        "setFees",
        "setLimitOrderPriceRange",
        "setMaxWinPercent",
        "setTradingExtension",
        "updateTpSl"
      ],
      "external_dependencies": [
        "GovNFT",
        "PairsContract",
        "Position",
        "Referrals",
        "StableToken",
        "StableVault",
        "TradingExtension"
      ],
      "security_notes": [
        "Relies on off-chain signed price data; signature and node whitelisting enforced.",
        "Proxy trading requires explicit approval and time-bound validity.",
        "All margin and asset transfers use ERC20 safe transfer patterns.",
        "Fee distribution logic is complex and must be checked for rounding and overflow.",
        "Limit order execution is open to any user, but requires delay and price checks.",
        "Liquidation threshold is enforced to prevent undercollateralized positions.",
        "Reentrancy is not explicitly guarded in Trading, but StableVault uses ReentrancyGuard.",
        "All critical state changes are gated by onlyOwner or onlyMinter as appropriate."
      ],
      "config_params": [
        {
          "name": "blockDelay",
          "storage_key": "blockDelay",
          "load_site": {
            "id": "Trading.sol:blockDelay",
            "file": "Trading.sol",
            "element_name": "blockDelay",
            "unique_snippet": "uint public blockDelay;"
          },
          "downstream_uses": [
            "Trading.sol:_checkDelay"
          ],
          "role": "misc"
        },
        {
          "name": "limitOrderPriceRange",
          "storage_key": "limitOrderPriceRange",
          "load_site": {
            "id": "Trading.sol:limitOrderPriceRange",
            "file": "Trading.sol",
            "element_name": "limitOrderPriceRange",
            "unique_snippet": "uint public limitOrderPriceRange = 1e8; // 1%"
          },
          "downstream_uses": [
            "Trading.sol:executeLimitOrder"
          ],
          "role": "upper_bound"
        },
        {
          "name": "maxWinPercent",
          "storage_key": "maxWinPercent",
          "load_site": {
            "id": "Trading.sol:maxWinPercent",
            "file": "Trading.sol",
            "element_name": "maxWinPercent",
            "unique_snippet": "uint public maxWinPercent;"
          },
          "downstream_uses": [
            "Trading.sol:_closePosition"
          ],
          "role": "upper_bound"
        },
        {
          "name": "vaultFundingPercent",
          "storage_key": "vaultFundingPercent",
          "load_site": {
            "id": "Trading.sol:vaultFundingPercent",
            "file": "Trading.sol",
            "element_name": "vaultFundingPercent",
            "unique_snippet": "uint public vaultFundingPercent;"
          },
          "downstream_uses": [
            "Trading.sol:_updateFunding"
          ],
          "role": "multiplier"
        }
      ],
      "flag_trackers": [
        {
          "name": "paused",
          "expected_setters": [
            "TradingExtension.setPaused"
          ],
          "observed_setters": [
            "TradingExtension.setPaused"
          ],
          "note": "Blocks trading when true"
        }
      ],
      "math_scale_hints": [
        {
          "id": "Trading.sol:positionSize",
          "file": "Trading.sol",
          "element_name": "initiateMarketOrder",
          "op": "mul",
          "lhs": "_marginAfterFees",
          "rhs": "_tradeInfo.leverage",
          "scale": 1,
          "comment": "Position size = margin * leverage / 1e18"
        }
      ]
    },
    {
      "id": "TradingExtension.sol",
      "file_name": "TradingExtension.sol",
      "core_purpose_raw": "TradingExtension provides auxiliary logic for the Trading contract, including price signature verification, referral management, trade validation, and open interest modification. It enforces protocol-level checks such as allowed margin assets, minimum position size, and pausing. It also manages the set of whitelisted oracle nodes and signature validity windows.",
      "core_purpose_digest": "Auxiliary contract for price verification, trade validation, and protocol-level checks.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPairsContract",
        "IReferrals",
        "IPosition"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner",
        "protocol"
      ],
      "key_state_vars": [
        "allowedMargin",
        "chainlinkEnabled",
        "isNode",
        "maxGasPrice",
        "minPositionSize",
        "pairsContract",
        "paused",
        "position",
        "referrals",
        "trading",
        "validSignatureTimer"
      ],
      "key_functions": [
        "getVerifiedPrice",
        "modifyLongOi",
        "modifyShortOi",
        "setAllowedMargin",
        "setMinPositionSize",
        "setNode",
        "setPaused",
        "setValidSignatureTimer",
        "validateTrade"
      ],
      "external_dependencies": [
        "PairsContract",
        "Position",
        "Referrals"
      ],
      "security_notes": [
        "Enforces signature validity and node whitelisting for price data.",
        "Pausing disables all trading via Trading contract.",
        "Gas price checks to prevent high-gas attacks.",
        "Trade validation enforces allowed margin, leverage bounds, and minimum position size."
      ],
      "config_params": [
        {
          "name": "validSignatureTimer",
          "storage_key": "validSignatureTimer",
          "load_site": {
            "id": "TradingExtension.sol:validSignatureTimer",
            "file": "TradingExtension.sol",
            "element_name": "validSignatureTimer",
            "unique_snippet": "uint256 public validSignatureTimer;"
          },
          "downstream_uses": [
            "TradingExtension.sol:getVerifiedPrice"
          ],
          "role": "upper_bound"
        },
        {
          "name": "maxGasPrice",
          "storage_key": "maxGasPrice",
          "load_site": {
            "id": "TradingExtension.sol:maxGasPrice",
            "file": "TradingExtension.sol",
            "element_name": "maxGasPrice",
            "unique_snippet": "uint public maxGasPrice = 1000000000000; // 1000 gwei"
          },
          "downstream_uses": [
            "TradingExtension.sol:_checkGas"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [
        {
          "name": "paused",
          "expected_setters": [
            "setPaused"
          ],
          "observed_setters": [
            "setPaused"
          ],
          "note": "Disables trading when true"
        }
      ],
      "math_scale_hints": [
        {
          "id": "TradingExtension.sol:priceWithSpread",
          "file": "TradingExtension.sol",
          "element_name": "getVerifiedPrice",
          "op": "mul",
          "lhs": "_price",
          "rhs": "_spread",
          "scale": 1,
          "comment": "Price adjusted by spread: _price +=/-= _price * _spread / DIVISION_CONSTANT"
        }
      ]
    },
    {
      "id": "Position.sol",
      "file_name": "Position.sol",
      "core_purpose_raw": "Position is an ERC721Enumerable NFT contract that represents user trading positions as NFTs. It tracks all open positions, limit orders, and manages funding rate calculations, margin/leverage modifications, and reward accounting. Only minter contracts (Trading) can mint, burn, or modify positions.",
      "core_purpose_digest": "NFT contract for user trading positions, manages open/limit positions and funding rates.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable",
        "IPosition"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "minter",
        "owner"
      ],
      "key_state_vars": [
        "_assetOpenPositions",
        "_assetOpenPositionsIndexes",
        "_isMinter",
        "_limitOrderIndexes",
        "_limitOrders",
        "_openPositions",
        "_openPositionsIndexes",
        "_trades",
        "accInterestPerOi",
        "fundingDeltaPerSec",
        "initId",
        "lastUpdate",
        "longOi",
        "shortOi",
        "vaultFundingPercent"
      ],
      "key_functions": [
        "addToPosition",
        "burn",
        "mint",
        "modifyMargin",
        "modifySl",
        "modifyTp",
        "reducePosition",
        "setAccInterest",
        "updateFunding"
      ],
      "external_dependencies": [
        "ERC721Enumerable"
      ],
      "security_notes": [
        "Only minter contracts can modify state.",
        "ERC721Enumerable ensures safe enumeration and transfer logic.",
        "Funding rate and interest calculations are sensitive to timestamp and open interest changes.",
        "Position ownership is enforced via ERC721 ownerOf."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "Position.sol:fundingDeltaPerSec",
          "file": "Position.sol",
          "element_name": "updateFunding",
          "op": "div",
          "lhs": "_oiDelta*int256(_baseFundingRate)",
          "rhs": "DIVISION_CONSTANT*31536000",
          "scale": 1,
          "comment": "Funding rate per second calculation"
        }
      ]
    },
    {
      "id": "PairsContract.sol",
      "file_name": "PairsContract.sol",
      "core_purpose_raw": "PairsContract manages the list of tradable assets, their parameters (leverage, fee multipliers, funding rates), and open interest tracking for each asset and margin token. It enforces max open interest limits and asset whitelisting. Only the protocol or owner can modify state.",
      "core_purpose_digest": "Manages tradable assets, parameters, and open interest limits for each asset.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPairsContract"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner",
        "protocol"
      ],
      "key_state_vars": [
        "_idToAsset",
        "_idToOi",
        "allowedAsset",
        "maxBaseFundingRate",
        "protocol"
      ],
      "key_functions": [
        "addAsset",
        "modifyLongOi",
        "modifyShortOi",
        "pauseAsset",
        "setAssetBaseFundingRate",
        "setAssetChainlinkFeed",
        "setMaxOi",
        "updateAssetFeeMultiplier",
        "updateAssetLeverage"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Enforces max open interest per asset and margin token.",
        "Only protocol can modify open interest.",
        "Asset parameters are only settable by owner.",
        "Chainlink feed addresses must be set per asset and chain."
      ],
      "config_params": [
        {
          "name": "maxBaseFundingRate",
          "storage_key": "maxBaseFundingRate",
          "load_site": {
            "id": "PairsContract.sol:maxBaseFundingRate",
            "file": "PairsContract.sol",
            "element_name": "maxBaseFundingRate",
            "unique_snippet": "uint256 private maxBaseFundingRate = 1e10;"
          },
          "downstream_uses": [
            "PairsContract.sol:setAssetBaseFundingRate"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "Referrals.sol",
      "file_name": "Referrals.sol",
      "core_purpose_raw": "Referrals manages referral codes and tracks which users have been referred by which code. It allows users to create codes and the protocol to set referred users. Used for distributing referral rewards in Trading.",
      "core_purpose_digest": "Manages referral codes and user referral relationships for fee distribution.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IReferrals"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner",
        "protocol"
      ],
      "key_state_vars": [
        "_referral",
        "_referred",
        "protocol"
      ],
      "key_functions": [
        "createReferralCode",
        "getReferral",
        "getReferred",
        "setReferred"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Only protocol can set referred users.",
        "Referral codes are unique and cannot be overwritten."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "GovNFT.sol",
      "file_name": "GovNFT.sol",
      "core_purpose_raw": "GovNFT is an ERC721Enumerable NFT contract representing governance rights. Holders receive rewards from trading fees, can bridge NFTs cross-chain via LayerZero, and claim rewards in supported assets. The contract manages reward distribution and cross-chain minting/burning.",
      "core_purpose_digest": "Governance NFT for fee rewards, supports cross-chain bridging and reward claiming.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable",
        "ILayerZeroReceiver",
        "IGovNFT"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "MAX",
        "_allowedAsset",
        "accRewardsPerNFT",
        "assets",
        "assetsIndex",
        "baseURI",
        "counter",
        "endpoint",
        "failedMessages",
        "gas",
        "isTrustedAddress",
        "maxBridge",
        "userDebt",
        "userPaid"
      ],
      "key_functions": [
        "addAsset",
        "claim",
        "crossChain",
        "distribute",
        "mint",
        "setAllowedAsset"
      ],
      "external_dependencies": [
        "ERC721Enumerable",
        "LayerZero"
      ],
      "security_notes": [
        "Cross-chain minting/burning is restricted to trusted addresses.",
        "Reward distribution is per NFT and asset.",
        "ERC721Enumerable ensures safe enumeration and transfer logic."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "StableToken.sol",
      "file_name": "StableToken.sol",
      "core_purpose_raw": "StableToken is an ERC20Permit token used as the protocol's stablecoin. Only minters can mint or burn tokens. Used for margin, rewards, and vault operations.",
      "core_purpose_digest": "ERC20Permit stablecoin for margin, rewards, and vault operations.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC20Permit"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "minter",
        "owner"
      ],
      "key_state_vars": [
        "isMinter"
      ],
      "key_functions": [
        "burnFrom",
        "mintFor",
        "setMinter"
      ],
      "external_dependencies": [
        "ERC20Permit"
      ],
      "security_notes": [
        "Only minters can mint or burn.",
        "ERC20Permit allows gasless approvals."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "StableVault.sol",
      "file_name": "StableVault.sol",
      "core_purpose_raw": "StableVault manages deposits and withdrawals of various whitelisted stablecoins, minting or burning the protocol's stablecoin (tigAsset) as needed. It ensures only allowed tokens can be deposited or withdrawn.",
      "core_purpose_digest": "Manages stablecoin deposits/withdrawals, mints/burns protocol stablecoin.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IERC20",
        "IERC20Mintable",
        "ERC20Permit"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "allowed",
        "stable",
        "tokenIndex",
        "tokens"
      ],
      "key_functions": [
        "delistToken",
        "deposit",
        "depositWithPermit",
        "listToken",
        "withdraw"
      ],
      "external_dependencies": [],
      "security_notes": [
        "ReentrancyGuard is used for deposit/withdraw.",
        "Only whitelisted tokens can be deposited/withdrawn.",
        "Decimals are handled for each token."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "Lock.sol",
      "file_name": "Lock.sol",
      "core_purpose_raw": "Lock allows users to lock protocol stablecoins for a period to earn rewards, creating BondNFTs. It manages claims, extensions, releases, and distributes rewards from GovNFTs to bonds.",
      "core_purpose_digest": "Allows users to lock tokens for rewards, manages BondNFTs and reward distribution.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IBondNFT",
        "IGovNFT",
        "IERC20"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "allowedAssets",
        "bondNFT",
        "govNFT",
        "maxPeriod",
        "minPeriod",
        "totalLocked"
      ],
      "key_functions": [
        "claim",
        "claimDebt",
        "claimGovFees",
        "editAsset",
        "extendLock",
        "lock",
        "release",
        "sendNFTs"
      ],
      "external_dependencies": [
        "BondNFT",
        "GovNFT"
      ],
      "security_notes": [
        "Only allowed assets can be locked.",
        "BondNFTs are used to represent locked positions.",
        "Reward distribution is handled via GovNFT claims."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "BondNFT.sol",
      "file_name": "BondNFT.sol",
      "core_purpose_raw": "BondNFT is an ERC721Enumerable NFT contract representing locked positions for rewards. It tracks bond parameters, manages reward distribution, and enforces lock/extension/release logic. Only the manager contract can mint, extend, or release bonds.",
      "core_purpose_digest": "NFT contract for locked positions, manages rewards and lock lifecycle.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "manager",
        "owner"
      ],
      "key_state_vars": [
        "_idToBond",
        "accRewardsPerShare",
        "allowedAsset",
        "assets",
        "assetsIndex",
        "baseURI",
        "bondPaid",
        "epoch",
        "manager",
        "totalBonds",
        "totalShares",
        "userDebt"
      ],
      "key_functions": [
        "addAsset",
        "claim",
        "claimDebt",
        "createLock",
        "distribute",
        "extendLock",
        "release",
        "setAllowedAsset",
        "setManager"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Only manager can mint, extend, or release bonds.",
        "Reward distribution is per share and epoch.",
        "ERC721Enumerable ensures safe enumeration and transfer logic."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The TigerSwap protocol is a decentralized perpetual trading platform that allows users to trade various assets with leverage. The protocol enables traders to open long or short positions, set take-profit and stop-loss orders, and manage their positions through a comprehensive set of functions. It uses NFT-based positions, a custom stablecoin, and distributes fees to governance and liquidity providers.",
    "overall_goal_digest": "Decentralized leveraged trading platform with NFT positions, custom stablecoin, and fee/reward system.",
    "actors_capabilities": [
      "Governance: modify protocol parameters and settings.",
      "Limit Order Executors: execute limit orders for a fee.",
      "Liquidators: liquidate undercollateralized positions.",
      "Proxy Wallets: trade on behalf of traders with approval.",
      "Referrers: refer users and earn a portion of trading fees.",
      "Traders: open/close/modify positions, set TP/SL, approve proxies."
    ],
    "core_assets": [
      "BondNFT",
      "GovNFT",
      "Lock",
      "PairsContract",
      "Position NFT",
      "StableToken",
      "StableVault",
      "Trading contract",
      "TradingExtension"
    ],
    "critical_interactions": [
      "Trading <-> TradingExtension: price verification, trade validation.",
      "Trading <-> Position: mint/burn/modify NFT positions.",
      "Trading <-> PairsContract: asset parameters, open interest.",
      "Trading <-> GovNFT: fee distribution.",
      "Trading <-> StableVault: margin deposits/withdrawals.",
      "Lock <-> BondNFT: create/extend/release bonds.",
      "Lock <-> GovNFT: claim and distribute rewards.",
      "GovNFT <-> LayerZero: cross-chain NFT bridging."
    ],
    "key_assumptions": [
      {
        "id": "oracle-sig-assumption",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Price data is signed by whitelisted oracles and signatures are checked on-chain."
      },
      {
        "id": "chainlink-feed-assumption",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Chainlink feeds are used for price sanity checks when enabled, and addresses must be set per chain."
      },
      {
        "id": "proxy-approval-assumption",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Proxy wallets must be explicitly approved by traders and are time-limited."
      },
      {
        "id": "nft-ownership-assumption",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Position and bond NFTs represent ownership and are non-fungible and transferable."
      }
    ],
    "invariants": [
      {
        "id": "inv-1",
        "description": "_handleDeposit preserves tigAsset balance",
        "related_code": [
          "Trading.sol:_handleDeposit"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-2",
        "description": "Stop-loss price must be valid relative to market price",
        "related_code": [
          "Trading.sol:_checkSl"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-3",
        "description": "StableVault input must be whitelisted and token allowed",
        "related_code": [
          "Trading.sol:_checkVault"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-4",
        "description": "Proxy must be approved before trading on behalf",
        "related_code": [
          "Trading.sol:_validateProxy"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-5",
        "description": "Trade margin*leverage must satisfy minPositionSize",
        "related_code": [
          "TradingExtension.sol:validateTrade"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-6",
        "description": "Trade leverage within allowed bounds",
        "related_code": [
          "TradingExtension.sol:validateTrade"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-7",
        "description": "Verified price signature must be from an allowed node",
        "related_code": [
          "TradingLibrary.sol:verifyPrice"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-8",
        "description": "Price timestamp must be within valid signature window",
        "related_code": [
          "TradingLibrary.sol:verifyPrice"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-9",
        "description": "updateFunding must set OI exactly to parameters",
        "related_code": [
          "Position.sol:updateFunding"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-10",
        "description": "fundingDeltaPerSec computed correctly in updateFunding",
        "related_code": [
          "Position.sol:updateFunding"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-11",
        "description": "mint initializes trade and assigns ownership",
        "related_code": [
          "Position.sol:mint"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-12",
        "description": "PairsContract.modifyLongOi never exceeds maxOi on open",
        "related_code": [
          "PairsContract.sol:modifyLongOi"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-13",
        "description": "PairsContract.modifyShortOi never exceeds maxOi on open",
        "related_code": [
          "PairsContract.sol:modifyShortOi"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-14",
        "description": "StableVault deposit mints correct stable amount",
        "related_code": [
          "StableVault.sol:deposit"
        ],
        "aggregate_of": null,
        "delay_guard": null,
        "origin": "check"
      },
      {
        "id": "inv-15",
        "description": "Limit orders must respect delay before execution",
        "related_code": [
          "Trading.sol:executeLimitOrder"
        ],
        "aggregate_of": null,
        "delay_guard": true,
        "origin": "check"
      }
    ],
    "general_security_ctx": [
      {
        "id": "layerzero-security",
        "source": "web_context",
        "context_type": "tooling_note",
        "details": "LayerZero endpoints are permissionless and immutable; security is per-channel and settings are immutable except by delegate. Verification and execution are separated to reduce attack surface."
      },
      {
        "id": "chainlink-security",
        "source": "web_context",
        "context_type": "tooling_note",
        "details": "Chainlink feeds are upgradeable via multisig; always check price freshness and decimals. Use try/catch and fallback logic for oracle failures."
      },
      {
        "id": "erc721enumerable-security",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "ERC721Enumerable prevents batch minting, enforces bounds checks, and uses atomic updates for safe enumeration."
      },
      {
        "id": "arbitrum-l2-differences",
        "source": "web_context",
        "context_type": "tooling_note",
        "details": "On Arbitrum, blockhash, coinbase, and difficulty are not secure for randomness; block.number and timestamps differ from L1. Do not use for critical logic."
      }
    ],
    "static_summary": null
  }
}