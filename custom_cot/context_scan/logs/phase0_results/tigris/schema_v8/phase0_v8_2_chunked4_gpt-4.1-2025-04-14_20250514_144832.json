{
  "analyzed_contracts": [
    {
      "id": "Trading.sol",
      "file_name": "Trading.sol",
      "core_purpose_raw": "The Trading contract is the main user-facing entry point for the TigerSwap protocol, enabling users to open, modify, and close leveraged perpetual trading positions. It manages market and limit orders, margin adjustments, liquidation, fee distribution, and proxy trading. It interacts with other protocol contracts for price verification, position NFT minting, open interest tracking, and stablecoin vault operations.",
      "core_purpose_digest": "Main entry for leveraged trading: open/close/modify positions, manage margin, fees, and interact with protocol modules.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ITradingExtension",
        "IPairsContract",
        "IPosition",
        "IGovNFT",
        "IStableVault",
        "IERC20"
      ],
      "compiler_version": null,
      "identified_roles": [
        "limit order executor",
        "liquidator",
        "owner",
        "proxy",
        "referrer",
        "trader"
      ],
      "key_state_vars": [
        "allowedVault",
        "blockDelay",
        "blockDelayPassed",
        "closeFees",
        "gov",
        "limitDelay",
        "limitOrderPriceRange",
        "maxWinPercent",
        "openFees",
        "pairsContract",
        "position",
        "proxyApprovals",
        "tradingExtension",
        "vaultFundingPercent"
      ],
      "key_functions": [
        "addMargin",
        "addToPosition",
        "approveProxy",
        "cancelLimitOrder",
        "executeLimitOrder",
        "initiateCloseOrder",
        "initiateLimitOrder",
        "initiateMarketOrder",
        "limitClose",
        "liquidatePosition",
        "removeMargin",
        "setAllowedVault",
        "setBlockDelay",
        "setFees",
        "setLimitOrderPriceRange",
        "setMaxWinPercent",
        "setTradingExtension",
        "updateTpSl"
      ],
      "external_dependencies": [
        "Chainlink price feed",
        "GovNFT",
        "IERC20",
        "LayerZero endpoint",
        "PairsContract",
        "Position",
        "StableVault",
        "TradingExtension"
      ],
      "security_notes": [
        "Proxy trading requires explicit approval and timestamp.",
        "All vaults and margin assets must be whitelisted.",
        "Price data must be signed by an allowed node and within a valid time window.",
        "Limit order execution requires a minimum delay.",
        "Liquidation threshold enforced to prevent undercollateralization.",
        "Fee distribution logic is complex and must be carefully reviewed for rounding and overflow.",
        "Reentrancy is not explicitly guarded; relies on external contract safety.",
        "Meta-transactions supported via MetaContext.",
        "All critical state changes gated by onlyOwner or onlyMinter as appropriate."
      ],
      "config_params": [
        {
          "name": "blockDelay",
          "storage_key": "blockDelay",
          "load_site": {
            "id": "Trading.sol:blockDelay",
            "file": "Trading.sol",
            "element_name": "blockDelay",
            "unique_snippet": "uint public blockDelay;"
          },
          "downstream_uses": [
            "Trading.sol:_checkDelay"
          ],
          "role": "misc"
        },
        {
          "name": "limitOrderPriceRange",
          "storage_key": "limitOrderPriceRange",
          "load_site": {
            "id": "Trading.sol:limitOrderPriceRange",
            "file": "Trading.sol",
            "element_name": "limitOrderPriceRange",
            "unique_snippet": "uint public limitOrderPriceRange = 1e8; // 1%"
          },
          "downstream_uses": [
            "Trading.sol:executeLimitOrder"
          ],
          "role": "upper_bound"
        },
        {
          "name": "maxWinPercent",
          "storage_key": "maxWinPercent",
          "load_site": {
            "id": "Trading.sol:maxWinPercent",
            "file": "Trading.sol",
            "element_name": "maxWinPercent",
            "unique_snippet": "uint public maxWinPercent;"
          },
          "downstream_uses": [
            "Trading.sol:_closePosition"
          ],
          "role": "upper_bound"
        },
        {
          "name": "vaultFundingPercent",
          "storage_key": "vaultFundingPercent",
          "load_site": {
            "id": "Trading.sol:vaultFundingPercent",
            "file": "Trading.sol",
            "element_name": "vaultFundingPercent",
            "unique_snippet": "uint public vaultFundingPercent;"
          },
          "downstream_uses": [
            "Trading.sol:_updateFunding"
          ],
          "role": "multiplier"
        }
      ],
      "flag_trackers": [
        {
          "name": "proxyApprovals",
          "expected_setters": [
            "approveProxy"
          ],
          "observed_setters": [
            "approveProxy"
          ],
          "lifecycle": "toggle",
          "note": "Tracks proxy trading rights for each trader"
        }
      ],
      "math_scale_hints": [
        {
          "id": "Trading.sol:leverage-math",
          "file": "Trading.sol",
          "element_name": "initiateMarketOrder",
          "op": "mul",
          "lhs": "_tradeInfo.margin",
          "rhs": "_tradeInfo.leverage",
          "scale": 1,
          "comment": "Position size = margin * leverage / 1e18"
        }
      ],
      "aggregate_trackers": [
        {
          "id": "oi-tracker",
          "name": "Open Interest",
          "must_increase_on": [
            "initiateMarketOrder",
            "addToPosition",
            "executeLimitOrder"
          ],
          "must_decrease_on": [
            "liquidatePosition",
            "initiateCloseOrder",
            "limitClose"
          ]
        }
      ],
      "delay_guards": [
        {
          "id": "limitDelay",
          "guard_fn": "executeLimitOrder",
          "delay_type": "timestamp",
          "period": 4
        },
        {
          "id": "blockDelayPassed",
          "guard_fn": "_checkDelay",
          "delay_type": "block",
          "period": 0
        }
      ],
      "external_flows": [
        {
          "file": "Trading.sol",
          "function": "_handleDeposit",
          "call_sig": "IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier)",
          "expected_effect": "Deposits margin asset into StableVault and mints tigAsset",
          "risk": "StableVault must be trusted; reentrancy risk if not safe"
        },
        {
          "file": "Trading.sol",
          "function": "_handleWithdraw",
          "call_sig": "IStableVault(_stableVault).withdraw(_outputToken, _toMint)",
          "expected_effect": "Withdraws output token from StableVault for trader",
          "risk": "StableVault must be trusted; output token decimals must be correct"
        },
        {
          "file": "Trading.sol",
          "function": "getVerifiedPrice",
          "call_sig": "tradingExtension.getVerifiedPrice(...)",
          "expected_effect": "Fetches and verifies price from off-chain oracle",
          "risk": "Oracle signature and timestamp must be valid; price manipulation risk"
        }
      ],
      "business_rules": [
        {
          "description": "Only whitelisted vaults and margin assets can be used for trading",
          "related_contracts": [
            "TradingExtension",
            "StableVault"
          ],
          "severity_if_broken": "High"
        },
        {
          "description": "Proxy trading only allowed for approved proxies within time window",
          "related_contracts": [
            "Trading"
          ],
          "severity_if_broken": "High"
        }
      ],
      "numeric_guards": [
        {
          "var_name": "_leverage",
          "guard_expr": "_leverage >= asset.minLeverage && _leverage <= asset.maxLeverage",
          "failure_mode": "Revert with '!lev'"
        },
        {
          "var_name": "_margin * _leverage / 1e18",
          "guard_expr": ">= minPositionSize[_tigAsset]",
          "failure_mode": "Revert with '!size'"
        }
      ]
    },
    {
      "id": "TradingExtension.sol",
      "file_name": "TradingExtension.sol",
      "core_purpose_raw": "TradingExtension is a support contract for the Trading contract, providing price verification (including signature and optional Chainlink checks), referral management, position validation, and open interest modification. It enforces minimum position sizes, margin asset whitelisting, and protocol pause logic.",
      "core_purpose_digest": "Verifies prices, manages referrals, validates trades, and enforces protocol rules for Trading.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPairsContract",
        "IReferrals",
        "IPosition"
      ],
      "compiler_version": null,
      "identified_roles": [
        "owner",
        "protocol"
      ],
      "key_state_vars": [
        "allowedMargin",
        "chainlinkEnabled",
        "isNode",
        "maxGasPrice",
        "minPositionSize",
        "paused",
        "validSignatureTimer"
      ],
      "key_functions": [
        "getVerifiedPrice",
        "modifyLongOi",
        "modifyShortOi",
        "setAllowedMargin",
        "setMinPositionSize",
        "setNode",
        "setPaused",
        "validateTrade"
      ],
      "external_dependencies": [
        "Chainlink price feed",
        "PairsContract",
        "Position",
        "Referrals"
      ],
      "security_notes": [
        "Price verification requires valid signature and node whitelisting.",
        "Chainlink price check is optional but can be enabled for extra safety.",
        "Gas price is capped for protocol actions.",
        "Only protocol (Trading) can call sensitive functions.",
        "Paused state disables trading.",
        "Minimum position size and allowed margin assets are enforced."
      ],
      "config_params": [
        {
          "name": "validSignatureTimer",
          "storage_key": "validSignatureTimer",
          "load_site": {
            "id": "TradingExtension.sol:validSignatureTimer",
            "file": "TradingExtension.sol",
            "element_name": "validSignatureTimer",
            "unique_snippet": "uint256 public validSignatureTimer;"
          },
          "downstream_uses": [
            "TradingExtension.sol:getVerifiedPrice"
          ],
          "role": "upper_bound"
        },
        {
          "name": "maxGasPrice",
          "storage_key": "maxGasPrice",
          "load_site": {
            "id": "TradingExtension.sol:maxGasPrice",
            "file": "TradingExtension.sol",
            "element_name": "maxGasPrice",
            "unique_snippet": "uint public maxGasPrice = 1000000000000; // 1000 gwei"
          },
          "downstream_uses": [
            "TradingExtension.sol:_checkGas"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [
        {
          "name": "paused",
          "expected_setters": [
            "setPaused"
          ],
          "observed_setters": [
            "setPaused"
          ],
          "lifecycle": "toggle",
          "note": "Pauses all trading activity"
        }
      ],
      "math_scale_hints": [
        {
          "id": "TradingExtension.sol:spread-math",
          "file": "TradingExtension.sol",
          "element_name": "getVerifiedPrice",
          "op": "mul",
          "lhs": "_price",
          "rhs": "_spread",
          "scale": 1,
          "comment": "Spread adjustment for price"
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [
        {
          "file": "TradingExtension.sol",
          "function": "getVerifiedPrice",
          "call_sig": "TradingLibrary.verifyPrice(...)",
          "expected_effect": "Verifies price signature and optionally checks Chainlink price",
          "risk": "Oracle manipulation or stale data if not properly checked"
        }
      ],
      "business_rules": [
        {
          "description": "Only allowed margin assets can be used for trading",
          "related_contracts": [
            "TradingExtension"
          ],
          "severity_if_broken": "High"
        },
        {
          "description": "Trading can be paused by owner",
          "related_contracts": [
            "TradingExtension"
          ],
          "severity_if_broken": "Medium"
        }
      ],
      "numeric_guards": [
        {
          "var_name": "_leverage",
          "guard_expr": "_leverage >= asset.minLeverage && _leverage <= asset.maxLeverage",
          "failure_mode": "Revert with '!lev'"
        },
        {
          "var_name": "_margin * _leverage / 1e18",
          "guard_expr": ">= minPositionSize[_tigAsset]",
          "failure_mode": "Revert with '!size'"
        }
      ]
    },
    {
      "id": "Position.sol",
      "file_name": "Position.sol",
      "core_purpose_raw": "Position is an ERC721Enumerable NFT contract that represents user trading positions as NFTs. It stores all trade data, manages minting, burning, and modification of positions, and tracks open interest and funding rates. It is only callable by authorized minters (Trading contract).",
      "core_purpose_digest": "NFT contract for user positions, manages trade data, open interest, and funding rates.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable",
        "IPosition"
      ],
      "compiler_version": null,
      "identified_roles": [
        "minter",
        "owner"
      ],
      "key_state_vars": [
        "_assetOpenPositions",
        "_assetOpenPositionsIndexes",
        "_isMinter",
        "_limitOrderIndexes",
        "_limitOrders",
        "_openPositions",
        "_openPositionsIndexes",
        "_trades",
        "accInterestPerOi",
        "fundingDeltaPerSec",
        "initId",
        "lastUpdate",
        "longOi",
        "shortOi"
      ],
      "key_functions": [
        "addToPosition",
        "burn",
        "executeLimitOrder",
        "mint",
        "modifyMargin",
        "modifySl",
        "modifyTp",
        "reducePosition",
        "setAccInterest",
        "updateFunding"
      ],
      "external_dependencies": [
        "ERC721Enumerable"
      ],
      "security_notes": [
        "Only minter (Trading) can mint/burn/modify positions.",
        "ERC721Enumerable ensures safe enumeration and prevents batch minting.",
        "Funding and open interest are updated atomically with position changes.",
        "All position data is deleted on burn.",
        "Meta-transactions supported via MetaContext."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "_isMinter",
          "expected_setters": [
            "setMinter"
          ],
          "observed_setters": [
            "setMinter"
          ],
          "lifecycle": "toggle",
          "note": "Controls which contracts can mint/burn/modify positions"
        }
      ],
      "math_scale_hints": [
        {
          "id": "Position.sol:funding-math",
          "file": "Position.sol",
          "element_name": "updateFunding",
          "op": "div",
          "lhs": "_oiDelta*int256(_baseFundingRate)",
          "rhs": "int256(DIVISION_CONSTANT)*31536000",
          "scale": 1,
          "comment": "Funding rate per second calculation"
        }
      ],
      "aggregate_trackers": [
        {
          "id": "openPositions",
          "name": "Open Positions",
          "must_increase_on": [
            "mint",
            "executeLimitOrder"
          ],
          "must_decrease_on": [
            "burn"
          ]
        }
      ],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [
        {
          "description": "Only minter can mint, burn, or modify positions",
          "related_contracts": [
            "Trading"
          ],
          "severity_if_broken": "High"
        }
      ],
      "numeric_guards": []
    },
    {
      "id": "PairsContract.sol",
      "file_name": "PairsContract.sol",
      "core_purpose_raw": "PairsContract manages the list of tradable assets, their parameters (leverage, fee multipliers, funding rates), and tracks open interest (OI) for each asset and margin token. It enforces OI caps and asset whitelisting, and is only modifiable by the owner or protocol.",
      "core_purpose_digest": "Manages tradable assets, their parameters, and open interest tracking for the protocol.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPairsContract",
        "IPosition"
      ],
      "compiler_version": null,
      "identified_roles": [
        "owner",
        "protocol"
      ],
      "key_state_vars": [
        "_idToAsset",
        "_idToOi",
        "allowedAsset",
        "maxBaseFundingRate",
        "protocol"
      ],
      "key_functions": [
        "addAsset",
        "modifyLongOi",
        "modifyShortOi",
        "pauseAsset",
        "setAssetBaseFundingRate",
        "setAssetChainlinkFeed",
        "setMaxBaseFundingRate",
        "setMaxOi",
        "setProtocol",
        "updateAssetFeeMultiplier",
        "updateAssetLeverage"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Only owner can add or modify asset parameters.",
        "Open interest cannot exceed maxOi per asset and margin token.",
        "Protocol address must be set for OI modification.",
        "Asset whitelisting enforced for trading."
      ],
      "config_params": [
        {
          "name": "maxBaseFundingRate",
          "storage_key": "maxBaseFundingRate",
          "load_site": {
            "id": "PairsContract.sol:maxBaseFundingRate",
            "file": "PairsContract.sol",
            "element_name": "maxBaseFundingRate",
            "unique_snippet": "uint256 private maxBaseFundingRate = 1e10;"
          },
          "downstream_uses": [
            "PairsContract.sol:setAssetBaseFundingRate"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [
        {
          "id": "oi-tracker",
          "name": "Open Interest",
          "must_increase_on": [
            "modifyLongOi (onOpen)",
            "modifyShortOi (onOpen)"
          ],
          "must_decrease_on": [
            "modifyLongOi (!onOpen)",
            "modifyShortOi (!onOpen)"
          ]
        }
      ],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [
        {
          "description": "Open interest for long/short cannot exceed maxOi on open",
          "related_contracts": [
            "PairsContract"
          ],
          "severity_if_broken": "High"
        },
        {
          "description": "Only owner can add or modify asset parameters",
          "related_contracts": [
            "PairsContract"
          ],
          "severity_if_broken": "High"
        }
      ],
      "numeric_guards": [
        {
          "var_name": "_idToOi[_asset][_tigAsset].longOi",
          "guard_expr": "<= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0",
          "failure_mode": "Revert with 'MaxLongOi'"
        },
        {
          "var_name": "_idToOi[_asset][_tigAsset].shortOi",
          "guard_expr": "<= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0",
          "failure_mode": "Revert with 'MaxShortOi'"
        }
      ]
    },
    {
      "id": "Referrals",
      "file_name": "Referrals.sol",
      "core_purpose_raw": "The Referrals contract manages referral codes and tracks which users have been referred by which codes. Any address can create a referral code, and only the protocol (settable by the owner) can set a user's referred code. The contract also allows the owner to initialize referral data in bulk (deprecated).",
      "core_purpose_digest": "Manages referral codes and tracks user referrals; protocol-controlled, owner-initializable.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IReferrals",
        "Ownable"
      ],
      "compiler_version": "^0.8.0",
      "identified_roles": [
        "owner",
        "protocol"
      ],
      "key_state_vars": [
        "_referral",
        "_referred",
        "isInit",
        "protocol"
      ],
      "key_functions": [
        "createReferralCode",
        "getReferral",
        "getReferred",
        "initRefs",
        "setProtocol",
        "setReferred"
      ],
      "external_dependencies": [
        "./interfaces/IReferrals.sol",
        "@openzeppelin/contracts/access/Ownable.sol"
      ],
      "security_notes": [
        "Only protocol can set referred users.",
        "Owner can set protocol address.",
        "initRefs can only be called once (isInit flag)."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "isInit",
          "expected_setters": [
            "initRefs"
          ],
          "observed_setters": [
            "initRefs"
          ],
          "lifecycle": "init_once",
          "note": "Prevents re-initialization of referral data."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "GovNFT",
      "file_name": "GovNFT.sol",
      "core_purpose_raw": "GovNFT is an ERC721Enumerable NFT contract with cross-chain bridging via LayerZero. It supports minting, burning, and transferring NFTs, as well as distributing and claiming ERC20 rewards to NFT holders. It manages trusted cross-chain addresses, failed message retries, and reward asset whitelisting.",
      "core_purpose_digest": "ERC721 NFT with cross-chain bridging, reward distribution, and asset whitelisting.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable",
        "ILayerZeroReceiver",
        "MetaContext",
        "IGovNFT"
      ],
      "compiler_version": "^0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "MAX",
        "_allowedAsset",
        "accRewardsPerNFT",
        "assets",
        "assetsIndex",
        "baseURI",
        "counter",
        "endpoint",
        "failedMessages",
        "gas",
        "isTrustedAddress",
        "maxBridge",
        "userDebt",
        "userPaid"
      ],
      "key_functions": [
        "addAsset",
        "claim",
        "crossChain",
        "distribute",
        "lzReceive",
        "mint",
        "mintMany",
        "nonblockingLzReceive",
        "retryMessage",
        "setAllowedAsset"
      ],
      "external_dependencies": [
        "./interfaces/IGovNFT.sol",
        "./interfaces/ILayerZeroEndpoint.sol",
        "./interfaces/ILayerZeroReceiver.sol",
        "./utils/ExcessivelySafeCall.sol",
        "./utils/MetaContext.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"
      ],
      "security_notes": [
        "Cross-chain minting and message handling via LayerZero.",
        "Trusted addresses must be set for cross-chain operations.",
        "Owner can add/remove reward assets.",
        "Reentrancy not explicitly guarded in claim/distribute."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "GovNFT-distribute-accRewardsPerNFT",
          "file": "GovNFT.sol",
          "element_name": "distribute",
          "op": "div",
          "lhs": "_amount",
          "rhs": "totalSupply()",
          "scale": 0,
          "comment": "Distributes rewards per NFT; risk of truncation if _amount not divisible by totalSupply."
        }
      ],
      "aggregate_trackers": [
        {
          "id": "GovNFT-totalSupply",
          "name": "totalSupply",
          "must_increase_on": [
            "mint",
            "mintMany",
            "_bridgeMint"
          ],
          "must_decrease_on": [
            "_burn",
            "crossChain"
          ]
        }
      ],
      "delay_guards": [],
      "external_flows": [
        {
          "file": "GovNFT.sol",
          "function": "claim",
          "call_sig": "IERC20(_tigAsset).transfer(_msgsender, amount)",
          "expected_effect": "Transfers pending rewards to user",
          "risk": null
        },
        {
          "file": "GovNFT.sol",
          "function": "distribute",
          "call_sig": "IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)",
          "expected_effect": "Collects reward tokens for distribution",
          "risk": null
        }
      ],
      "business_rules": [],
      "numeric_guards": [
        {
          "var_name": "counter",
          "guard_expr": "counter <= MAX",
          "failure_mode": "Exceeds supply"
        },
        {
          "var_name": "tokenId",
          "guard_expr": "tokenId <= 10000",
          "failure_mode": "BadID"
        }
      ]
    },
    {
      "id": "StableToken",
      "file_name": "StableToken.sol",
      "core_purpose_raw": "StableToken is an ERC20 token with permit functionality and a minter role. Only addresses with the minter role can mint or burn tokens. The owner can assign or revoke minter status.",
      "core_purpose_digest": "ERC20 with permit and minter role; only minters can mint/burn; owner manages minters.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC20Permit",
        "MetaContext"
      ],
      "compiler_version": "^0.8.0",
      "identified_roles": [
        "minter",
        "owner"
      ],
      "key_state_vars": [
        "isMinter"
      ],
      "key_functions": [
        "burnFrom",
        "mintFor",
        "setMinter"
      ],
      "external_dependencies": [
        "./utils/MetaContext.sol",
        "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"
      ],
      "security_notes": [
        "Only minters can mint or burn tokens.",
        "Owner controls minter assignment."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "StableVault",
      "file_name": "StableVault.sol",
      "core_purpose_raw": "StableVault allows users to deposit whitelisted tokens and receive a stable asset (tigAsset) in return, and to withdraw by burning tigAsset for the underlying token. Only owner can list/delist allowed tokens. Supports permit-based deposits.",
      "core_purpose_digest": "Vault for swapping whitelisted tokens to/from stable asset; owner manages allowed tokens.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "MetaContext",
        "IStableVault"
      ],
      "compiler_version": "^0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "allowed",
        "stable",
        "tokenIndex",
        "tokens"
      ],
      "key_functions": [
        "delistToken",
        "deposit",
        "depositWithPermit",
        "listToken",
        "withdraw"
      ],
      "external_dependencies": [
        "./interfaces/IStableVault.sol",
        "./utils/MetaContext.sol",
        "@openzeppelin/contracts/security/ReentrancyGuard.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      ],
      "security_notes": [
        "Only owner can list/delist tokens.",
        "Deposit/withdraw logic depends on correct decimals.",
        "No explicit reentrancy guard on deposit/withdraw."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "StableVault-deposit-mintFor",
          "file": "StableVault.sol",
          "element_name": "deposit",
          "op": "mul",
          "lhs": "_amount",
          "rhs": "10**(18-IERC20Mintable(_token).decimals())",
          "scale": 18,
          "comment": "Normalizes deposited token to 18 decimals for minting stable asset."
        },
        {
          "id": "StableVault-withdraw-burnFrom",
          "file": "StableVault.sol",
          "element_name": "withdraw",
          "op": "div",
          "lhs": "_amount",
          "rhs": "10**(18-IERC20Mintable(_token).decimals())",
          "scale": 18,
          "comment": "Converts stable asset back to token decimals on withdrawal."
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [
        {
          "file": "StableVault.sol",
          "function": "deposit",
          "call_sig": "IERC20(_token).transferFrom(_msgSender(), address(this), _amount)",
          "expected_effect": "Transfers deposit token to vault",
          "risk": null
        },
        {
          "file": "StableVault.sol",
          "function": "withdraw",
          "call_sig": "IERC20(_token).transfer(_msgSender(), _output)",
          "expected_effect": "Transfers withdrawn token to user",
          "risk": null
        }
      ],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "Lock",
      "file_name": "Lock.sol",
      "core_purpose_raw": "Lock allows users to lock whitelisted assets for a period to create bond NFTs, claim rewards, extend locks, and release bonds. It tracks total locked per asset and interacts with BondNFT and GovNFT contracts for reward distribution and NFT management. Only owner can whitelist assets and retrieve NFTs.",
      "core_purpose_digest": "Manages time-locked assets for bond NFTs, reward claiming, and asset whitelisting.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "Ownable"
      ],
      "compiler_version": "^0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "allowedAssets",
        "bondNFT",
        "govNFT",
        "maxPeriod",
        "minPeriod",
        "totalLocked"
      ],
      "key_functions": [
        "claim",
        "claimDebt",
        "claimGovFees",
        "editAsset",
        "extendLock",
        "lock",
        "release",
        "sendNFTs"
      ],
      "external_dependencies": [
        "./interfaces/IBondNFT.sol",
        "./interfaces/IGovNFT.sol",
        "@openzeppelin/contracts/access/Ownable.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "hardhat/console.sol"
      ],
      "security_notes": [
        "Only owner can whitelist assets and retrieve NFTs.",
        "Lock period must be within min/max bounds.",
        "totalLocked updated on lock/release."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [
        {
          "id": "Lock-totalLocked",
          "name": "totalLocked",
          "must_increase_on": [
            "lock"
          ],
          "must_decrease_on": [
            "release"
          ]
        }
      ],
      "delay_guards": [],
      "external_flows": [
        {
          "file": "Lock.sol",
          "function": "lock",
          "call_sig": "IERC20(_asset).transferFrom(msg.sender, address(this), _amount)",
          "expected_effect": "Transfers locked asset to contract",
          "risk": null
        },
        {
          "file": "Lock.sol",
          "function": "release",
          "call_sig": "IERC20(asset).transfer(_owner, amount)",
          "expected_effect": "Transfers released asset to bond owner",
          "risk": null
        }
      ],
      "business_rules": [
        {
          "description": "Lock period must be between minPeriod and maxPeriod.",
          "related_contracts": [
            "Lock"
          ],
          "severity_if_broken": "High"
        }
      ],
      "numeric_guards": [
        {
          "var_name": "_period",
          "guard_expr": "_period <= maxPeriod",
          "failure_mode": "MAX PERIOD"
        },
        {
          "var_name": "_period",
          "guard_expr": "_period >= minPeriod",
          "failure_mode": "MIN PERIOD"
        }
      ]
    },
    {
      "id": "BondNFT",
      "file_name": "BondNFT.sol",
      "core_purpose_raw": "BondNFT is an ERC721Enumerable contract that represents time-locked bond positions as NFTs. Users can lock ERC20 tokens (tigAsset) for a period, receiving a bond NFT that tracks ownership, amount, period, and reward shares. The contract manages reward distribution, bond extension, release, and transfer, with a manager contract controlling sensitive operations. It supports multiple assets, whitelisting, and reward accounting per epoch.",
      "core_purpose_digest": "ERC721 NFT bonds for time-locked ERC20 deposits, with reward distribution and manager-controlled ops.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IERC20",
        "ERC721Enumerable",
        "Ownable"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "manager",
        "owner"
      ],
      "key_state_vars": [
        "_idToBond",
        "accRewardsPerShare",
        "allowedAsset",
        "assets",
        "assetsIndex",
        "baseURI",
        "bondPaid",
        "epoch",
        "manager",
        "totalBonds",
        "totalShares",
        "userDebt"
      ],
      "key_functions": [
        "addAsset",
        "approveMany",
        "claim",
        "claimDebt",
        "createLock",
        "distribute",
        "extendLock",
        "getAssets",
        "idToBond",
        "isExpired",
        "pending",
        "release",
        "safeTransferFromMany",
        "safeTransferMany",
        "setAllowedAsset",
        "setBaseURI",
        "setManager",
        "totalAssets"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/access/Ownable.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"
      ],
      "security_notes": [
        "Manager role is critical for all state-changing operations.",
        "ERC20 transfers rely on external token contracts.",
        "Unchecked math is used throughout; relies on Solidity 0.8+ for overflow checks.",
        "Bond transfer requires epoch alignment and non-expiry.",
        "Reward accounting is per-epoch and per-asset.",
        "Bond extension and release have strict owner and expiry checks."
      ],
      "config_params": [
        {
          "name": "manager",
          "storage_key": "manager",
          "load_site": {
            "id": "BondNFT.onlyManager",
            "file": "BondNFT.sol",
            "element_name": "onlyManager",
            "unique_snippet": "require(msg.sender == manager, \"!manager\");"
          },
          "downstream_uses": [
            "BondNFT.createLock",
            "BondNFT.extendLock",
            "BondNFT.release",
            "BondNFT.claim",
            "BondNFT.claimDebt"
          ],
          "role": "address_key"
        }
      ],
      "flag_trackers": [
        {
          "name": "expired",
          "expected_setters": [
            "idToBond",
            "isExpired"
          ],
          "observed_setters": [
            "idToBond"
          ],
          "lifecycle": "toggle",
          "note": "Indicates if a bond is expired and eligible for release."
        }
      ],
      "math_scale_hints": [
        {
          "id": "BondNFT.sharesCalc",
          "file": "BondNFT.sol",
          "element_name": "createLock/extendLock",
          "op": "mul",
          "lhs": "_amount",
          "rhs": "_period",
          "scale": 365,
          "comment": "Shares = amount * period / 365; period is in days."
        },
        {
          "id": "BondNFT.accRewardsPerShare",
          "file": "BondNFT.sol",
          "element_name": "distribute",
          "op": "div",
          "lhs": "_amount * 1e18",
          "rhs": "totalShares[_tigAsset]",
          "scale": 1,
          "comment": "Reward per share uses 1e18 scaling."
        }
      ],
      "aggregate_trackers": [
        {
          "id": "totalShares",
          "name": "totalShares",
          "must_increase_on": [
            "createLock",
            "extendLock"
          ],
          "must_decrease_on": [
            "release"
          ]
        }
      ],
      "delay_guards": [
        {
          "id": "BondNFT.transferDelay",
          "guard_fn": "_transfer",
          "delay_type": "timestamp",
          "period": 300
        }
      ],
      "external_flows": [
        {
          "file": "BondNFT.sol",
          "function": "claim",
          "call_sig": "IERC20(tigAsset).transfer(manager, amount)",
          "expected_effect": "Transfers claimed rewards to manager",
          "risk": "Relies on external ERC20 transfer; manager must be trusted"
        },
        {
          "file": "BondNFT.sol",
          "function": "claimDebt",
          "call_sig": "IERC20(_tigAsset).transfer(manager, amount)",
          "expected_effect": "Transfers user debt to manager",
          "risk": "Relies on external ERC20 transfer; manager must be trusted"
        },
        {
          "file": "BondNFT.sol",
          "function": "distribute",
          "call_sig": "IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)",
          "expected_effect": "Collects rewards from sender",
          "risk": "Relies on external ERC20 transferFrom; sender must approve"
        }
      ],
      "business_rules": [
        {
          "description": "Only whitelisted assets can be locked in bonds.",
          "related_contracts": [
            "BondNFT"
          ],
          "severity_if_broken": "High"
        },
        {
          "description": "Bond can only be extended if not expired and by owner.",
          "related_contracts": [
            "BondNFT"
          ],
          "severity_if_broken": "High"
        },
        {
          "description": "Bond transfer only allowed if not expired and after 300 seconds from mint.",
          "related_contracts": [
            "BondNFT"
          ],
          "severity_if_broken": "Medium"
        }
      ],
      "numeric_guards": [
        {
          "var_name": "_period",
          "guard_expr": "bond.period+_period <= 365",
          "failure_mode": "MAX PERIOD"
        }
      ]
    },
    {
      "id": "MetaContext",
      "file_name": "MetaContext.sol",
      "core_purpose_raw": "MetaContext is an Ownable contract that manages a set of trusted forwarders for meta-transactions. It overrides _msgSender and _msgData to support ERC2771-style meta-tx, allowing calls to appear as if sent by the original user when relayed by a trusted forwarder.",
      "core_purpose_digest": "Ownable meta-tx context with trusted forwarder support for _msgSender/_msgData.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "Ownable"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner"
      ],
      "key_state_vars": [
        "_isTrustedForwarder"
      ],
      "key_functions": [
        "_msgData",
        "_msgSender",
        "isTrustedForwarder",
        "setTrustedForwarder"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/access/Ownable.sol"
      ],
      "security_notes": [
        "Trusted forwarder list is owner-controlled.",
        "Assembly is used for extracting sender from calldata.",
        "Meta-tx support relies on correct forwarder configuration."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [
        {
          "description": "Only owner can set trusted forwarders.",
          "related_contracts": [
            "MetaContext"
          ],
          "severity_if_broken": "High"
        }
      ],
      "numeric_guards": []
    },
    {
      "id": "ILayerZeroReceiver",
      "file_name": "ILayerZeroReceiver.sol",
      "core_purpose_raw": "Defines the interface for contracts to receive cross-chain messages via LayerZero. The lzReceive function is called by the LayerZero endpoint to deliver messages from a source chain, including source chain ID, source address, nonce, and payload.",
      "core_purpose_digest": "Interface for receiving cross-chain messages via LayerZero.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "lzReceive"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "ILayerZeroUserApplicationConfig",
      "file_name": "ILayerZeroUserApplicationConfig.sol",
      "core_purpose_raw": "Defines the interface for configuring LayerZero messaging library parameters for user applications. Allows setting config for specific versions and chains, changing send/receive versions, and resuming message flow in blocking mode.",
      "core_purpose_digest": "Interface for configuring LayerZero messaging library and resuming message flow.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "forceResumeReceive",
        "setConfig",
        "setReceiveVersion",
        "setSendVersion"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "IPairsContract",
      "file_name": "IPairsContract.sol",
      "core_purpose_raw": "Defines the interface for managing trading pairs and their associated assets and open interest. Allows querying allowed assets, asset details, open interest, and modifying funding rates and open interest for long/short positions.",
      "core_purpose_digest": "Interface for managing trading pairs, assets, and open interest.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "allowedAsset",
        "idToAsset",
        "idToOi",
        "modifyLongOi",
        "modifyShortOi",
        "setAssetBaseFundingRate"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "IPosition",
      "file_name": "IPosition.sol",
      "core_purpose_raw": "Defines the interface for managing trading positions, including minting, burning, modifying, and querying trades. Supports limit orders, margin/leverage adjustments, and funding updates. Includes structures for Trade and MintTrade.",
      "core_purpose_digest": "Interface for managing trading positions, orders, and funding.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "addToPosition",
        "assetOpenPositions",
        "assetOpenPositionsIndexes",
        "assetOpenPositionsLength",
        "burn",
        "executeLimitOrder",
        "getCount",
        "limitOrderIndexes",
        "limitOrders",
        "limitOrdersLength",
        "mint",
        "modifyMargin",
        "modifySl",
        "modifyTp",
        "ownerOf",
        "reducePosition",
        "setAccInterest",
        "trades",
        "updateFunding"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "IReferrals",
      "file_name": "IReferrals.sol",
      "core_purpose_raw": "Defines the interface for a referral system, allowing creation of referral codes, setting and querying referred traders, and retrieving referral addresses by code.",
      "core_purpose_digest": "Interface for referral code creation and lookup.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "createReferralCode",
        "getReferral",
        "getReferred",
        "setReferred"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "IStableVault",
      "file_name": "IStableVault.sol",
      "core_purpose_raw": "Defines the interface for a stable vault contract, allowing deposits and withdrawals of tokens, checking if an address is allowed, and retrieving the stable asset address.",
      "core_purpose_digest": "Interface for stable vaults: deposit, withdraw, allowed check, and stable asset address.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "allowed",
        "deposit",
        "stable",
        "withdraw"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    },
    {
      "id": "ITrading",
      "file_name": "ITrading.sol",
      "core_purpose_raw": "Defines the interface for trading operations, including market and limit order initiation, margin management, position management, liquidation, and order execution. It also defines data structures for trade information and ERC20 permit data.",
      "core_purpose_digest": "Interface for trading: order initiation, margin/position management, liquidation, and order execution.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "TradingLibrary"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "addMargin",
        "addToPosition",
        "cancelLimitOrder",
        "executeLimitOrder",
        "initiateCloseOrder",
        "initiateLimitOrder",
        "initiateMarketOrder",
        "limitClose",
        "liquidatePosition",
        "removeMargin",
        "updateTpSl"
      ],
      "external_dependencies": [
        "TradingLibrary"
      ],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [],
      "external_flows": [],
      "business_rules": [],
      "numeric_guards": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The TigerSwap protocol is a decentralized perpetual trading platform that allows users to trade various assets with leverage. The protocol enables traders to open long or short positions, set take-profit and stop-loss orders, and manage their positions through a comprehensive set of functions. It consists of interconnected smart contracts for trading, position management (NFTs), asset pairs, governance, stablecoin vaults, and more. The protocol uses off-chain oracles for price data, supports meta-transactions, and distributes fees to stakeholders.",
    "overall_goal_digest": "Decentralized leveraged trading platform with NFT positions, oracles, and fee/reward distribution.",
    "actors_capabilities": [
      "Governance: modify protocol parameters",
      "Limit Order Executors: execute limit orders for a fee",
      "Liquidators: liquidate undercollateralized positions",
      "Proxy Wallets: trade on behalf of traders with approval",
      "Referrers: refer users and earn trading fee share",
      "Traders: open/close/modify positions, set TP/SL, manage margin"
    ],
    "core_assets": [
      "BondNFT",
      "GovNFT",
      "Lock",
      "PairsContract",
      "Position NFT contract",
      "StableToken",
      "StableVault",
      "Trading contract",
      "TradingExtension contract"
    ],
    "critical_interactions": [
      "Trading <-> TradingExtension: price verification, OI modification, trade validation",
      "Trading <-> Position: mint/burn/modify position NFTs",
      "Trading <-> PairsContract: asset/parameter lookup, OI tracking",
      "Trading <-> StableVault: margin deposit/withdrawal",
      "TradingExtension <-> Chainlink: optional price check",
      "TradingExtension <-> Referrals: referral management"
    ],
    "key_assumptions": [
      {
        "id": "assume-1",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Only whitelisted nodes can sign price data and only valid signatures are accepted."
      },
      {
        "id": "assume-2",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "StableVault and margin assets are trusted and correctly implement deposit/withdraw logic."
      },
      {
        "id": "assume-3",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "ERC721Enumerable is used for position NFTs, preventing batch minting and ensuring safe enumeration."
      },
      {
        "id": "assume-4",
        "source": "web_context",
        "context_type": "security_assumption",
        "details": "LayerZero and Chainlink endpoints are trusted and configured per chain; price feeds are not hardcoded."
      }
    ],
    "invariants": [
      {
        "id": "inv-1",
        "description": "_handleDeposit preserves tigAsset balance",
        "related_code": [
          "Trading.sol:_handleDeposit"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-2",
        "description": "Stop-loss price must be valid relative to market price",
        "related_code": [
          "Trading.sol:_checkSl"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-3",
        "description": "StableVault input must be whitelisted and token allowed",
        "related_code": [
          "Trading.sol:_checkVault"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-4",
        "description": "Proxy must be approved before trading on behalf",
        "related_code": [
          "Trading.sol:_validateProxy"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-5",
        "description": "Trade margin*leverage must satisfy minPositionSize",
        "related_code": [
          "TradingExtension.sol:validateTrade"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-6",
        "description": "Trade leverage within allowed bounds",
        "related_code": [
          "TradingExtension.sol:validateTrade"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-7",
        "description": "Verified price signature must be from an allowed node",
        "related_code": [
          "TradingLibrary.sol:verifyPrice"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-8",
        "description": "Price timestamp must be within valid signature window",
        "related_code": [
          "TradingLibrary.sol:verifyPrice"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-9",
        "description": "updateFunding must set OI exactly to parameters",
        "related_code": [
          "Position.sol:updateFunding"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-10",
        "description": "fundingDeltaPerSec computed correctly in updateFunding",
        "related_code": [
          "Position.sol:updateFunding"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-11",
        "description": "mint initializes trade and assigns ownership",
        "related_code": [
          "Position.sol:mint"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-12",
        "description": "PairsContract.modifyLongOi never exceeds maxOi on open",
        "related_code": [
          "PairsContract.sol:modifyLongOi"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-13",
        "description": "PairsContract.modifyShortOi never exceeds maxOi on open",
        "related_code": [
          "PairsContract.sol:modifyShortOi"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-14",
        "description": "StableVault deposit mints correct stable amount",
        "related_code": [
          "Trading.sol:_handleDeposit"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-15",
        "description": "Limit orders must respect delay before execution",
        "related_code": [
          "Trading.sol:executeLimitOrder"
        ],
        "numeric_bound": null,
        "origin": "check"
      },
      {
        "id": "inv-1",
        "description": "totalLocked[asset] accurately tracks the sum of all locked assets in Lock.",
        "related_code": [],
        "numeric_bound": null,
        "origin": "assumption"
      },
      {
        "id": "inv-2",
        "description": "No more than MAX (10000) GovNFT tokens can be minted.",
        "related_code": [],
        "numeric_bound": "10000",
        "origin": "check"
      },
      {
        "id": "inv_totalShares",
        "description": "totalShares for each asset equals the sum of all active bond shares.",
        "related_code": [
          "BondNFT.createLock",
          "BondNFT.extendLock",
          "BondNFT.release"
        ],
        "numeric_bound": null,
        "origin": "assumption"
      },
      {
        "id": "inv_bond_expiry",
        "description": "Bonds cannot be extended or transferred after expiry.",
        "related_code": [
          "BondNFT.extendLock",
          "BondNFT._transfer"
        ],
        "numeric_bound": null,
        "origin": "check"
      }
    ],
    "general_security_ctx": [
      {
        "id": "ctx-1",
        "source": "web_context",
        "context_type": "tooling_note",
        "details": "LayerZero endpoints are immutable and enforce message nonces for exactly-once delivery."
      },
      {
        "id": "ctx-2",
        "source": "web_context",
        "context_type": "tooling_note",
        "details": "Chainlink price feeds must be checked for staleness and decimals; fallback logic is recommended."
      },
      {
        "id": "ctx-3",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "ERC721Enumerable prevents batch minting and ensures safe enumeration."
      },
      {
        "id": "ctx-4",
        "source": "web_context",
        "context_type": "other",
        "details": "On Arbitrum, blockhash, coinbase, and difficulty are not secure for randomness or timing."
      },
      {
        "id": "ctx_manager_only",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "All state-changing functions are restricted to the manager contract via onlyManager modifier."
      },
      {
        "id": "ctx_owner_only",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Asset whitelisting and trusted forwarder management are restricted to the contract owner."
      }
    ],
    "static_summary": null
  }
}