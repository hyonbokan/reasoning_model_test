{
  "analyzed_contracts": [
    {
      "id": "Trading.sol",
      "file_name": "Trading.sol",
      "core_purpose_raw": "The Trading contract is the main user-facing contract for the TigerSwap protocol, enabling users to open, modify, and close leveraged perpetual trading positions. It manages market and limit orders, margin adjustments, liquidation, fee distribution, proxy trading, and interacts with other protocol components such as the TradingExtension, Position NFT, PairsContract, StableVault, and governance modules. It enforces access control, margin and leverage checks, and integrates with off-chain oracles for price data.",
      "core_purpose_digest": "Main user contract for leveraged trading: open/close positions, margin, liquidation, fees, proxy, and NFT positions.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ITradingExtension",
        "IPairsContract",
        "IPosition",
        "IGovNFT",
        "IStableVault",
        "IERC20",
        "ERC20Permit"
      ],
      "compiler_version": null,
      "identified_roles": [
        "limit order executor",
        "liquidator",
        "owner",
        "proxy",
        "referrer",
        "trader"
      ],
      "key_state_vars": [
        "allowedVault",
        "blockDelay",
        "blockDelayPassed",
        "closeFees",
        "gov",
        "limitDelay",
        "limitOrderPriceRange",
        "maxWinPercent",
        "openFees",
        "pairsContract",
        "position",
        "proxyApprovals",
        "tradingExtension",
        "vaultFundingPercent"
      ],
      "key_functions": [
        "addMargin",
        "addToPosition",
        "approveProxy",
        "cancelLimitOrder",
        "executeLimitOrder",
        "initiateCloseOrder",
        "initiateLimitOrder",
        "initiateMarketOrder",
        "limitClose",
        "liquidatePosition",
        "removeMargin",
        "setAllowedVault",
        "setBlockDelay",
        "setFees",
        "setLimitOrderPriceRange",
        "setMaxWinPercent",
        "setTradingExtension",
        "updateTpSl"
      ],
      "external_dependencies": [
        "ERC20",
        "ERC20Permit",
        "GovNFT",
        "PairsContract",
        "Position",
        "StableVault",
        "TradingExtension"
      ],
      "security_notes": [
        "Proxy trading requires explicit approval and time-bound access.",
        "All margin and leverage checks are enforced before position changes.",
        "StableVault and margin asset must be whitelisted.",
        "Price data is verified via off-chain signatures and node whitelisting.",
        "Limit order execution is guarded by a minimum delay.",
        "Fee distribution is parameterized and can be updated by owner.",
        "Liquidation threshold is enforced to prevent undercollateralized positions.",
        "Reentrancy is not explicitly guarded; relies on external contract safety.",
        "Meta-transactions are supported via MetaContext.",
        "All critical state changes emit events for off-chain tracking."
      ],
      "config_params": [
        {
          "name": "blockDelay",
          "storage_key": "blockDelay",
          "load_site": {
            "id": "Trading.sol:blockDelay",
            "file": "Trading.sol",
            "element_name": "blockDelay",
            "unique_snippet": "uint public blockDelay;"
          },
          "downstream_uses": [
            "Trading.sol:_checkDelay"
          ],
          "role": "misc"
        },
        {
          "name": "maxWinPercent",
          "storage_key": "maxWinPercent",
          "load_site": {
            "id": "Trading.sol:maxWinPercent",
            "file": "Trading.sol",
            "element_name": "maxWinPercent",
            "unique_snippet": "uint public maxWinPercent;"
          },
          "downstream_uses": [
            "Trading.sol:_closePosition"
          ],
          "role": "upper_bound"
        },
        {
          "name": "vaultFundingPercent",
          "storage_key": "vaultFundingPercent",
          "load_site": {
            "id": "Trading.sol:vaultFundingPercent",
            "file": "Trading.sol",
            "element_name": "vaultFundingPercent",
            "unique_snippet": "uint public vaultFundingPercent;"
          },
          "downstream_uses": [
            "Trading.sol:_updateFunding"
          ],
          "role": "multiplier"
        },
        {
          "name": "limitOrderPriceRange",
          "storage_key": "limitOrderPriceRange",
          "load_site": {
            "id": "Trading.sol:limitOrderPriceRange",
            "file": "Trading.sol",
            "element_name": "limitOrderPriceRange",
            "unique_snippet": "uint public limitOrderPriceRange = 1e8;"
          },
          "downstream_uses": [
            "Trading.sol:executeLimitOrder"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [
        {
          "name": "paused",
          "expected_setters": [
            "TradingExtension.setPaused"
          ],
          "observed_setters": [
            "TradingExtension.setPaused"
          ],
          "note": "TradingExtension pause state is checked before order execution."
        }
      ],
      "arith_hints": [
        {
          "var": "DIVISION_CONSTANT",
          "role": "scale",
          "scale_or_default": 1,
          "comment": "Used as 1e10 for 100% scaling in all percent math."
        },
        {
          "var": "liqPercent",
          "role": "multiplier",
          "scale_or_default": 9,
          "comment": "Used as 90% for liquidation threshold."
        }
      ],
      "sync_guards": [
        {
          "name": "blockDelayPassed",
          "guard_type": "delay",
          "detail": "Prevents opening/closing in same block; enforced in _checkDelay."
        },
        {
          "name": "limitDelay",
          "guard_type": "delay",
          "detail": "Enforces minimum time before limit order execution."
        }
      ]
    },
    {
      "id": "TradingExtension.sol",
      "file_name": "TradingExtension.sol",
      "core_purpose_raw": "TradingExtension is a support contract for the Trading contract, providing price verification (including signature and optional Chainlink checks), referral management, position validation, and open interest modification. It enforces minimum position sizes, margin asset whitelisting, and can pause trading. It is the only contract allowed to call certain functions in the protocol, acting as a security and logic extension.",
      "core_purpose_digest": "Trading logic extension: price verification, referral, position validation, OI management, pausing, and min size checks.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPairsContract",
        "IReferrals",
        "IPosition"
      ],
      "compiler_version": null,
      "identified_roles": [
        "node",
        "owner",
        "referrer",
        "trading (protocol)"
      ],
      "key_state_vars": [
        "allowedMargin",
        "chainlinkEnabled",
        "isNode",
        "maxGasPrice",
        "minPositionSize",
        "paused",
        "validSignatureTimer"
      ],
      "key_functions": [
        "_setReferral",
        "getVerifiedPrice",
        "modifyLongOi",
        "modifyShortOi",
        "setAllowedMargin",
        "setChainlinkEnabled",
        "setMaxGasPrice",
        "setMinPositionSize",
        "setNode",
        "setPaused",
        "setValidSignatureTimer",
        "validateTrade"
      ],
      "external_dependencies": [
        "PairsContract",
        "Position",
        "Referrals"
      ],
      "security_notes": [
        "Price data is verified by signature and node whitelisting.",
        "Chainlink price feed can be enabled for additional price sanity checks.",
        "Minimum position size and allowed margin assets are enforced.",
        "Trading can be paused by owner.",
        "Gas price is capped to prevent MEV attacks.",
        "Only the Trading contract can call protocol functions.",
        "Referral system is managed and validated."
      ],
      "config_params": [
        {
          "name": "validSignatureTimer",
          "storage_key": "validSignatureTimer",
          "load_site": {
            "id": "TradingExtension.sol:validSignatureTimer",
            "file": "TradingExtension.sol",
            "element_name": "validSignatureTimer",
            "unique_snippet": "uint256 public validSignatureTimer;"
          },
          "downstream_uses": [
            "TradingExtension.sol:getVerifiedPrice"
          ],
          "role": "upper_bound"
        },
        {
          "name": "chainlinkEnabled",
          "storage_key": "chainlinkEnabled",
          "load_site": {
            "id": "TradingExtension.sol:chainlinkEnabled",
            "file": "TradingExtension.sol",
            "element_name": "chainlinkEnabled",
            "unique_snippet": "bool public chainlinkEnabled;"
          },
          "downstream_uses": [
            "TradingExtension.sol:getVerifiedPrice"
          ],
          "role": "misc"
        },
        {
          "name": "maxGasPrice",
          "storage_key": "maxGasPrice",
          "load_site": {
            "id": "TradingExtension.sol:maxGasPrice",
            "file": "TradingExtension.sol",
            "element_name": "maxGasPrice",
            "unique_snippet": "uint public maxGasPrice = 1000000000000;"
          },
          "downstream_uses": [
            "TradingExtension.sol:_checkGas"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [
        {
          "name": "paused",
          "expected_setters": [
            "setPaused"
          ],
          "observed_setters": [
            "setPaused"
          ],
          "note": "Trading can be paused by owner."
        }
      ],
      "arith_hints": [
        {
          "var": "DIVISION_CONSTANT",
          "role": "scale",
          "scale_or_default": 1,
          "comment": "Used as 1e10 for percent math."
        }
      ],
      "sync_guards": []
    },
    {
      "id": "Position.sol",
      "file_name": "Position.sol",
      "core_purpose_raw": "Position is an ERC721Enumerable NFT contract that represents user trading positions as NFTs. It tracks all open positions, limit orders, and per-asset open interest. It manages minting, burning, and modification of position data, and accumulates funding rates and interest. Only whitelisted minters (e.g., Trading contract) can mint or modify positions.",
      "core_purpose_digest": "ERC721 NFT for user positions: mint/burn, open/close, funding, and per-asset open interest tracking.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable",
        "IPosition"
      ],
      "compiler_version": null,
      "identified_roles": [
        "minter (Trading contract)",
        "owner",
        "user"
      ],
      "key_state_vars": [
        "_assetOpenPositions",
        "_assetOpenPositionsIndexes",
        "_isMinter",
        "_limitOrderIndexes",
        "_limitOrders",
        "_openPositions",
        "_openPositionsIndexes",
        "_trades",
        "accInterestPerOi",
        "fundingDeltaPerSec",
        "initId",
        "lastUpdate",
        "longOi",
        "shortOi"
      ],
      "key_functions": [
        "addToPosition",
        "burn",
        "executeLimitOrder",
        "mint",
        "modifyMargin",
        "modifySl",
        "modifyTp",
        "reducePosition",
        "setAccInterest",
        "setMinter",
        "updateFunding"
      ],
      "external_dependencies": [
        "ERC721Enumerable"
      ],
      "security_notes": [
        "Only whitelisted minters can mint or modify positions.",
        "ERC721Enumerable ensures safe enumeration and prevents batch minting.",
        "Funding and interest are updated on every position change.",
        "All position state changes are atomic and tracked by NFT ID.",
        "Open/close/limit order lists are updated with swap-and-pop for O(1) removal."
      ],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [
        {
          "var": "DIVISION_CONSTANT",
          "role": "scale",
          "scale_or_default": 1,
          "comment": "Used as 1e10 for percent math."
        }
      ],
      "sync_guards": []
    },
    {
      "id": "PairsContract.sol",
      "file_name": "PairsContract.sol",
      "core_purpose_raw": "PairsContract manages the list of tradable assets, their parameters (leverage, fee multipliers, funding rates), and tracks open interest (OI) for each asset and margin token. It enforces per-asset OI limits and allows the owner to add, update, or pause assets. Only the protocol (Trading contract) can modify OI.",
      "core_purpose_digest": "Manages tradable assets, parameters, and open interest; enforces OI limits and asset whitelisting.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPairsContract",
        "Ownable"
      ],
      "compiler_version": null,
      "identified_roles": [
        "owner",
        "protocol (Trading contract)"
      ],
      "key_state_vars": [
        "_idToAsset",
        "_idToOi",
        "allowedAsset",
        "maxBaseFundingRate",
        "protocol"
      ],
      "key_functions": [
        "addAsset",
        "modifyLongOi",
        "modifyShortOi",
        "pauseAsset",
        "setAssetBaseFundingRate",
        "setAssetChainlinkFeed",
        "setMaxBaseFundingRate",
        "setMaxOi",
        "setProtocol",
        "updateAssetFeeMultiplier",
        "updateAssetLeverage"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Only owner can add/update/pause assets and set protocol address.",
        "Only protocol can modify open interest.",
        "Per-asset OI limits are enforced on open.",
        "All asset parameters are validated before update."
      ],
      "config_params": [
        {
          "name": "maxBaseFundingRate",
          "storage_key": "maxBaseFundingRate",
          "load_site": {
            "id": "PairsContract.sol:maxBaseFundingRate",
            "file": "PairsContract.sol",
            "element_name": "maxBaseFundingRate",
            "unique_snippet": "uint256 private maxBaseFundingRate = 1e10;"
          },
          "downstream_uses": [
            "PairsContract.sol:setAssetBaseFundingRate"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "Referrals",
      "file_name": "Referrals.sol",
      "core_purpose_raw": "A contract for managing referral codes and tracking which users have been referred, with owner-controlled protocol address and ability to initialize referral data. Allows users to create referral codes, and a protocol contract to set referred users. Owner can set protocol and (deprecated) initialize referral mappings.",
      "core_purpose_digest": "Manages referral codes and referred users, with owner and protocol controls.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "Ownable",
        "IReferrals"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner",
        "protocol",
        "referred",
        "referrer"
      ],
      "key_state_vars": [
        "_referral",
        "_referred",
        "isInit",
        "protocol"
      ],
      "key_functions": [
        "createReferralCode",
        "getReferral",
        "getReferred",
        "initRefs",
        "setProtocol",
        "setReferred"
      ],
      "external_dependencies": [
        "./interfaces/IReferrals.sol",
        "@openzeppelin/contracts/access/Ownable.sol"
      ],
      "security_notes": [
        "Only protocol can set referred users.",
        "Owner can set protocol address.",
        "initRefs is deprecated and only callable once."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "isInit",
          "expected_setters": [
            "initRefs"
          ],
          "observed_setters": [
            "initRefs"
          ],
          "note": "Prevents re-initialization of referral data."
        }
      ],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "GovNFT",
      "file_name": "GovNFT.sol",
      "core_purpose_raw": "An ERC721Enumerable NFT contract with cross-chain bridging via LayerZero, reward distribution for NFT holders, and meta-transaction support. Allows minting, burning, transferring, bridging, and claiming rewards. Owner can set trusted addresses, gas, endpoint, and allowed assets.",
      "core_purpose_digest": "ERC721 NFT with cross-chain bridging, rewards, and meta-tx support.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC721Enumerable",
        "ILayerZeroReceiver",
        "MetaContext",
        "IGovNFT"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "NFT holder",
        "endpoint",
        "owner",
        "trusted address"
      ],
      "key_state_vars": [
        "MAX",
        "_allowedAsset",
        "accRewardsPerNFT",
        "assets",
        "assetsIndex",
        "baseURI",
        "counter",
        "endpoint",
        "failedMessages",
        "gas",
        "isTrustedAddress",
        "maxBridge",
        "userDebt",
        "userPaid"
      ],
      "key_functions": [
        "addAsset",
        "claim",
        "crossChain",
        "distribute",
        "lzReceive",
        "mint",
        "mintMany",
        "nonblockingLzReceive",
        "setAllowedAsset",
        "setEndpoint",
        "setGas",
        "setTrustedAddress"
      ],
      "external_dependencies": [
        "./interfaces/IGovNFT.sol",
        "./interfaces/ILayerZeroEndpoint.sol",
        "./interfaces/ILayerZeroReceiver.sol",
        "./utils/ExcessivelySafeCall.sol",
        "./utils/MetaContext.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"
      ],
      "security_notes": [
        "Cross-chain minting and message handling via LayerZero.",
        "Owner can set trusted addresses and endpoint.",
        "Rewards distribution depends on allowed assets and total supply.",
        "Reentrancy not explicitly guarded in reward/bridge logic."
      ],
      "config_params": [
        {
          "name": "gas",
          "storage_key": "gas",
          "load_site": {
            "id": "GovNFT.setGas",
            "file": "GovNFT.sol",
            "element_name": "setGas",
            "unique_snippet": "function setGas(uint _gas) external onlyOwner { gas = _gas; }"
          },
          "downstream_uses": [
            "GovNFT.crossChain"
          ],
          "role": "multiplier"
        },
        {
          "name": "maxBridge",
          "storage_key": "maxBridge",
          "load_site": {
            "id": "GovNFT.setMaxBridge",
            "file": "GovNFT.sol",
            "element_name": "setMaxBridge",
            "unique_snippet": "function setMaxBridge(uint256 _max) external onlyOwner { maxBridge = _max; }"
          },
          "downstream_uses": [],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [],
      "arith_hints": [
        {
          "var": "counter",
          "role": "scale",
          "scale_or_default": 1,
          "comment": "Incremented on mint, must not exceed MAX"
        },
        {
          "var": "accRewardsPerNFT[_tigAsset]",
          "role": "divisor",
          "scale_or_default": null,
          "comment": "Rewards per NFT, division by totalSupply()"
        }
      ],
      "sync_guards": []
    },
    {
      "id": "StableToken",
      "file_name": "StableToken.sol",
      "core_purpose_raw": "An ERC20 token with permit functionality and meta-transaction support. Allows owner to set minters, and minters to mint or burn tokens for any account.",
      "core_purpose_digest": "ERC20 with permit, meta-tx, and owner-controlled minters.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ERC20Permit",
        "MetaContext"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "minter",
        "owner"
      ],
      "key_state_vars": [
        "isMinter"
      ],
      "key_functions": [
        "burnFrom",
        "mintFor",
        "setMinter"
      ],
      "external_dependencies": [
        "./utils/MetaContext.sol",
        "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"
      ],
      "security_notes": [
        "Only minters can mint or burn tokens.",
        "Owner controls minter status."
      ],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "StableVault",
      "file_name": "StableVault.sol",
      "core_purpose_raw": "A vault for depositing allowed tokens and minting a stable asset (tigAsset), and for redeeming tigAsset for underlying tokens. Owner can list/delist allowed tokens. Supports permit-based deposits.",
      "core_purpose_digest": "Vault for minting/redeeming stable asset against allowed tokens.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "MetaContext",
        "IStableVault"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "depositor",
        "owner"
      ],
      "key_state_vars": [
        "allowed",
        "stable",
        "tokenIndex",
        "tokens"
      ],
      "key_functions": [
        "delistToken",
        "deposit",
        "depositWithPermit",
        "listToken",
        "withdraw"
      ],
      "external_dependencies": [
        "./interfaces/IStableVault.sol",
        "./utils/MetaContext.sol",
        "@openzeppelin/contracts/security/ReentrancyGuard.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      ],
      "security_notes": [
        "Owner controls which tokens are allowed.",
        "Deposit/withdraw logic depends on correct decimals.",
        "No explicit reentrancy guard on deposit/withdraw."
      ],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [
        {
          "var": "_amount*(10**(18-IERC20Mintable(_token).decimals()))",
          "role": "multiplier",
          "scale_or_default": null,
          "comment": "Converts token amount to 18 decimals for minting"
        },
        {
          "var": "_amount/10**(18-IERC20Mintable(_token).decimals())",
          "role": "divisor",
          "scale_or_default": null,
          "comment": "Converts 18 decimal stable to token decimals for withdrawal"
        }
      ],
      "sync_guards": []
    },
    {
      "id": "Lock",
      "file_name": "Lock.sol",
      "core_purpose_raw": "A contract for locking allowed assets to create bond NFTs, claim rewards, extend locks, and release bonds. Integrates with BondNFT and GovNFT contracts. Owner can whitelist assets and retrieve NFTs.",
      "core_purpose_digest": "Locks assets for bond NFTs, manages rewards, and asset whitelisting.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "Ownable"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "bondNFT",
        "govNFT",
        "owner",
        "user"
      ],
      "key_state_vars": [
        "allowedAssets",
        "bondNFT",
        "govNFT",
        "maxPeriod",
        "minPeriod",
        "totalLocked"
      ],
      "key_functions": [
        "claim",
        "claimDebt",
        "claimGovFees",
        "editAsset",
        "extendLock",
        "lock",
        "release",
        "sendNFTs"
      ],
      "external_dependencies": [
        "./interfaces/IBondNFT.sol",
        "./interfaces/IGovNFT.sol",
        "@openzeppelin/contracts/access/Ownable.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      ],
      "security_notes": [
        "Owner can whitelist assets.",
        "Lock periods are enforced between minPeriod and maxPeriod.",
        "Relies on external BondNFT and GovNFT contracts for core logic."
      ],
      "config_params": [
        {
          "name": "minPeriod",
          "storage_key": "minPeriod",
          "load_site": {
            "id": "Lock.lock.minPeriod",
            "file": "Lock.sol",
            "element_name": "lock",
            "unique_snippet": "require(_period >= minPeriod, \"MIN PERIOD\");"
          },
          "downstream_uses": [
            "Lock.lock"
          ],
          "role": "lower_bound"
        },
        {
          "name": "maxPeriod",
          "storage_key": "maxPeriod",
          "load_site": {
            "id": "Lock.lock.maxPeriod",
            "file": "Lock.sol",
            "element_name": "lock",
            "unique_snippet": "require(_period <= maxPeriod, \"MAX PERIOD\");"
          },
          "downstream_uses": [
            "Lock.lock"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "BondNFT.sol",
      "file_name": "BondNFT.sol",
      "core_purpose_raw": "BondNFT is an ERC721Enumerable NFT contract that represents time-locked bonds of ERC20 tokens (tigAssets). Users can lock assets for a period, receive an NFT representing the bond, and claim rewards. The contract manages bond creation, extension, release, reward distribution, and debt claims, with access control for a manager and owner. It tracks shares, rewards, and asset whitelisting.",
      "core_purpose_digest": "NFTs represent time-locked ERC20 bonds; users lock assets, earn rewards, and manage bonds via a manager.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IERC20",
        "ERC721Enumerable",
        "Ownable"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "manager",
        "owner",
        "user"
      ],
      "key_state_vars": [
        "_idToBond",
        "accRewardsPerShare",
        "allowedAsset",
        "assets",
        "assetsIndex",
        "baseURI",
        "bondPaid",
        "epoch",
        "manager",
        "totalBonds",
        "totalShares",
        "userDebt"
      ],
      "key_functions": [
        "addAsset",
        "approveMany",
        "claim",
        "claimDebt",
        "createLock",
        "distribute",
        "extendLock",
        "getAssets",
        "idToBond",
        "isExpired",
        "pending",
        "release",
        "safeTransferFromMany",
        "safeTransferMany",
        "setAllowedAsset",
        "setBaseURI",
        "setManager",
        "totalAssets"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/access/Ownable.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"
      ],
      "security_notes": [
        "Only the manager can call core bond management functions (createLock, extendLock, release, claim, claimDebt).",
        "Owner can add assets, set allowed assets, set base URI, and set manager.",
        "Unchecked math is used in several places; care is needed for overflows.",
        "Bond transfer requires epoch to match and bond to be unexpired.",
        "Rewards are distributed per share; division by zero is guarded by totalShares check.",
        "Bond extension is limited to a max period of 365 days."
      ],
      "config_params": [
        {
          "name": "epoch",
          "storage_key": "epoch[_asset]",
          "load_site": {
            "id": "BondNFT.sol:createLock:require(allowedAsset[_asset], \"!Asset\");",
            "file": "BondNFT.sol",
            "element_name": "createLock",
            "unique_snippet": "require(allowedAsset[_asset], \"!Asset\");"
          },
          "downstream_uses": [
            "BondNFT.sol:createLock:expireEpoch = epoch[_asset] + _period;",
            "BondNFT.sol:extendLock:require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");",
            "BondNFT.sol:distribute:if (aEpoch > epoch[_tigAsset]) { ... }"
          ],
          "role": "misc"
        },
        {
          "name": "allowedAsset",
          "storage_key": "allowedAsset[_asset]",
          "load_site": {
            "id": "BondNFT.sol:createLock:require(allowedAsset[_asset], \"!Asset\");",
            "file": "BondNFT.sol",
            "element_name": "createLock",
            "unique_snippet": "require(allowedAsset[_asset], \"!Asset\");"
          },
          "downstream_uses": [
            "BondNFT.sol:createLock:require(allowedAsset[_asset], \"!Asset\");",
            "BondNFT.sol:distribute:if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;"
          ],
          "role": "misc"
        },
        {
          "name": "totalShares",
          "storage_key": "totalShares[_asset]",
          "load_site": {
            "id": "BondNFT.sol:createLock:totalShares[_asset] += shares;",
            "file": "BondNFT.sol",
            "element_name": "createLock",
            "unique_snippet": "totalShares[_asset] += shares;"
          },
          "downstream_uses": [
            "BondNFT.sol:distribute:if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;",
            "BondNFT.sol:distribute:accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];"
          ],
          "role": "divisor"
        }
      ],
      "flag_trackers": [
        {
          "name": "expired",
          "expected_setters": [
            "idToBond"
          ],
          "observed_setters": [
            "idToBond"
          ],
          "note": "Indicates if a bond is expired; set in idToBond based on expireEpoch and epoch."
        }
      ],
      "arith_hints": [
        {
          "var": "totalShares[_tigAsset]",
          "role": "divisor",
          "scale_or_default": null,
          "comment": "Division guarded by if (totalShares[_tigAsset] == 0) return;"
        },
        {
          "var": "bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18",
          "role": "scale",
          "scale_or_default": 1,
          "comment": "Rewards per share are scaled by 1e18"
        }
      ],
      "sync_guards": []
    },
    {
      "id": "MetaContext.sol",
      "file_name": "MetaContext.sol",
      "core_purpose_raw": "MetaContext is an Ownable contract that manages trusted forwarders for meta-transactions. It allows the owner to set trusted forwarders and overrides _msgSender and _msgData to support meta-tx relaying, enabling contracts to correctly identify the original sender and calldata.",
      "core_purpose_digest": "Ownable contract for meta-tx support via trusted forwarders and _msgSender/_msgData overrides.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "Ownable"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "owner",
        "trusted forwarder"
      ],
      "key_state_vars": [
        "_isTrustedForwarder"
      ],
      "key_functions": [
        "_msgData",
        "_msgSender",
        "isTrustedForwarder",
        "setTrustedForwarder"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/access/Ownable.sol"
      ],
      "security_notes": [
        "Only owner can set trusted forwarders.",
        "Assembly is used in _msgSender for extracting sender from calldata.",
        "Meta-tx support relies on correct trusted forwarder configuration."
      ],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "IBondNFT.sol",
      "file_name": "IBondNFT.sol",
      "core_purpose_raw": "IBondNFT is an interface for the BondNFT contract, defining external functions for bond creation, extension, claiming, releasing, distributing rewards, and asset queries. It standardizes the BondNFT API for integration and interaction.",
      "core_purpose_digest": "Interface for BondNFT: defines bond management and query functions for integration.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.9",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "claim",
        "claimDebt",
        "createLock",
        "distribute",
        "extendLock",
        "getAssets",
        "ownerOf",
        "release",
        "totalAssets"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "IGovNFT.sol",
      "file_name": "IGovNFT.sol",
      "core_purpose_raw": "IGovNFT is an interface for a governance NFT contract, defining functions for distributing rewards, batch transfers, claiming, and querying pending rewards. It standardizes the API for governance NFT operations.",
      "core_purpose_digest": "Interface for governance NFT: reward distribution, batch transfer, claim, and pending query.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "claim",
        "distribute",
        "pending",
        "safeTransferMany"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "ILayerZeroEndpoint.sol",
      "file_name": "ILayerZeroEndpoint.sol",
      "core_purpose_raw": "ILayerZeroEndpoint is an interface for the LayerZero cross-chain messaging protocol endpoint. It defines functions for sending and receiving messages, querying nonces, estimating fees, retrying payloads, and managing configuration for cross-chain communication.",
      "core_purpose_digest": "Interface for LayerZero endpoint: cross-chain messaging, fee estimation, and config management.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ILayerZeroUserApplicationConfig"
      ],
      "compiler_version": "0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "estimateFees",
        "getChainId",
        "getConfig",
        "getInboundNonce",
        "getOutboundNonce",
        "getReceiveLibraryAddress",
        "getReceiveVersion",
        "getSendLibraryAddress",
        "getSendVersion",
        "hasStoredPayload",
        "isReceivingPayload",
        "isSendingPayload",
        "receivePayload",
        "retryPayload",
        "send"
      ],
      "external_dependencies": [
        "./ILayerZeroUserApplicationConfig.sol"
      ],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "ILayerZeroReceiver",
      "file_name": "ILayerZeroReceiver.sol",
      "core_purpose_raw": "Defines the interface for LayerZero endpoint to deliver cross-chain messages to the destination contract. The lzReceive function is called by the LayerZero endpoint to deliver a message from a source chain.",
      "core_purpose_digest": "Interface for receiving cross-chain messages via LayerZero endpoint.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "Destination contract",
        "LayerZero endpoint"
      ],
      "key_state_vars": [],
      "key_functions": [
        "lzReceive"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "ILayerZeroUserApplicationConfig",
      "file_name": "ILayerZeroUserApplicationConfig.sol",
      "core_purpose_raw": "Defines the interface for configuring LayerZero messaging library versions and resuming message flow. Allows setting config, send version, receive version, and force resuming message flow in blocking mode.",
      "core_purpose_digest": "Interface for configuring LayerZero messaging library and resuming message flow.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "LayerZero messaging library",
        "User application"
      ],
      "key_state_vars": [],
      "key_functions": [
        "forceResumeReceive",
        "setConfig",
        "setReceiveVersion",
        "setSendVersion"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "IPairsContract",
      "file_name": "IPairsContract.sol",
      "core_purpose_raw": "Defines the interface for managing trading pairs, assets, and open interest in a trading protocol. Allows querying and modifying asset parameters, open interest, and funding rates.",
      "core_purpose_digest": "Interface for managing trading pairs, assets, and open interest.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "Asset manager",
        "Trading protocol"
      ],
      "key_state_vars": [],
      "key_functions": [
        "allowedAsset",
        "idToAsset",
        "idToOi",
        "modifyLongOi",
        "modifyShortOi",
        "setAssetBaseFundingRate"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "IPosition",
      "file_name": "IPosition.sol",
      "core_purpose_raw": "Defines the interface for managing trading positions, including minting, burning, modifying, and querying positions. Supports limit orders, margin/leverage adjustments, and funding updates.",
      "core_purpose_digest": "Interface for managing trading positions and related operations.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "Position manager",
        "Trader"
      ],
      "key_state_vars": [],
      "key_functions": [
        "addToPosition",
        "assetOpenPositions",
        "assetOpenPositionsIndexes",
        "assetOpenPositionsLength",
        "burn",
        "executeLimitOrder",
        "getCount",
        "limitOrderIndexes",
        "limitOrders",
        "limitOrdersLength",
        "mint",
        "modifyMargin",
        "modifySl",
        "modifyTp",
        "ownerOf",
        "reducePosition",
        "setAccInterest",
        "trades",
        "updateFunding"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "IReferrals",
      "file_name": "IReferrals.sol",
      "core_purpose_raw": "Defines the interface for a referral system, allowing creation of referral codes, setting and getting referred traders, and resolving referral codes to addresses.",
      "core_purpose_digest": "Interface for referral code management and lookup.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.0",
      "identified_roles": [
        "Referral manager",
        "Trader"
      ],
      "key_state_vars": [],
      "key_functions": [
        "createReferralCode",
        "getReferral",
        "getReferred",
        "setReferred"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "IStableVault",
      "file_name": "IStableVault.sol",
      "core_purpose_raw": "Defines the interface for a stable vault, allowing deposits, withdrawals, permission checks, and querying the stable asset address.",
      "core_purpose_digest": "Interface for stable vault: deposit, withdraw, permission check, and stable asset address.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "^0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "allowed(address)",
        "deposit(address,uint)",
        "stable()",
        "withdraw(address,uint)"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    },
    {
      "id": "ITrading",
      "file_name": "ITrading.sol",
      "core_purpose_raw": "Defines the interface for trading operations, including market and limit order initiation, margin management, position management, and liquidation. It also defines data structures for trade information and ERC20 permit data.",
      "core_purpose_digest": "Interface for trading: order initiation, margin/position management, liquidation, and related structs.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "^0.8.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "addMargin",
        "addToPosition",
        "cancelLimitOrder",
        "executeLimitOrder",
        "initiateCloseOrder",
        "initiateLimitOrder",
        "initiateMarketOrder",
        "limitClose",
        "liquidatePosition",
        "removeMargin",
        "updateTpSl"
      ],
      "external_dependencies": [
        "../utils/TradingLibrary.sol"
      ],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "arith_hints": [],
      "sync_guards": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The TigerSwap protocol is a decentralized perpetual trading platform that allows users to trade various assets with leverage. The protocol enables traders to open long or short positions, set take-profit and stop-loss orders, and manage their positions through a comprehensive set of functions. At its core, the protocol consists of several interconnected smart contracts that handle different aspects of the trading system: Trading, TradingExtension, Position (NFT), PairsContract, GovNFT, BondNFT, StableToken, StableVault, Lock. The protocol implements leveraged trading, market/limit orders, position management, liquidation, fee system, funding rate, referral, and meta-transactions.",
    "overall_goal_digest": "Decentralized leveraged perpetual trading platform with NFT positions, liquidation, fees, and referral system.",
    "actors_capabilities": [
      "Governance: modify protocol parameters/settings.",
      "Limit Order Executors: execute limit orders for a fee.",
      "Liquidators: liquidate undercollateralized positions.",
      "Proxy Wallets: trade on behalf of traders with approval.",
      "Referrers: refer users and earn trading fee share.",
      "Traders: open/close/manage positions, set TP/SL, add/remove margin."
    ],
    "core_assets": [
      "BondNFT",
      "GovNFT",
      "PairsContract",
      "Position NFT contract",
      "StableToken",
      "StableVault",
      "Trading contract",
      "TradingExtension contract"
    ],
    "critical_interactions": [
      "Trading <-> TradingExtension: price verification, OI modification, validation.",
      "Trading <-> Position: mint/burn/modify NFT positions.",
      "Trading <-> PairsContract: asset parameters, OI tracking.",
      "Trading <-> StableVault: margin deposit/withdrawal.",
      "Trading <-> GovNFT: fee distribution.",
      "TradingExtension <-> Referrals: referral management.",
      "TradingExtension <-> PairsContract: asset/parameter queries.",
      "TradingExtension <-> Position: trade data, OI, funding."
    ],
    "key_assumptions": [
      {
        "id": "assume-1",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Off-chain price data is signed by whitelisted oracles and verified on-chain."
      },
      {
        "id": "assume-2",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Only whitelisted minters (Trading contract) can mint/modify Position NFTs."
      },
      {
        "id": "assume-3",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "StableVault and margin assets must be whitelisted before use."
      },
      {
        "id": "assume-4",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Chainlink price feeds, if enabled, are used for price sanity checks."
      },
      {
        "id": "assume-5",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "ERC721Enumerable is used for position NFTs to ensure safe enumeration and prevent batch minting."
      }
    ],
    "invariants": [
      {
        "id": "inv-1",
        "description": "_handleDeposit preserves tigAsset balance",
        "related_code": [
          "Trading.sol:_handleDeposit"
        ],
        "origin": "check"
      },
      {
        "id": "inv-2",
        "description": "Stop-loss price must be valid relative to market price",
        "related_code": [
          "Trading.sol:_checkSl"
        ],
        "origin": "check"
      },
      {
        "id": "inv-3",
        "description": "StableVault input must be whitelisted and token allowed",
        "related_code": [
          "Trading.sol:_checkVault"
        ],
        "origin": "check"
      },
      {
        "id": "inv-4",
        "description": "Proxy must be approved before trading on behalf",
        "related_code": [
          "Trading.sol:_validateProxy"
        ],
        "origin": "check"
      },
      {
        "id": "inv-5",
        "description": "Trade margin*leverage must satisfy minPositionSize",
        "related_code": [
          "TradingExtension.sol:validateTrade"
        ],
        "origin": "check"
      },
      {
        "id": "inv-6",
        "description": "Trade leverage within allowed bounds",
        "related_code": [
          "TradingExtension.sol:validateTrade"
        ],
        "origin": "check"
      },
      {
        "id": "inv-7",
        "description": "Verified price signature must be from an allowed node",
        "related_code": [
          "TradingLibrary.sol:verifyPrice"
        ],
        "origin": "check"
      },
      {
        "id": "inv-8",
        "description": "Price timestamp must be within valid signature window",
        "related_code": [
          "TradingLibrary.sol:verifyPrice"
        ],
        "origin": "check"
      },
      {
        "id": "inv-9",
        "description": "updateFunding must set OI exactly to parameters",
        "related_code": [
          "Position.sol:updateFunding"
        ],
        "origin": "check"
      },
      {
        "id": "inv-10",
        "description": "fundingDeltaPerSec computed correctly in updateFunding",
        "related_code": [
          "Position.sol:updateFunding"
        ],
        "origin": "check"
      },
      {
        "id": "inv-11",
        "description": "mint initializes trade and assigns ownership",
        "related_code": [
          "Position.sol:mint"
        ],
        "origin": "check"
      },
      {
        "id": "inv-12",
        "description": "PairsContract.modifyLongOi never exceeds maxOi on open",
        "related_code": [
          "PairsContract.sol:modifyLongOi"
        ],
        "origin": "check"
      },
      {
        "id": "inv-13",
        "description": "PairsContract.modifyShortOi never exceeds maxOi on open",
        "related_code": [
          "PairsContract.sol:modifyShortOi"
        ],
        "origin": "check"
      },
      {
        "id": "inv-14",
        "description": "StableVault deposit mints correct stable amount",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "inv-15",
        "description": "Limit orders must respect delay before execution",
        "related_code": [
          "Trading.sol:executeLimitOrder"
        ],
        "origin": "check"
      },
      {
        "id": "inv-1",
        "description": "Referral code can only be created if it does not already exist.",
        "related_code": [
          "Referrals.createReferralCode"
        ],
        "origin": "check"
      },
      {
        "id": "inv-2",
        "description": "Lock period must be between minPeriod and maxPeriod.",
        "related_code": [
          "Lock.lock"
        ],
        "origin": "check"
      },
      {
        "id": "inv-3",
        "description": "Only allowed tokens can be deposited in StableVault.",
        "related_code": [
          "StableVault.deposit"
        ],
        "origin": "check"
      },
      {
        "id": "inv-4",
        "description": "NFT minting in GovNFT cannot exceed MAX supply.",
        "related_code": [
          "GovNFT._mint"
        ],
        "origin": "check"
      },
      {
        "id": "1",
        "description": "Bond period cannot exceed 365 days.",
        "related_code": [
          "BondNFT.sol:extendLock:require(bond.period+_period <= 365, \"MAX PERIOD\");"
        ],
        "origin": "check"
      },
      {
        "id": "2",
        "description": "Rewards distribution per asset is only performed if totalShares > 0.",
        "related_code": [
          "BondNFT.sol:distribute:if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;"
        ],
        "origin": "check"
      }
    ],
    "general_security_ctx": [
      {
        "id": "ctx-1",
        "source": "web_context",
        "context_type": "tooling_note",
        "details": "LayerZero cross-chain calls are isolated per channel, with immutable security settings and separation of verification and execution."
      },
      {
        "id": "ctx-2",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Chainlink price feeds should always check decimals and freshness, and fallback logic should be audited."
      },
      {
        "id": "ctx-3",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "ERC721Enumerable prohibits batch minting and ensures O(1) deletion for NFT positions."
      },
      {
        "id": "ctx-4",
        "source": "web_context",
        "context_type": "security_assumption",
        "details": "On Arbitrum, blockhash, coinbase, and difficulty are not secure for randomness; block.number is not the local L2 block height."
      },
      {
        "id": "sec-1",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Owner-only functions for critical parameter changes."
      },
      {
        "id": "sec-2",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Meta-transaction support for user convenience."
      },
      {
        "id": "1",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Should only be called by a manager contract"
      }
    ],
    "static_summary": null
  }
}