{
  "analyzed_contracts": [
    {
      "id": "LandManager.sol",
      "file_name": "LandManager.sol",
      "core_purpose_raw": "The LandManager contract manages the staking of Munchable NFTs on virtual plots owned by landlords, facilitating earnings and revenue sharing in the form of Schnibbles. It tracks plot ownership, manages staking/unstaking, applies a tax rate, distributes rewards, and controls plot metadata.",
      "core_purpose_digest": "Handles staking of Munchable NFTs on virtual land, manages metadata, distributes rewards and taxes.",
      "identified_roles": [
        "accountmanager (tracks player metadata)",
        "landlord (users who lock tokens to obtain and manage plots)",
        "lockmanager (tracks locked value/land plots)",
        "munchable nft owners (players staking nfts to farm rewards)",
        "nftattributesmanager (provides nft stats/attributes)",
        "protocol admin (controls configstorage)"
      ],
      "key_state_vars": [
        "accountmanager",
        "base_schnibble_rate",
        "default_tax_rate",
        "lockmanager",
        "max_tax_rate",
        "min_tax_rate",
        "munchableowner (mapping: tokenid to original owner)",
        "munchablesstaked (mapping: account to staked nft ids)",
        "munchnft",
        "nftattributesmanager",
        "plotmetadata (mapping: landlord to metadata)",
        "plotoccupied (mapping: landlord, plotid to plot occupancy)",
        "price_per_plot",
        "rarity_bonuses",
        "realm_bonuses",
        "toilerstate (mapping: tokenid to state)"
      ],
      "key_functions": [
        "_farmplots(address _sender)",
        "_getmainaccountrequireregistered(address)",
        "_getnumplots(address)",
        "_removetokenidfromstakedlist(address, uint256)",
        "configupdated()",
        "farmplots()",
        "initialize(address _configstorage)",
        "stakemunchable(address landlord, uint256 tokenid, uint256 plotid)",
        "transfertounoccupiedplot(uint256 tokenid, uint256 plotid)",
        "triggerplotmetadata()",
        "unstakemunchable(uint256 tokenid)",
        "updateplotmetadata(address landlord)",
        "updatetaxrate(uint256 newtaxrate)"
      ],
      "external_dependencies": [
        "baseblastmanagerupgradeable",
        "iaccountmanager (accountmanager)",
        "iconfigstorage (config storage values, e.g., addresses and config parameters)",
        "ierc721 (munchnft)",
        "ilockmanager (lockmanager)",
        "inftattributesmanager (nftattributesmanager)",
        "munchablescommonlib"
      ],
      "security_notes": [
        "Pausing (notPaused modifier) restricts sensitive operations during emergencies.",
        "Relies on external contract addresses/configuration via ConfigStorage; improper updates may break integration or enable abuse.",
        "Enforces player registration on all critical actions (via _getMainAccountRequireRegistered).",
        "Staking can only occur if the NFT is approved for contract; revocation of approval is up to user vigilance.",
        "Length of staked Munchables per user capped (<=10) to prevent abuse.",
        "Reentrancy risk present due to external token/NFT transfers (ERC721 transferFrom); no explicit reentrancy guard detected.",
        "Reward logic depends on state from multiple contracts (potential for reward manipulation if dependencies are misbehaving or untrusted).",
        "Upgradeable contract pattern used; storage collision and initializer risks must be considered.",
        "Call to transferFrom in staking/unstaking relies on proper ERC721 implementation and correct handling of _safeTransferFrom patterns.",
        "Dirty flag handles certain edge cases of changes in plot counts during reward claiming.",
        "Possible race conditions if external state changes (lockManager or config updates) occur simultaneously with user actions.",
        "Events are emitted for off-chain tracking."
      ],
      "static_findings": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The LandManager contract is part of a virtual land and farming protocol where users can stake NFT characters (Munchables) on plots of land owned by landlords. This contract manages the relationship between landlords who own plots of land and users who stake their Munchable NFTs on these plots to earn rewards in the form of \"Schnibbles.\"",
    "overall_goal_digest": "Manages virtual land and NFT staking for farming gameplay, enabling NFT rewards and landlord-tenant reward sharing.",
    "actors_capabilities": [
      "accountmanager: gatekeeping (registration requirement), player metadata updates, controls access to protocol functions.",
      "admin/protocol owner: controls config storage and can update global addresses/parameters.",
      "external contracts: provide nft attributes and may enforce or bypass further access/logic via upgradeability.",
      "landlords: lock tokens to acquire plots, set/change tax rate, initialize/trigger plot metadata.",
      "lockmanager: determines how many plots a landlord owns by weighted value locked.",
      "nft owners: stake/unstake nfts, transfer staked nfts between plots, claim distributed rewards (schnibbles)."
    ],
    "core_assets": [
      "munchable nfts (erc721, can be staked for farming).",
      "player registration and metadata.",
      "plot metadata (tax rates, timestamps).",
      "plots of land (allocated via locked tokens and tracked per landlord).",
      "schnibbles (reward points/tokens)."
    ],
    "critical_interactions": [
      "ERC721 transferFrom (in and out) of Munchable NFTs during staking/unstaking.",
      "Delegated configuration updates via ConfigStorage; changing addresses for integrator contracts.",
      "AccountManager and LockManager integration for authentication, permissions, and business logic.",
      "NFT attribute lookups during reward calculation (reward bonus logic).",
      "Reward sharing logic between landlords and NFT stakers: funds/tokens split according to tax rates each time rewards farmed.",
      "Upgradeable contract logic and initializer pattern."
    ],
    "key_assumptions": [
      {
        "id": "ctx1",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Current tax rate after update is within allowed bounds: plotMetadata[landlord].currentTaxRate >= MIN_TAX_RATE && plotMetadata[landlord].currentTaxRate <= MAX_TAX_RATE",
        "related_code": null
      },
      {
        "id": "ctx2",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After triggerPlotMetadata, metadata initialized: plotMetadata[mainAccount].lastUpdated == block.timestamp && plotMetadata[mainAccount].currentTaxRate == DEFAULT_TAX_RATE",
        "related_code": null
      },
      {
        "id": "ctx3",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Stake does not increase staked munchables beyond limit: munchablesStaked[mainAccount].length <= 10",
        "related_code": null
      },
      {
        "id": "ctx4",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After staking, plot is marked occupied: plotOccupied[landlord][plotId].occupied == true && plotOccupied[landlord][plotId].tokenId == tokenId",
        "related_code": null
      },
      {
        "id": "ctx5",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After staking, munchableOwner maps token to staker: munchableOwner[tokenId] == mainAccount",
        "related_code": null
      },
      {
        "id": "ctx6",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "toilerState initialized correctly on stake",
        "related_code": null
      },
      {
        "id": "ctx7",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "PRICE_PER_PLOT is non-zero",
        "related_code": null
      },
      {
        "id": "ctx8",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "DEFAULT_TAX_RATE within bounds",
        "related_code": null
      },
      {
        "id": "ctx9",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, plot is marked unoccupied, owner cleared, and toilerState reset",
        "related_code": null
      },
      {
        "id": "ctx10",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Transfer of staked Munchable only allowed if plot is unoccupied, owner matches, and plotId within bounds",
        "related_code": null
      },
      {
        "id": "ctx11",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Only registered players can operate",
        "related_code": null
      },
      {
        "id": "ctx12",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Stake requires approved or operator rights",
        "related_code": null
      },
      {
        "id": "ctx13",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Unstake only if owned by staker",
        "related_code": null
      },
      {
        "id": "ctx14",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Cannot stake to self",
        "related_code": null
      },
      {
        "id": "ctx15",
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Cannot transfer to occupied plot",
        "related_code": null
      }
    ],
    "general_security_ctx": [
      {
        "id": "ctx16",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Upgradeable contract with initializer pattern; admin should ensure one-time initialization and protect against storage collisions.",
        "related_code": null
      },
      {
        "id": "ctx17",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "ERC721 transfers should use safeTransferFrom to ensure tokens are not locked; consider reentrancy guard in staking/unstaking to prevent attacks from malicious NFT contracts.",
        "related_code": null
      },
      {
        "id": "ctx18",
        "source": "web_context",
        "context_type": "security_assumption",
        "details": "Approval management in ERC721 (approve/setApprovalForAll) could allow third-party operator to transfer NFTs on behalf of user.",
        "related_code": null
      },
      {
        "id": "ctx19",
        "source": "web_context",
        "context_type": "other",
        "details": "transient storage and MCOPY opcode changes in Solidity 0.8.25 do not directly impact business logic unless contract uses assembly for memory copying or tstore.",
        "related_code": null
      },
      {
        "id": "ctx20",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Access control for updating config addresses or storage keys should be strictly restricted.",
        "related_code": null
      },
      {
        "id": "ctx21",
        "source": "web_context",
        "context_type": "invariant_rule",
        "details": "Ensure that upgradeable proxy patterns follow EIP-1967 for storage layout and do not expose dangerous delegatecall paths.",
        "related_code": null
      },
      {
        "id": "ctx22",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Use protected, one-time initializers and lock implementation contract from accidental initialization.",
        "related_code": null
      },
      {
        "id": "ctx23",
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Chainlink VRF recommended for secure randomness; avoid block.timestamp or other miner-controllable fields.",
        "related_code": null
      },
      {
        "id": "ctx24",
        "source": "web_context",
        "context_type": "other",
        "details": "Common vulnerabilities: reentrancy, access control mistakes, input validation, delegatecall storage collisions, unchecked calls.",
        "related_code": null
      }
    ],
    "static_summary": null
  }
}