{
  "analyzed_contracts_summary": [
    {
      "file_name": "LandManager.sol",
      "core_purpose": "Manages staking, unstaking, and reward distribution of Munchable NFTs on virtual land plots; enables landlords to set tax rates and users to farm Schnibbles with revenue sharing.",
      "identified_roles": [
        "landlord",
        "Munchable owner",
        "ConfigStorage",
        "AccountManager"
      ],
      "key_state_variables_security": [
        "MIN_TAX_RATE",
        "MAX_TAX_RATE",
        "DEFAULT_TAX_RATE",
        "BASE_SCHNIBBLE_RATE",
        "PRICE_PER_PLOT",
        "REALM_BONUSES",
        "RARITY_BONUSES",
        "plotMetadata",
        "plotOccupied",
        "munchableOwner",
        "munchablesStaked",
        "toilerState"
      ],
      "key_functions_security": [
        "initialize",
        "_reconfigure",
        "updateTaxRate",
        "triggerPlotMetadata",
        "updatePlotMetadata",
        "stakeMunchable",
        "unstakeMunchable",
        "transferToUnoccupiedPlot",
        "farmPlots",
        "_farmPlots",
        "_removeTokenIdFromStakedList",
        "_getMainAccountRequireRegistered",
        "_getNumPlots"
      ],
      "external_dependencies": [
        "ILockManager",
        "IAccountManager",
        "IERC721 (MunchNFT)",
        "INFTAttributesManager",
        "IConfigStorage",
        "BaseBlastManagerUpgradeable"
      ],
      "security_notes_from_code": [
        "Uses forceFarmPlots modifier to farm before state changes",
        "ERC721.transferFrom calls introduce external calls without explicit reentrancy guard",
        "Custom errors used for invalid states",
        "Mappings track plot occupancy and NFT ownership",
        "Initializer pattern from OpenZeppelin upgradeable contracts"
      ],
      "static_analysis_findings": []
    }
  ],
  "project_context_summary": {
    "overall_protocol_goal": "Enable a virtual real estate and farming economy where NFT holders stake Munchable characters on landlordsâ€™ plots to earn Schnibbles rewards, with tax-based revenue sharing.",
    "system_actors_and_capabilities": [
      "Landlord (locks tokens to own plots, sets tax rate, triggers metadata)",
      "Munchable owner (stakes, transfers, unstakes NFTs; harvests rewards)",
      "ConfigStorage (supplies configurable parameters)",
      "AccountManager (verifies registration and updates player data)"
    ],
    "core_assets_managed": [
      "Munchable NFTs",
      "Schnibbles reward units",
      "Land plot representations",
      "Locked tokens determining plot entitlement"
    ],
    "critical_cross_contract_interactions": [
      "LockManager.getLockedWeightedValue for plot count calculation",
      "AccountManager.getPlayer/updatePlayer for registration and reward state",
      "MunchNFT.transferFrom for NFT custody transfers",
      "NFTAttributesManager.getImmutableAttributes for bonus computations",
      "ConfigStorage for dynamic parameter loading"
    ],
    "key_security_assumptions_or_invariants": [
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Current tax rate after update is within allowed bounds",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "updateTaxRate",
          "unique_snippet": "plotMetadata[landlord].currentTaxRate >= MIN_TAX_RATE && plotMetadata[landlord].currentTaxRate <= MAX_TAX_RATE",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After triggerPlotMetadata, metadata initialized",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "triggerPlotMetadata",
          "unique_snippet": "plotMetadata[mainAccount].lastUpdated == block.timestamp && plotMetadata[mainAccount].currentTaxRate == DEFAULT_TAX_RATE",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After updatePlotMetadata, metadata lastUpdated is set",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "updatePlotMetadata",
          "unique_snippet": "plotMetadata[landlord].lastUpdated == block.timestamp",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Stake does not increase staked munchables beyond limit",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "munchablesStaked[mainAccount].length <= 10",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After staking, plot is marked occupied",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "plotOccupied[landlord][plotId].occupied == true && plotOccupied[landlord][plotId].tokenId == tokenId",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After staking, munchableOwner maps token to staker",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "munchableOwner[tokenId] == mainAccount",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "toilerState initialized correctly on stake",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "toilerState[tokenId] == ToilerState({ lastToilDate: block.timestamp, plotId: plotId, landlord: landlord, latestTaxRate: plotMetadata[landlord].currentTaxRate, dirty: false })",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "PRICE_PER_PLOT is non-zero",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_reconfigure",
          "unique_snippet": "PRICE_PER_PLOT > 0",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "DEFAULT_TAX_RATE within bounds",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_reconfigure",
          "unique_snippet": "DEFAULT_TAX_RATE >= MIN_TAX_RATE && DEFAULT_TAX_RATE <= MAX_TAX_RATE",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, plot is marked unoccupied",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "plotOccupied[landlord][plotId].occupied == false && plotOccupied[landlord][plotId].tokenId == 0",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, munchableOwner cleared",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "munchableOwner[tokenId] == address(0)",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, toilerState reset",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "toilerState[tokenId] == ToilerState({ lastToilDate: 0, plotId: 0, landlord: address(0), latestTaxRate: 0, dirty: false })",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, munchablesStaked does not contain tokenId",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "!munchablesStaked[mainAccount].includes(tokenId)",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Transfer to new plot updates occupancy correctly",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "plotOccupied[landlord][oldPlotId].occupied == false && plotOccupied[landlord][plotId].occupied == true",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Transfer to new plot updates latestTaxRate",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "toilerState[tokenId].latestTaxRate == plotMetadata[landlord].currentTaxRate",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After transfer, toilerState.plotId updated",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "toilerState[tokenId].plotId == plotId",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "_removeTokenIdFromStakedList removes the token",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_removeTokenIdFromStakedList",
          "unique_snippet": "!munchablesStaked[mainAccount].includes(tokenId) && munchablesStaked[mainAccount].length == oldLength - 1",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "_getNumPlots computes based on lockManager",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_getNumPlots",
          "unique_snippet": "_getNumPlots(account) == lockManager.getLockedWeightedValue(account) / PRICE_PER_PLOT",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "In farming, total schnibbles split equals total",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "(schnibblesTotal - schnibblesLandlord) + schnibblesLandlord == schnibblesTotal",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "In farming, landlord allocation never exceeds total schnibbles",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "schnibblesLandlord <= schnibblesTotal",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "toilerState.lastToilDate updated to at most block.timestamp",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "toilerState[tokenId].lastToilDate <= block.timestamp",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Dirty flag set when plot count decreases",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "if (_getNumPlots(landlord) < _toiler.plotId) { toilerState[tokenId].dirty == true }",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Only registered players can operate",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_getMainAccountRequireRegistered",
          "unique_snippet": "accountManager.getPlayer(_account).registrationDate != 0",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Tax rate update requires metadata initialized",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "updateTaxRate",
          "unique_snippet": "plotMetadata[landlord].lastUpdated != 0",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Stake requires approved or operator rights",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "munchNFT.isApprovedForAll(mainAccount, address(this)) || munchNFT.getApproved(tokenId) == address(this)",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Unstake only if owned by staker",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "munchableOwner[tokenId] == mainAccount",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Plot ID within available plots on stake",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "plotId < _getNumPlots(landlord)",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Cannot stake to self",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "landlord != mainAccount",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Cannot transfer to occupied plot",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "plotOccupied[_toiler.landlord][plotId].occupied == false",
          "lines": null
        }
      }
    ],
    "applicable_general_security_context": [
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Use safeTransferFrom for ERC721 transfers to trigger onERC721Received and reduce risk of locked tokens; transferFrom requires explicit reentrancy guard",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "munchNFT.transferFrom(mainAccount, address(this), tokenId)",
          "lines": null
        }
      },
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Apply checks-effects-interactions pattern and reentrancy guards around external calls",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Upgradeable contracts must use initializer modifier and call _disableInitializers() in constructor to prevent direct initialization",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "constructor",
          "unique_snippet": "_disableInitializers();",
          "lines": null
        }
      },
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Use OpenZeppelin custom errors (EIP-6093) for explicit failure modes and gas efficiency",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "other_detail",
        "details": "Ensure contracts compiled with v0.8.25 target the same EVM version (cancun) to avoid execution mismatches",
        "related_code_ref": null
      }
    ],
    "overall_static_analysis_summary": null
  }
}