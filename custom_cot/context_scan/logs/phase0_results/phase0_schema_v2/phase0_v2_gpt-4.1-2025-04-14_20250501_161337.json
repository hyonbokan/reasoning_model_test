{
  "analyzed_contracts_summary": [
    {
      "file_name": "LandManager.sol",
      "core_purpose": "Manages the relationship between landlords and users who stake Munchable NFTs on virtual plots of land. Handles plot metadata, tax rates, staking/unstaking Munchables, transferring staked tokens between plots, and reward distribution (Schnibbles) based on a tax system. Integrates with external managers for player accounts, attributes, and land ownership based on locked tokens.",
      "identified_roles": [
        "Landlord",
        "Munchable owner (player)",
        "Admin (ConfigStorage, contract upgraders)",
        "AccountManager",
        "LockManager"
      ],
      "key_state_variables_security": [
        "MIN_TAX_RATE",
        "MAX_TAX_RATE",
        "DEFAULT_TAX_RATE",
        "BASE_SCHNIBBLE_RATE",
        "PRICE_PER_PLOT",
        "plotMetadata",
        "plotOccupied",
        "munchablesStaked",
        "munchableOwner",
        "toilerState",
        "lockManager",
        "accountManager",
        "munchNFT",
        "nftAttributesManager"
      ],
      "key_functions_security": [
        "initialize",
        "updateTaxRate",
        "triggerPlotMetadata",
        "updatePlotMetadata",
        "stakeMunchable",
        "unstakeMunchable",
        "transferToUnoccupiedPlot",
        "farmPlots",
        "_farmPlots",
        "_removeTokenIdFromStakedList",
        "_getMainAccountRequireRegistered",
        "_getNumPlots",
        "_reconfigure"
      ],
      "external_dependencies": [
        "ILockManager",
        "IAccountManager",
        "IERC721 (MunchNFT)",
        "INFTAttributesManager",
        "BaseBlastManagerUpgradeable",
        "IConfigStorage"
      ],
      "security_notes_from_code": [
        "Implements upgradeable pattern (constructor disables initializers, has initialize())",
        "Relies on external configuration via ConfigStorage",
        "ERC721 usage (transferFrom, isApprovedForAll, getApproved) with external MunchNFT contract",
        "Enforces role separation via onlyConfigStorage modifier and registration checks",
        "Checks on plot occupancy, max staked tokens (<=10 per account), and approved ownership before staking",
        "Direct token transfers (transferFrom) of NFTs in and out of this contract",
        "No reentrancy guard present despite external calls in stake/unstake to ERC721",
        "Effectively uses struct clearing on unstake to reset state mappings",
        "No constructors used; supports upgradeable/UUPS design",
        "Configurable financial parameters (e.g., tax rate) with lower/upper bounds"
      ],
      "static_analysis_findings": []
    }
  ],
  "project_context_summary": {
    "overall_protocol_goal": "Establish a virtual real estate and farming protocol where users can stake NFT characters (Munchables) on landlord-owned plots to earn and share Schnibbles rewards, with economic incentives, staking mechanics, and customizable parameters fostering player strategy.",
    "system_actors_and_capabilities": [
      "Landlords: Own plots by locking tokens, set tax rates, receive share of Schnibbles from players using their land.",
      "Players/Munchable owners: Stake NFTs on landlord plots, control unstaking/transfers, earn rewards.",
      "Admins: Configure system-wide parameters through ConfigStorage, deploy and upgrade contracts.",
      "LockManager: Manages locked tokens and determines plot allocation.",
      "AccountManager: Controls player registrations, account data, and ensures only registered players can interact.",
      "MunchNFT: ERC721 contract representing the stakable NFT assets.",
      "NFTAttributesManager: Assigns game-relevant traits to each Munchable NFT."
    ],
    "core_assets_managed": [
      "Munchable NFTs (ERC721)",
      "Schnibbles (reward points/tokens)",
      "Locked collateral for land ownership",
      "Virtual plots/real-estate within the game world"
    ],
    "critical_cross_contract_interactions": [
      "LockManager: Determines number of plots by calculating from locked tokens.",
      "AccountManager: Ensures actors are registered players; updates player rewards on staking/farming.",
      "MunchNFT: Transfers ERC721 tokens on stake/unstake; checks ownership/approval for critical actions.",
      "NFTAttributesManager: Retrieves unique attributes affecting reward calculation.",
      "ConfigStorage: Provides system parameter configuration to LandManager."
    ],
    "key_security_assumptions_or_invariants": [
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "The current tax rate after update must always be within the allowed minimum and maximum bounds.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "updateTaxRate",
          "unique_snippet": "if (newTaxRate < MIN_TAX_RATE || newTaxRate > MAX_TAX_RATE)",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After triggerPlotMetadata, metadata for the landlord must be initialized with the current block timestamp and set to DEFAULT_TAX_RATE.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "triggerPlotMetadata",
          "unique_snippet": "plotMetadata[mainAccount] = PlotMetadata({ lastUpdated: block.timestamp, currentTaxRate: DEFAULT_TAX_RATE });",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After updatePlotMetadata, landlord's metadata lastUpdated is set to block.timestamp.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "updatePlotMetadata",
          "unique_snippet": "plotMetadata[landlord].lastUpdated = block.timestamp;",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Stake cannot increase the munchablesStaked for an account beyond the limit; capped at 10.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "if (munchablesStaked[mainAccount].length > 10) revert TooManyStakedMunchiesError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After staking, plot is marked occupied and tokenId assigned.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "plotOccupied[landlord][plotId] = Plot({ occupied: true, tokenId: tokenId });",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After staking, munchableOwner maps tokenId to the staker (mainAccount).",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "munchableOwner[tokenId] = mainAccount;",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "toilerState for tokenId is initialized correctly on stake.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "toilerState[tokenId] = ToilerState(...)",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "PRICE_PER_PLOT must be non-zero after _reconfigure.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_reconfigure",
          "unique_snippet": "PRICE_PER_PLOT = ...",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "DEFAULT_TAX_RATE remains within min and max bounds after _reconfigure.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_reconfigure",
          "unique_snippet": "DEFAULT_TAX_RATE = ...",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, the plot is marked unoccupied and tokenId reset to 0.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "plotOccupied[_toiler.landlord][_toiler.plotId] = Plot({ occupied: false, tokenId: 0 });",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, munchableOwner for the tokenId is cleared (set to address(0)).",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "munchableOwner[tokenId] = address(0);",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, toilerState data for tokenId is reset to zero/default values.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "toilerState[tokenId] = ToilerState({ lastToilDate: 0, plotId: 0, landlord: address(0), latestTaxRate: 0, dirty: false });",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After unstaking, munchablesStaked does not contain tokenId.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_removeTokenIdFromStakedList",
          "unique_snippet": "if (!found) revert InvalidTokenIdError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Transfer to new plot updates occupancy correctly for old and new plotIds.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "plotOccupied[_toiler.landlord][oldPlotId] = Plot({ occupied: false, tokenId: 0 }); plotOccupied[_toiler.landlord][plotId] = Plot({ occupied: true, tokenId: tokenId });",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After transfer, toilerState.latestTaxRate is updated to the current plot tax rate.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate;",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "After transfer, toilerState.plotId is updated.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "toilerState[tokenId].plotId == plotId;",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "_removeTokenIdFromStakedList removes the token and reduces the array length by 1.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_removeTokenIdFromStakedList",
          "unique_snippet": "if (!found) revert InvalidTokenIdError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "_getNumPlots for an account is computed as locked weighted value / PRICE_PER_PLOT from LockManager.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_getNumPlots",
          "unique_snippet": "return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "In farming (reward distribution), schnibbles split equals the total calculated.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "(schnibblesTotal - schnibblesLandlord) + schnibblesLandlord == schnibblesTotal",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "In farming, landlord allocation never exceeds total schnibbles generated.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "schnibblesLandlord <= schnibblesTotal",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "toilerState.lastToilDate is set to at most block.timestamp during farmPlots.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "toilerState[tokenId].lastToilDate = timestamp;",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "invariant_rule",
        "details": "Dirty flag is set when plot count decreases under a staked Munchableâ€™s index.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "if (_getNumPlots(landlord) < _toiler.plotId) { toilerState[tokenId].dirty = true; }",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Only registered players (accountManager.getPlayer(_account).registrationDate != 0) can interact with key LandManager methods.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_getMainAccountRequireRegistered",
          "unique_snippet": "if (_player.registrationDate == 0) revert PlayerNotRegisteredError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Updating the tax rate requires plot metadata to be initialized (plotMetadata[landlord].lastUpdated != 0).",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "updateTaxRate",
          "unique_snippet": "if (plotMetadata[landlord].lastUpdated == 0) revert PlotMetadataNotUpdatedError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Staking requires either approved or operator rights for the NFT in question.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "if (!munchNFT.isApprovedForAll(mainAccount, address(this)) && munchNFT.getApproved(tokenId) != address(this)) revert NotApprovedError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Unstaking is only allowed by the current staker/owner of the Munchable.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "unstakeMunchable",
          "unique_snippet": "if (munchableOwner[tokenId] != mainAccount) revert InvalidOwnerError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Plot ID supplied during stake must be strictly less than number of plots the landlord owns.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "if (plotId >= totalPlotsAvail) revert PlotTooHighError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Cannot stake to one's own land (must stake on another landlord's plot).",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable",
          "unique_snippet": "if (landlord == mainAccount) revert CantStakeToSelfError();",
          "lines": null
        }
      },
      {
        "source": "invariants",
        "context_type": "security_assumption",
        "details": "Transfer of a staked Munchable can only occur to an unoccupied plot.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "transferToUnoccupiedPlot",
          "unique_snippet": "if (plotOccupied[_toiler.landlord][plotId].occupied) revert OccupiedPlotError(_toiler.landlord, plotId);",
          "lines": null
        }
      }
    ],
    "applicable_general_security_context": [
      {
        "source": "docs",
        "context_type": "eip_standard",
        "details": "MunchNFT follows the ERC721 (NFT) standard for all stakable game characters.",
        "related_code_ref": null
      },
      {
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Upgradeable contracts do not use constructors; all state initialization occurs in initialize() using OpenZeppelin Initializable.",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "When using upgradeable proxies, always explicitly call all parent initializers when upgrading or instantiating contracts.",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Proxy contracts must be protected from direct initialization by calling _disableInitializers() in the constructor.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "constructor",
          "unique_snippet": "constructor() { _disableInitializers(); }",
          "lines": null
        }
      },
      {
        "source": "web_context",
        "context_type": "compiler_warning",
        "details": "If using inline assembly, ensure transient storage (`tstore`) and new MCOPY opcodes are not misused or introduce vulnerabilities. Solidity 0.8.25 emits warnings for unsafe use.",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "access_control_rule",
        "details": "Access control in critical functions is enforced via require checks and role-specific modifiers.",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "common_vulnerability",
        "details": "Calls to ERC721.transferFrom may enable reentrancy if the ERC721 is custom/non-compliant. Prefer checks-effects-interactions pattern and/or use reentrancy guards, particularly when transferring tokens externally.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "stakeMunchable, unstakeMunchable",
          "unique_snippet": "munchNFT.transferFrom(...);",
          "lines": null
        }
      },
      {
        "source": "web_context",
        "context_type": "best_practice",
        "details": "Always check that only registered/whitelisted contracts are able to access upgrade/admin functions.",
        "related_code_ref": null
      },
      {
        "source": "web_context",
        "context_type": "other_detail",
        "details": "Relying on block.timestamp for rewards exposes protocol to potential block timestamp manipulation, especially for short timeframes.",
        "related_code_ref": {
          "file": "LandManager.sol",
          "element_name": "_farmPlots",
          "unique_snippet": "timestamp = block.timestamp;",
          "lines": null
        }
      }
    ],
    "overall_static_analysis_summary": null
  }
}