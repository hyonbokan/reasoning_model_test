{
  "analyzed_contracts": [
    {
      "id": "Vultisig.sol",
      "file_name": "Vultisig.sol",
      "core_purpose_raw": "ERC20 token contract for Vultisig, with an initial supply of 100 million tokens, owned by deployer. Supports approveAndCall pattern for composability with contracts that implement IApproveAndCallReceiver.",
      "core_purpose_digest": "ERC20 token with 100M supply and approveAndCall for composability.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IApproveAndCallReceiver"
      ],
      "compiler_version": "0.8.24",
      "identified_roles": [
        "Owner"
      ],
      "key_state_vars": [
        "ERC20",
        "Ownable"
      ],
      "key_functions": [
        "approveAndCall",
        "constructor"
      ],
      "external_dependencies": [
        "./interfaces/IApproveAndCallReceiver.sol",
        "@openzeppelin/contracts/access/Ownable.sol",
        "@openzeppelin/contracts/token/ERC20/ERC20.sol"
      ],
      "security_notes": [
        "approveAndCall pattern can introduce reentrancy if receiver contract is malicious.",
        "No burn or mint after deployment; supply is fixed at 100M."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "Whitelist.sol",
      "file_name": "Whitelist.sol",
      "core_purpose_raw": "Handles whitelist and blacklist logic for Vultisig token transfers. Enforces max ETH contribution per address, supports self-whitelisting (when enabled), and integrates with Uniswap V3 TWAP oracle for price checks. Only the Vultisig token contract can call checkWhitelist, which is used to restrict token purchases during the whitelist period.",
      "core_purpose_digest": "Manages whitelist/blacklist and per-address cap for Vultisig token sales.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IOracle"
      ],
      "compiler_version": "0.8.24",
      "identified_roles": [
        "Owner",
        "Vultisig"
      ],
      "key_state_vars": [
        "_allowedWhitelistIndex",
        "_contributed",
        "_isBlacklisted",
        "_isSelfWhitelistDisabled",
        "_locked",
        "_maxAddressCap",
        "_oracle",
        "_pool",
        "_vultisig",
        "_whitelistCount",
        "_whitelistIndex"
      ],
      "key_functions": [
        "addBatchWhitelist",
        "addWhitelistedAddress",
        "checkWhitelist",
        "receive",
        "setAllowedWhitelistIndex",
        "setBlacklisted",
        "setIsSelfWhitelistDisabled",
        "setLocked",
        "setMaxAddressCap",
        "setOracle",
        "setPool",
        "setVultisig"
      ],
      "external_dependencies": [
        "./interfaces/IOracle.sol",
        "@openzeppelin/contracts/access/Ownable.sol"
      ],
      "security_notes": [
        "Only Vultisig contract can call checkWhitelist (enforced by onlyVultisig modifier).",
        "Self-whitelisting is only possible when enabled and not blacklisted.",
        "ETH sent for self-whitelisting is refunded.",
        "Max address cap is enforced per address using Uniswap V3 TWAP price.",
        "Owner can set all critical parameters, including pool, oracle, and caps.",
        "Blacklist can override whitelist status."
      ],
      "config_params": [
        {
          "name": "maxAddressCap",
          "storage_key": "_maxAddressCap",
          "load_site": {
            "id": "Whitelist.sol:maxAddressCap",
            "file": "Whitelist.sol",
            "element_name": "maxAddressCap",
            "unique_snippet": "function maxAddressCap() external view returns (uint256) { return _maxAddressCap; }"
          },
          "downstream_uses": [
            "Whitelist.sol:checkWhitelist"
          ],
          "role": "upper_bound"
        },
        {
          "name": "oracle",
          "storage_key": "_oracle",
          "load_site": {
            "id": "Whitelist.sol:oracle",
            "file": "Whitelist.sol",
            "element_name": "oracle",
            "unique_snippet": "function oracle() external view returns (address) { return _oracle; }"
          },
          "downstream_uses": [
            "Whitelist.sol:checkWhitelist"
          ],
          "role": "address_key"
        },
        {
          "name": "pool",
          "storage_key": "_pool",
          "load_site": {
            "id": "Whitelist.sol:pool",
            "file": "Whitelist.sol",
            "element_name": "pool",
            "unique_snippet": "function pool() external view returns (address) { return _pool; }"
          },
          "downstream_uses": [
            "Whitelist.sol:checkWhitelist"
          ],
          "role": "address_key"
        },
        {
          "name": "allowedWhitelistIndex",
          "storage_key": "_allowedWhitelistIndex",
          "load_site": {
            "id": "Whitelist.sol:allowedWhitelistIndex",
            "file": "Whitelist.sol",
            "element_name": "allowedWhitelistIndex",
            "unique_snippet": "function allowedWhitelistIndex() external view returns (uint256) { return _allowedWhitelistIndex; }"
          },
          "downstream_uses": [
            "Whitelist.sol:checkWhitelist"
          ],
          "role": "upper_bound"
        }
      ],
      "flag_trackers": [
        {
          "name": "_locked",
          "expected_setters": [
            "setLocked"
          ],
          "observed_setters": [
            "setLocked"
          ],
          "note": "When true, token transfers via pool are locked."
        },
        {
          "name": "_isSelfWhitelistDisabled",
          "expected_setters": [
            "setIsSelfWhitelistDisabled"
          ],
          "observed_setters": [
            "setIsSelfWhitelistDisabled"
          ],
          "note": "When true, self-whitelisting is disabled."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "VultisigWhitelisted.sol",
      "file_name": "VultisigWhitelisted.sol",
      "core_purpose_raw": "Extends Vultisig token to enforce whitelist checks during restricted period. Calls checkWhitelist on the configured whitelist contract in _beforeTokenTransfer. Owner can disable whitelist by setting contract address to zero.",
      "core_purpose_digest": "ERC20 extension: enforces whitelist checks on transfer during restricted period.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IWhitelist"
      ],
      "compiler_version": "0.8.24",
      "identified_roles": [
        "Owner"
      ],
      "key_state_vars": [
        "_whitelistContract"
      ],
      "key_functions": [
        "_beforeTokenTransfer",
        "setWhitelistContract"
      ],
      "external_dependencies": [
        "../Vultisig.sol",
        "../interfaces/IWhitelist.sol"
      ],
      "security_notes": [
        "If _whitelistContract is set to address(0), transfers are unrestricted.",
        "Whitelist checks are enforced on every transfer when enabled."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "UniswapV3Oracle.sol",
      "file_name": "UniswapV3Oracle.sol",
      "core_purpose_raw": "Provides a Uniswap V3 TWAP oracle for VULT/ETH price over a 30-minute window, with a 5% slippage buffer. Used by Whitelist contract to estimate ETH value of VULT tokens for cap enforcement.",
      "core_purpose_digest": "Uniswap V3 TWAP oracle for VULT/ETH with 5% slippage, used for whitelist cap.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IOracle",
        "IUniswapV3Pool"
      ],
      "compiler_version": "0.8.24",
      "identified_roles": [],
      "key_state_vars": [
        "BASE_AMOUNT",
        "PERIOD",
        "WETH",
        "baseToken",
        "pool"
      ],
      "key_functions": [
        "peek"
      ],
      "external_dependencies": [
        "../../interfaces/IOracle.sol",
        "./uniswapv0.8/OracleLibrary.sol",
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"
      ],
      "security_notes": [
        "TWAP oracles can be manipulated if pool liquidity is low.",
        "5% slippage buffer is applied to price.",
        "Oracle is read-only; no state-changing logic."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "FullMath.sol",
      "file_name": "FullMath.sol",
      "core_purpose_raw": "Library for 512-bit precision multiplication and division, used for price and liquidity math in Uniswap V3 and related contracts. Provides mulDiv and mulDivRoundingUp for precise math without overflow.",
      "core_purpose_digest": "512-bit precision math for price/liquidity calculations (Uniswap V3).",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": null,
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "mulDiv",
        "mulDivRoundingUp"
      ],
      "external_dependencies": [],
      "security_notes": [
        "mulDiv reverts if denominator is zero or result overflows uint256.",
        "Used for precise math in Uniswap V3 oracles and pools."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "FullMath.sol:mulDiv",
          "file": "FullMath.sol",
          "element_name": "mulDiv",
          "op": "mul",
          "lhs": "a",
          "rhs": "b",
          "scale": 1,
          "comment": "512-bit multiplication and division for price/liquidity math"
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "OracleLibrary",
      "file_name": "OracleLibrary.sol",
      "core_purpose_raw": "Provides utility functions to interact with Uniswap V3 pool oracles, including fetching time-weighted average ticks, quoting token amounts at a tick, and retrieving the age of the oldest observation in a pool.",
      "core_purpose_digest": "Uniswap V3 oracle utility library for TWAP, quoting, and observation info.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IUniswapV3Pool"
      ],
      "compiler_version": ">=0.5.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "consult",
        "getOldestObservationSecondsAgo",
        "getQuoteAtTick"
      ],
      "external_dependencies": [
        "./FullMath.sol",
        "./TickMath.sol",
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol"
      ],
      "security_notes": [
        "consult: require(period != 0, \"BP\") prevents division by zero.",
        "getOldestObservationSecondsAgo: require(observationCardinality > 0, \"NI\") ensures valid pool state."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "OracleLibrary.getQuoteAtTick.mulDiv_192",
          "file": "OracleLibrary.sol",
          "element_name": "getQuoteAtTick",
          "op": "mul",
          "lhs": "ratioX192",
          "rhs": "baseAmount",
          "scale": 192,
          "comment": "Fixed-point math for price quote when sqrtRatioX96 <= uint128.max"
        },
        {
          "id": "OracleLibrary.getQuoteAtTick.mulDiv_128",
          "file": "OracleLibrary.sol",
          "element_name": "getQuoteAtTick",
          "op": "mul",
          "lhs": "ratioX128",
          "rhs": "baseAmount",
          "scale": 128,
          "comment": "Fixed-point math for price quote when sqrtRatioX96 > uint128.max"
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "TickMath",
      "file_name": "TickMath.sol",
      "core_purpose_raw": "Math library for computing sqrt prices from ticks and vice versa for Uniswap V3. Supports fixed-point Q64.96 numbers and price ranges between 2**-128 and 2**128.",
      "core_purpose_digest": "Math for Uniswap V3: tick <-> sqrt price conversions (Q64.96).",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": ">=0.5.0",
      "identified_roles": [],
      "key_state_vars": [
        "MAX_SQRT_RATIO",
        "MAX_TICK",
        "MIN_SQRT_RATIO",
        "MIN_TICK"
      ],
      "key_functions": [
        "getSqrtRatioAtTick",
        "getTickAtSqrtRatio"
      ],
      "external_dependencies": [],
      "security_notes": [
        "getSqrtRatioAtTick: require(absTick <= uint256(uint24(MAX_TICK)), \"T\") bounds check.",
        "getTickAtSqrtRatio: require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\") bounds check."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "TickMath.getSqrtRatioAtTick.Q64.96",
          "file": "TickMath.sol",
          "element_name": "getSqrtRatioAtTick",
          "op": "div",
          "lhs": "ratio",
          "rhs": "1<<32",
          "scale": 96,
          "comment": "Converts Q128.128 to Q128.96"
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ILOManager",
      "file_name": "ILOManager.sol",
      "core_purpose_raw": "Manages Initial Liquidity Offering (ILO) projects and pools, including project initialization, pool deployment, fee configuration, and project lifecycle (launch, refund, admin transfer). Integrates with Uniswap V3 pools and supports vesting, whitelisting, and fee management.",
      "core_purpose_digest": "Manages ILO projects/pools, fees, and Uniswap V3 integration.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IILOManager",
        "IILOPool",
        "IUniswapV3Factory",
        "IUniswapV3Pool"
      ],
      "compiler_version": "=0.7.6",
      "identified_roles": [
        "Owner",
        "ProjectAdmin"
      ],
      "key_state_vars": [
        "DEFAULT_DEADLINE_OFFSET",
        "FEE_TAKER",
        "ILO_POOL_IMPLEMENTATION",
        "PERFORMANCE_FEE",
        "PLATFORM_FEE",
        "UNIV3_FACTORY",
        "WETH9",
        "_cachedProject",
        "_initializedILOPools"
      ],
      "key_functions": [
        "claimRefund",
        "initILOPool",
        "initProject",
        "initialize",
        "launch",
        "setDefaultDeadlineOffset",
        "setFeeTaker",
        "setILOPoolImplementation",
        "setPerformanceFee",
        "setPlatformFee",
        "setRefundDeadlineForProject",
        "transferAdminProject"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/access/Ownable.sol",
        "@openzeppelin/contracts/proxy/Clones.sol",
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol",
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol",
        "@uniswap/v3-core/contracts/libraries/TickMath.sol"
      ],
      "security_notes": [
        "initILOPool: require(_project.uniV3PoolAddress != address(0), \"NI\") ensures project exists.",
        "initILOPool: require(params.start < params.end && params.end < _project.launchTime, \"PT\") checks time logic.",
        "initILOPool: require(sqrtRatioLowerX96 < _project.initialPoolPriceX96 && sqrtRatioLowerX96 < sqrtRatioUpperX96, \"RANGE\") checks tick range.",
        "_cacheProject: require(_project.uniV3PoolAddress == address(0), \"RE\") prevents re-initialization.",
        "launch: require(block.timestamp > _cachedProject[uniV3PoolAddress].launchTime, \"LT\") ensures launch time.",
        "launch: require(_cachedProject[uniV3PoolAddress].initialPoolPriceX96 == sqrtPriceX96, \"UV3P\") price check.",
        "claimRefund: require(_cachedProject[uniV3PoolAddress].refundDeadline < block.timestamp, \"RFT\") refund time check."
      ],
      "config_params": [
        {
          "name": "PLATFORM_FEE",
          "storage_key": "PLATFORM_FEE",
          "load_site": {
            "id": "ILOManager.PLATFORM_FEE",
            "file": "ILOManager.sol",
            "element_name": "PLATFORM_FEE",
            "unique_snippet": "uint16 public override PLATFORM_FEE;"
          },
          "downstream_uses": [
            "ILOManager._cacheProject",
            "ILOManager.setPlatformFee"
          ],
          "role": "misc"
        },
        {
          "name": "PERFORMANCE_FEE",
          "storage_key": "PERFORMANCE_FEE",
          "load_site": {
            "id": "ILOManager.PERFORMANCE_FEE",
            "file": "ILOManager.sol",
            "element_name": "PERFORMANCE_FEE",
            "unique_snippet": "uint16 public override PERFORMANCE_FEE;"
          },
          "downstream_uses": [
            "ILOManager._cacheProject",
            "ILOManager.setPerformanceFee"
          ],
          "role": "misc"
        },
        {
          "name": "FEE_TAKER",
          "storage_key": "FEE_TAKER",
          "load_site": {
            "id": "ILOManager.FEE_TAKER",
            "file": "ILOManager.sol",
            "element_name": "FEE_TAKER",
            "unique_snippet": "address public override FEE_TAKER;"
          },
          "downstream_uses": [
            "ILOManager.setFeeTaker"
          ],
          "role": "address_key"
        },
        {
          "name": "ILO_POOL_IMPLEMENTATION",
          "storage_key": "ILO_POOL_IMPLEMENTATION",
          "load_site": {
            "id": "ILOManager.ILO_POOL_IMPLEMENTATION",
            "file": "ILOManager.sol",
            "element_name": "ILO_POOL_IMPLEMENTATION",
            "unique_snippet": "address public override ILO_POOL_IMPLEMENTATION;"
          },
          "downstream_uses": [
            "ILOManager.setILOPoolImplementation"
          ],
          "role": "address_key"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ILOPool",
      "file_name": "ILOPool.sol",
      "core_purpose_raw": "Implements the ILO pool logic, wrapping Uniswap V3 positions as ERC721 NFTs, handling user participation, vesting, liquidity management, refunds, and claims. Integrates with ILOManager and Uniswap V3 pools, supports whitelisting, vesting, and project-level configuration.",
      "core_purpose_digest": "ERC721-wrapped ILO pool: user buy, vest, claim, refund, Uniswap V3 integration.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IILOPool",
        "IILOManager",
        "IUniswapV3Pool",
        "IERC721Metadata"
      ],
      "compiler_version": "=0.7.6",
      "identified_roles": [
        "Manager",
        "ProjectAdmin"
      ],
      "key_state_vars": [
        "_launchSucceeded",
        "_nextId",
        "_positions",
        "_refundTriggered",
        "_vestingConfigs",
        "saleInfo",
        "totalRaised"
      ],
      "key_functions": [
        "_deductFees",
        "_saleAmountNeeded",
        "buy",
        "claim",
        "claimProjectRefund",
        "claimRefund",
        "initialize",
        "launch",
        "positions",
        "totalSold",
        "vestingStatus"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/token/ERC721/ERC721.sol",
        "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol",
        "@uniswap/v3-core/contracts/libraries/FixedPoint128.sol",
        "@uniswap/v3-core/contracts/libraries/FullMath.sol"
      ],
      "security_notes": [
        "buy: require(_isWhitelisted(recipient), \"UA\") enforces whitelist.",
        "buy: require(block.timestamp > saleInfo.start && block.timestamp < saleInfo.end, \"ST\") sale window.",
        "buy: require(saleInfo.hardCap - totalRaised >= raiseAmount, \"HC\") hard cap.",
        "buy: require(totalSold() <= saleInfo.maxSaleAmount, \"SA\") sale amount.",
        "buy: require(raiseAmount <= saleInfo.maxCapPerUser - _position.raiseAmount, \"UC\") per-user cap.",
        "claim: require(_launchSucceeded, \"PNL\") only after launch.",
        "claim: require(positionLiquidity >= liquidity2Claim) checks liquidity.",
        "claimRefund: require(!_launchSucceeded, \"PL\") and require(block.timestamp >= _project.refundDeadline, \"RFT\") for refund.",
        "launch: require(!_launchSucceeded, \"PL\") and require(!_refundTriggered, \"IRF\") for launch.",
        "launch: require(totalRaised >= saleInfo.softCap, \"SC\") soft cap."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "_launchSucceeded",
          "expected_setters": [
            "launch"
          ],
          "observed_setters": [
            "launch"
          ],
          "note": "Indicates if pool has been launched; blocks refund after launch."
        },
        {
          "name": "_refundTriggered",
          "expected_setters": [
            "claimRefund",
            "claimProjectRefund"
          ],
          "observed_setters": [
            "claimRefund",
            "claimProjectRefund"
          ],
          "note": "Indicates if refund has been triggered; blocks launch after refund."
        }
      ],
      "math_scale_hints": [
        {
          "id": "ILOPool._deductFees.mulDiv",
          "file": "ILOPool.sol",
          "element_name": "_deductFees",
          "op": "mul",
          "lhs": "amount0",
          "rhs": "feeBPS",
          "scale": 10000,
          "comment": "Fee deduction in basis points"
        },
        {
          "id": "ILOPool._deductFees.mulDiv",
          "file": "ILOPool.sol",
          "element_name": "_deductFees",
          "op": "mul",
          "lhs": "amount1",
          "rhs": "feeBPS",
          "scale": 10000,
          "comment": "Fee deduction in basis points"
        }
      ],
      "aggregate_trackers": [
        {
          "id": "ILOPool.totalRaised",
          "name": "totalRaised",
          "must_increase_on": [
            "buy"
          ],
          "must_decrease_on": []
        }
      ],
      "delay_guards": []
    },
    {
      "id": "ILOPoolImmutableState",
      "file_name": "ILOPoolImmutableState.sol",
      "core_purpose_raw": "Abstract contract providing immutable state variables for ILO pools, including token addresses, tick bounds, and cached pool key/address. Used by periphery contracts for configuration and state reference.",
      "core_purpose_digest": "Holds immutable state for ILO pools (tokens, ticks, pool key).",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IILOPoolImmutableState"
      ],
      "compiler_version": "=0.7.6",
      "identified_roles": [],
      "key_state_vars": [
        "BPS",
        "MANAGER",
        "RAISE_TOKEN",
        "SALE_TOKEN",
        "SQRT_RATIO_LOWER_X96",
        "SQRT_RATIO_UPPER_X96",
        "SQRT_RATIO_X96",
        "TICK_LOWER",
        "TICK_UPPER",
        "WETH9",
        "_cachedPoolKey",
        "_cachedUniV3PoolAddress"
      ],
      "key_functions": [],
      "external_dependencies": [
        "../interfaces/IILOPoolImmutableState.sol",
        "../libraries/PoolAddress.sol"
      ],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ILOVest.sol",
      "file_name": "ILOVest.sol",
      "core_purpose_raw": "Abstract contract for vesting logic, handling position vesting schedules and share validation. Provides internal functions to calculate unlocked and claimable liquidity for NFT positions, and validates vesting share and schedule configurations to ensure no overflow and correct share distribution.",
      "core_purpose_digest": "Abstract vesting logic for NFT positions, validates vesting shares and schedules.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IILOVest"
      ],
      "compiler_version": "0.7.6",
      "identified_roles": [],
      "key_state_vars": [
        "_positionVests"
      ],
      "key_functions": [
        "_claimableLiquidity",
        "_unlockedLiquidity",
        "_validateSharesAndVests",
        "_validateVestSchedule"
      ],
      "external_dependencies": [
        "IILOVest"
      ],
      "security_notes": [
        "Validates that vesting shares do not overflow and sum to 10000 (BPS).",
        "Vesting schedule must not overlap and must start after launchTime."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ILOWhitelist.sol",
      "file_name": "ILOWhitelist.sol",
      "core_purpose_raw": "Abstract contract for managing a whitelist of addresses for an ILO (Initial Liquidity Offering). Allows project admins to open access to all, add or remove addresses in batch, and check whitelist status. Uses OpenZeppelin's EnumerableSet for address management.",
      "core_purpose_digest": "Manages whitelist for ILO, supports open-to-all and batch admin operations.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IILOWhitelist"
      ],
      "compiler_version": "0.7.6",
      "identified_roles": [
        "onlyProjectAdmin"
      ],
      "key_state_vars": [
        "_openToAll",
        "_whitelisted"
      ],
      "key_functions": [
        "_isWhitelisted",
        "_removeWhitelist",
        "_setOpenToAll",
        "_setWhitelist",
        "batchRemoveWhitelist",
        "batchWhitelist",
        "isOpenToAll",
        "isWhitelisted",
        "setOpenToAll"
      ],
      "external_dependencies": [
        "EnumerableSet",
        "IILOWhitelist"
      ],
      "security_notes": [
        "Whitelist and open-to-all status can only be changed by project admin."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "_openToAll",
          "expected_setters": [
            "setOpenToAll"
          ],
          "observed_setters": [
            "_setOpenToAll"
          ],
          "note": "Controls if whitelist is bypassed."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "LiquidityManagement.sol",
      "file_name": "LiquidityManagement.sol",
      "core_purpose_raw": "Abstract contract for internal liquidity management in Uniswap V3 pools. Implements the UniswapV3MintCallback to handle minting and payment logic, and provides an internal function to add liquidity to a pool with slippage checks.",
      "core_purpose_digest": "Internal Uniswap V3 liquidity management with mint callback and slippage checks.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IUniswapV3MintCallback",
        "ILOPoolImmutableState"
      ],
      "compiler_version": "0.7.6",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "addLiquidity",
        "uniswapV3MintCallback"
      ],
      "external_dependencies": [
        "ILOPoolImmutableState",
        "IUniswapV3MintCallback",
        "IUniswapV3Pool",
        "PeripheryPayments"
      ],
      "security_notes": [
        "Slippage is checked after minting liquidity.",
        "Callback only allowed from cached pool address."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "Initializable.sol",
      "file_name": "Initializable.sol",
      "core_purpose_raw": "Abstract contract providing initialization guard logic. Ensures that initialization can only happen once, and provides modifiers to restrict function execution to before or after initialization.",
      "core_purpose_digest": "Provides initialization guard and modifiers for one-time setup.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.7.6",
      "identified_roles": [],
      "key_state_vars": [
        "_initialized"
      ],
      "key_functions": [
        "_disableInitialize"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Modifiers enforce single initialization and restrict access accordingly."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "_initialized",
          "expected_setters": [
            "_disableInitialize"
          ],
          "observed_setters": [
            "_disableInitialize",
            "whenNotInitialized"
          ],
          "note": "Prevents re-initialization."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "Multicall.sol",
      "file_name": "Multicall.sol",
      "core_purpose_raw": "Abstract contract enabling multiple method calls in a single transaction using delegatecall. Returns results for each call and reverts with error message if any call fails.",
      "core_purpose_digest": "Enables batching multiple calls in one transaction with error bubbling.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IMulticall"
      ],
      "compiler_version": "0.7.6",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "multicall"
      ],
      "external_dependencies": [
        "IMulticall"
      ],
      "security_notes": [
        "Uses delegatecall for each call; reverts and bubbles up error messages on failure."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "PeripheryPayments",
      "file_name": "PeripheryPayments.sol",
      "core_purpose_raw": "Abstract contract for handling payments in a periphery contract, supporting ETH (via WETH9) and ERC20 tokens. It provides a unified internal pay() function that can pay with WETH9 (wrapping ETH as needed), transfer tokens from the contract, or pull tokens from a payer. The receive() function only accepts ETH sent from the WETH9 contract.",
      "core_purpose_digest": "Handles periphery contract payments in ETH (via WETH9) and ERC20, with unified pay() logic.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IERC20",
        "IWETH9",
        "ILOPoolImmutableState"
      ],
      "compiler_version": ">=0.7.5",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "pay",
        "receive"
      ],
      "external_dependencies": [
        "../interfaces/external/IWETH9.sol",
        "../libraries/TransferHelper.sol",
        "./ILOPoolImmutableState.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      ],
      "security_notes": [
        "receive() only accepts ETH from WETH9 contract, preventing accidental ETH transfers from other sources.",
        "pay() wraps ETH as WETH9 only as needed, and uses safe transfer helpers for ERC20."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ChainId",
      "file_name": "ChainId.sol",
      "core_purpose_raw": "Library providing a function to get the current chain ID using inline assembly.",
      "core_purpose_digest": "Library to fetch the current chain ID via assembly.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": ">=0.7.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "get"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "LiquidityAmounts",
      "file_name": "LiquidityAmounts.sol",
      "core_purpose_raw": "Library for computing liquidity amounts from token amounts and price ranges, and vice versa, for Uniswap V3-style pools. Provides functions to convert between token amounts and liquidity, using fixed-point math and price boundaries.",
      "core_purpose_digest": "Computes liquidity/token amounts for Uniswap V3 pools using price ranges and fixed-point math.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "FullMath",
        "FixedPoint96",
        "SqrtPriceMath"
      ],
      "compiler_version": ">=0.5.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "getAmount0ForLiquidity",
        "getAmount1ForLiquidity",
        "getLiquidityForAmount0",
        "getLiquidityForAmount1",
        "toUint128"
      ],
      "external_dependencies": [
        "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol",
        "@uniswap/v3-core/contracts/libraries/FullMath.sol",
        "@uniswap/v3-core/contracts/libraries/SqrtPriceMath.sol"
      ],
      "security_notes": [
        "toUint128() reverts if downcast would lose data.",
        "All math uses FullMath.mulDiv to avoid overflows and ensure precision."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "LiquidityAmounts.getLiquidityForAmount0.mulDiv",
          "file": "LiquidityAmounts.sol",
          "element_name": "getLiquidityForAmount0",
          "op": "mul",
          "lhs": "sqrtRatioAX96",
          "rhs": "sqrtRatioBX96",
          "scale": 96,
          "comment": "FixedPoint96.Q96 scaling for sqrt price math"
        },
        {
          "id": "LiquidityAmounts.getLiquidityForAmount1.mulDiv",
          "file": "LiquidityAmounts.sol",
          "element_name": "getLiquidityForAmount1",
          "op": "div",
          "lhs": "amount1",
          "rhs": "sqrtRatioBX96 - sqrtRatioAX96",
          "scale": 96,
          "comment": "FixedPoint96.Q96 scaling for sqrt price math"
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "PoolAddress",
      "file_name": "PoolAddress.sol",
      "core_purpose_raw": "Library for deriving a Uniswap V3 pool address deterministically from the factory address, two token addresses, and the pool fee. Provides a struct for pool keys and functions to order tokens and compute the pool address using CREATE2.",
      "core_purpose_digest": "Derives Uniswap V3 pool address from factory, tokens, and fee using CREATE2.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": ">=0.5.0",
      "identified_roles": [],
      "key_state_vars": [
        "POOL_INIT_CODE_HASH"
      ],
      "key_functions": [
        "computeAddress",
        "getPoolKey"
      ],
      "external_dependencies": [],
      "security_notes": [
        "computeAddress() requires token0 < token1, preventing address collision.",
        "Uses keccak256 and abi.encodePacked for deterministic address calculation."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "PositionKey",
      "file_name": "PositionKey.sol",
      "core_purpose_raw": "Library for computing a unique position key for Uniswap V3 positions, based on owner address and tick range.",
      "core_purpose_digest": "Computes unique position key for Uniswap V3 positions from owner and tick range.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": ">=0.5.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "compute"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "SqrtPriceMathPartial",
      "file_name": "SqrtPriceMathPartial.sol",
      "core_purpose_raw": "Exposes two functions from @uniswap/v3-core SqrtPriceMath that use square root of price as a Q64.96 and liquidity to compute deltas. Provides getAmount0Delta and getAmount1Delta to calculate the amount of token0 or token1 required to cover a position of given liquidity between two price points, using Q64.96 fixed-point math.",
      "core_purpose_digest": "Computes token0/token1 deltas for liquidity between sqrt price ranges using Q64.96 math.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": ">=0.5.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "getAmount0Delta",
        "getAmount1Delta"
      ],
      "external_dependencies": [
        "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol",
        "@uniswap/v3-core/contracts/libraries/FullMath.sol",
        "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol"
      ],
      "security_notes": [
        "Requires sqrtRatioAX96 > 0 in getAmount0Delta to prevent division by zero.",
        "Uses FullMath and UnsafeMath for precise and safe arithmetic operations."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "SqrtPriceMathPartial_getAmount0Delta_mulDiv",
          "file": "SqrtPriceMathPartial.sol",
          "element_name": "getAmount0Delta",
          "op": "mul",
          "lhs": "numerator1",
          "rhs": "numerator2",
          "scale": 96,
          "comment": "Q64.96 fixed-point multiplication"
        },
        {
          "id": "SqrtPriceMathPartial_getAmount1Delta_mulDiv",
          "file": "SqrtPriceMathPartial.sol",
          "element_name": "getAmount1Delta",
          "op": "mul",
          "lhs": "liquidity",
          "rhs": "sqrtRatioBX96 - sqrtRatioAX96",
          "scale": 96,
          "comment": "Q64.96 fixed-point multiplication"
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "TransferHelper",
      "file_name": "TransferHelper.sol",
      "core_purpose_raw": "Provides safe wrappers for ERC20 and ETH transfers and approvals. Ensures that token transfers, approvals, and ETH transfers either succeed or revert with a clear error string. Handles non-standard ERC20s that do not return a boolean value.",
      "core_purpose_digest": "Safely handles ERC20 and ETH transfers/approvals, reverting on failure.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IERC20"
      ],
      "compiler_version": ">=0.6.0",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "safeApprove",
        "safeTransfer",
        "safeTransferETH",
        "safeTransferFrom"
      ],
      "external_dependencies": [
        "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      ],
      "security_notes": [
        "Reverts with specific error strings ('STF', 'ST', 'SA', 'STE') on failure.",
        "Handles ERC20 tokens that do not return a boolean value.",
        "ETH transfer uses call and checks for success."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The Vultisig protocol is a token-based system with whitelist functionality and initial liquidity offering (ILO) capabilities. The protocol consists of several interconnected contracts that work together to provide a controlled token distribution mechanism. At the core of the protocol is the Vultisig token, an ERC20 token with an initial supply of 100 million tokens. The token is extended by the VultisigWhitelisted contract, which adds whitelist functionality to control token transfers during a restricted period. This whitelist mechanism is managed by the Whitelist contract, which maintains a list of approved addresses and enforces various restrictions on token transfers. The whitelist system includes self-whitelist, blacklist, max contribution caps, whitelist index tracking, and Uniswap V3 TWAP oracle integration. The protocol also includes an Initial Liquidity Offering (ILO) system through the ILOManager and ILOPool contracts, allowing for project creation, pool initialization, token sales, vesting, and Uniswap V3 launches, with safety mechanisms like refunds, whitelist controls, and vesting schedules.",
    "overall_goal_digest": "Token protocol with whitelist, ILO, and Uniswap V3 launch, enforcing controlled distribution.",
    "actors_capabilities": [
      "Fee Taker: Receives platform/performance fees from ILOs.",
      "Project Admins: Create/manage ILO projects, control whitelist, claim refunds.",
      "Protocol Owner: Set global parameters (fees, caps, oracles, pools).",
      "Users: Can self-whitelist (if enabled), participate in token sales, claim tokens, and claim refunds."
    ],
    "core_assets": [
      "ILOManager and ILOPool contracts",
      "Uniswap V3 pool",
      "Vultisig token (VULT)",
      "Whitelist contract"
    ],
    "critical_interactions": [
      "VultisigWhitelisted calls Whitelist.checkWhitelist on transfer.",
      "Whitelist uses UniswapV3Oracle to estimate ETH value for cap enforcement.",
      "ILOManager and ILOPool manage project creation, sales, vesting, and refunds.",
      "Owner can set/disable whitelist, change caps, and set oracles/pools."
    ],
    "key_assumptions": [
      {
        "id": "assumption-1",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Only the configured Vultisig contract can invoke whitelist checks."
      },
      {
        "id": "assumption-2",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Uniswap V3 TWAP oracle is trusted for price estimation."
      },
      {
        "id": "assumption-3",
        "source": "docs",
        "context_type": "security_assumption",
        "details": "Owner is trusted to set critical parameters (caps, oracles, pools, whitelist)."
      }
    ],
    "invariants": [
      {
        "id": "inv-1",
        "description": "Total supply after deployment equals 100 million tokens",
        "related_code": [
          "Vultisig.sol:constructor"
        ],
        "origin": "check"
      },
      {
        "id": "inv-2",
        "description": "Only the configured Vultisig contract can invoke whitelist checks",
        "related_code": [
          "Whitelist.sol:onlyVultisig"
        ],
        "origin": "check"
      },
      {
        "id": "inv-3",
        "description": "When adding a new whitelisted address index and count increment correctly",
        "related_code": [
          "Whitelist.sol:_addWhitelistedAddress"
        ],
        "origin": "check"
      },
      {
        "id": "inv-4",
        "description": "Receive only whitelists when self-whitelist enabled and not blacklisted",
        "related_code": [
          "Whitelist.sol:receive"
        ],
        "origin": "check"
      },
      {
        "id": "inv-5",
        "description": "After self-whitelist, sender index must be non-zero",
        "related_code": [
          "Whitelist.sol:receive"
        ],
        "origin": "check"
      },
      {
        "id": "inv-6",
        "description": "Contributed ETH never exceeds maxAddressCap",
        "related_code": [
          "Whitelist.sol:checkWhitelist"
        ],
        "origin": "check"
      },
      {
        "id": "inv-7",
        "description": "Lock flag enforced during pool-to-user transfers in whitelist period",
        "related_code": [
          "Whitelist.sol:checkWhitelist"
        ],
        "origin": "check"
      },
      {
        "id": "inv-8",
        "description": "Buyer must be whitelisted within allowed index on buy actions",
        "related_code": [
          "Whitelist.sol:checkWhitelist"
        ],
        "origin": "check"
      },
      {
        "id": "inv-9",
        "description": "UniswapV3Oracle.peek output includes 5% slippage max",
        "related_code": [
          "UniswapV3Oracle.sol:peek"
        ],
        "origin": "check"
      },
      {
        "id": "inv-10",
        "description": "FullMath.mulDiv denominator non-zero and result <2^256",
        "related_code": [
          "FullMath.sol:mulDiv"
        ],
        "origin": "check"
      },
      {
        "id": "inv-ilo-hardcap",
        "description": "totalRaised must never exceed saleInfo.hardCap in ILOPool.",
        "related_code": [
          "ILOPool.buy"
        ],
        "origin": "check"
      },
      {
        "id": "inv-ilo-softcap-launch",
        "description": "ILOPool cannot launch unless totalRaised >= saleInfo.softCap.",
        "related_code": [
          "ILOPool.launch"
        ],
        "origin": "check"
      },
      {
        "id": "inv-ilo-no-refund-after-launch",
        "description": "Refund cannot be triggered after pool launch (_launchSucceeded).",
        "related_code": [
          "ILOPool.claimRefund",
          "ILOPool.claimProjectRefund"
        ],
        "origin": "check"
      },
      {
        "id": "inv1",
        "description": "Total vesting shares must equal 10000 (BPS) in both shares and schedule validation.",
        "related_code": [
          "ILOVest.sol:_validateSharesAndVests",
          "ILOVest.sol:_validateVestSchedule"
        ],
        "origin": "check"
      },
      {
        "id": "inv2",
        "description": "Vesting schedule entries must not overlap and must start after launchTime.",
        "related_code": [
          "ILOVest.sol:_validateVestSchedule"
        ],
        "origin": "check"
      },
      {
        "id": "transferhelper_revert_on_failure",
        "description": "All token and ETH transfers/approvals must revert if the operation fails.",
        "related_code": [],
        "origin": "check"
      }
    ],
    "general_security_ctx": [
      {
        "id": "sec-1",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Use OpenZeppelin SafeERC20 for all token transfers to handle non-standard ERC20s."
      },
      {
        "id": "sec-2",
        "source": "docs",
        "context_type": "best_practice",
        "details": "TWAP oracles can be manipulated if pool liquidity is low; use long windows and cross-check prices."
      },
      {
        "id": "sec-3",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Owner/admin roles must be protected and monitored for critical parameter changes."
      },
      {
        "id": "sec-4",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Avoid using SELFDESTRUCT in new contracts due to EIP-6780 changes."
      },
      {
        "id": "sec-5",
        "source": "docs",
        "context_type": "best_practice",
        "details": "For approveAndCall, ensure receiver contract is trusted to avoid reentrancy."
      },
      {
        "id": "ctx-ilo-timelock",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Refunds are only possible after refundDeadline and before launch."
      },
      {
        "id": "ctx-ilo-fee-deduction",
        "source": "logic_inference",
        "context_type": "best_practice",
        "details": "Platform and performance fees are deducted using basis points (BPS) math."
      },
      {
        "id": "gsc1",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Slippage is checked after minting liquidity in Uniswap V3 pool."
      },
      {
        "id": "gsc2",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Multicall reverts and bubbles up error messages on failure."
      },
      {
        "id": "transferhelper_error_strings",
        "source": "code_comment",
        "context_type": "tooling_note",
        "details": "Reverts with specific error strings ('STF', 'ST', 'SA', 'STE') on failure."
      }
    ],
    "static_summary": null
  }
}