{
  "analyzed_contracts": [
    {
      "id": "Authorization.sol",
      "file_name": "Authorization.sol",
      "core_purpose_raw": "Authorization provides a base for role-based access control, delegating role checks to an external RoleManager contract. It is used as a parent for contracts that require permissioned actions, ensuring that only accounts with the correct roles can execute sensitive functions.",
      "core_purpose_digest": "Base contract for role-based access control via external RoleManager.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IRoleManager"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GOVERNANCE"
      ],
      "key_state_vars": [
        "__roleManager"
      ],
      "key_functions": [
        "_roleManager"
      ],
      "external_dependencies": [
        "AuthorizationBase",
        "IRoleManager"
      ],
      "security_notes": [],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "RoleManager.sol",
      "file_name": "RoleManager.sol",
      "core_purpose_raw": "RoleManager manages roles and permissions for the protocol. It allows governance to grant and revoke roles, check role membership, and enumerate role members. It uses OpenZeppelin's EnumerableSet for efficient set operations and ensures only authorized accounts can modify roles.",
      "core_purpose_digest": "Manages protocol roles and permissions, with governance-controlled grants/revokes.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IAddressProvider",
        "IRoleManager"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GAUGE_ZAP",
        "GOVERNANCE",
        "MAINTENANCE",
        "POOL",
        "POOL_FACTORY",
        "VAULT"
      ],
      "key_state_vars": [
        "_roleMembers",
        "_roles",
        "addressProvider"
      ],
      "key_functions": [
        "addGaugeZap",
        "addGovernor",
        "getRoleMember",
        "getRoleMemberCount",
        "grantRole",
        "hasRole",
        "removeGaugeZap",
        "renounceGovernance",
        "revokeRole"
      ],
      "external_dependencies": [
        "AddressProviderKeys",
        "EnumerableSet",
        "Errors",
        "IAddressProvider",
        "Roles",
        "UncheckedMath"
      ],
      "security_notes": [
        "EnumerableSet's add/remove do not revert on failure; always check return values with require()."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "GOVERNANCE",
          "expected_setters": [
            "grantRole",
            "addGovernor",
            "renounceGovernance"
          ],
          "observed_setters": [
            "_grantRole",
            "_revokeRole"
          ],
          "note": "Tracks governance membership for protocol control."
        }
      ],
      "math_scale_hints": []
    },
    {
      "id": "AddressProvider.sol",
      "file_name": "AddressProvider.sol",
      "core_purpose_raw": "AddressProvider is a central registry for contract addresses and configuration keys in the protocol. It manages pools, vaults, staker vaults, fee handlers, and actions. It supports two-phase commit for config changes and enforces governance control over critical updates.",
      "core_purpose_digest": "Central registry for contract addresses/configs, with governance-controlled updates.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IGasBank",
        "IAddressProvider",
        "IStakerVault",
        "IOracleProvider"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GOVERNANCE",
        "POOL",
        "POOL_FACTORY",
        "VAULT"
      ],
      "key_state_vars": [
        "_actions",
        "_addressKeyMetas",
        "_stakerVaults",
        "_tokenToPools",
        "_vaults",
        "_whiteListedFeeHandlers"
      ],
      "key_functions": [
        "addPool",
        "addStakerVault",
        "executeAddress",
        "freezeAddress",
        "initializeAddress",
        "prepareAddress",
        "removePool"
      ],
      "external_dependencies": [
        "AddressProviderKeys",
        "AddressProviderMeta",
        "AuthorizationBase",
        "EnumerableMapping",
        "EnumerableSet",
        "Preparable",
        "Roles"
      ],
      "security_notes": [
        "Two-phase commit for config changes mitigates accidental/unauthorized updates.",
        "All address initializations and updates are gated by governance."
      ],
      "static_findings": [],
      "config_params": [
        {
          "name": "TREASURY",
          "storage_key": "_TREASURY_KEY",
          "load_site": {
            "id": "AddressProvider.constructor",
            "file": "AddressProvider.sol",
            "element_name": "constructor",
            "unique_snippet": "AddressProviderMeta.Meta(true, false);\n_addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());\n_setConfig(AddressProviderKeys._TREASURY_KEY, treasury);"
          },
          "downstream_uses": [],
          "role": "address_key"
        },
        {
          "name": "ROLE_MANAGER",
          "storage_key": "_ROLE_MANAGER_KEY",
          "load_site": {
            "id": "AddressProvider.initialize",
            "file": "AddressProvider.sol",
            "element_name": "initialize",
            "unique_snippet": "AddressProviderMeta.Meta(true, true);\n_addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());\n_setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);"
          },
          "downstream_uses": [],
          "role": "address_key"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "BkdLocker.sol",
      "file_name": "BkdLocker.sol",
      "core_purpose_raw": "BkdLocker allows users to lock governance tokens (BKD) for boosted rewards and voting power. It manages user balances, boost factors, and distributes protocol fees to lockers. It supports migration of reward tokens and enforces withdrawal delays for unlocking.",
      "core_purpose_digest": "BKD token locker for boosted rewards, fee distribution, and voting power.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IBkdLocker",
        "IMigrationContract"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GOVERNANCE"
      ],
      "key_state_vars": [
        "balances",
        "boostFactors",
        "govToken",
        "rewardToken",
        "totalLocked",
        "totalLockedBoosted"
      ],
      "key_functions": [
        "claimFees",
        "computeNewBoost",
        "depositFees",
        "executeUnlocks",
        "lock",
        "lockFor",
        "prepareUnlock",
        "userCheckpoint"
      ],
      "external_dependencies": [
        "Authorization",
        "Preparable",
        "SafeERC20",
        "ScaledMath"
      ],
      "security_notes": [
        "Uses SafeERC20 for all token transfers to handle non-standard ERC20s.",
        "Withdrawal delay enforced for unlocks."
      ],
      "static_findings": [],
      "config_params": [
        {
          "name": "startBoost",
          "storage_key": "_START_BOOST",
          "load_site": {
            "id": "BkdLocker.initialize",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_START_BOOST, startBoost);"
          },
          "downstream_uses": [],
          "role": "lower_bound"
        },
        {
          "name": "maxBoost",
          "storage_key": "_MAX_BOOST",
          "load_site": {
            "id": "BkdLocker.initialize",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_MAX_BOOST, maxBoost);"
          },
          "downstream_uses": [],
          "role": "upper_bound"
        },
        {
          "name": "increasePeriod",
          "storage_key": "_INCREASE_PERIOD",
          "load_site": {
            "id": "BkdLocker.initialize",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_INCREASE_PERIOD, increasePeriod);"
          },
          "downstream_uses": [],
          "role": "misc"
        },
        {
          "name": "withdrawDelay",
          "storage_key": "_WITHDRAW_DELAY",
          "load_site": {
            "id": "BkdLocker.initialize",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_WITHDRAW_DELAY, withdrawDelay);"
          },
          "downstream_uses": [],
          "role": "misc"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "BkdLocker.scaledDiv",
          "file": "BkdLocker.sol",
          "element_name": "depositFees",
          "op": "div",
          "lhs": "amount",
          "rhs": "totalLockedBoosted",
          "scale": 1,
          "comment": "Fee integral update uses scaled division for fixed-point math."
        }
      ]
    },
    {
      "id": "Controller.sol",
      "file_name": "Controller.sol",
      "core_purpose_raw": "Controller coordinates protocol components, manages staker vaults and pools, and enforces minimum staked BKD requirements for keepers. It interacts with the InflationManager for reward distribution and supports two-phase commit for config changes.",
      "core_purpose_digest": "Coordinates protocol, manages vaults/pools, and enforces keeper requirements.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IController",
        "IAddressProvider",
        "IStakerVault",
        "ILiquidityPool",
        "IInflationManager"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GOVERNANCE",
        "POOL_FACTORY"
      ],
      "key_state_vars": [
        "addressProvider",
        "inflationManager"
      ],
      "key_functions": [
        "addStakerVault",
        "canKeeperExecuteAction",
        "executeKeeperRequiredStakedBKD",
        "prepareKeeperRequiredStakedBKD",
        "removePool"
      ],
      "external_dependencies": [
        "AddressProviderHelpers",
        "Authorization",
        "Preparable"
      ],
      "security_notes": [],
      "static_findings": [],
      "config_params": [
        {
          "name": "KEEPER_REQUIRED_STAKED_BKD",
          "storage_key": "_KEEPER_REQUIRED_STAKED_BKD",
          "load_site": {
            "id": "Controller.prepareKeeperRequiredStakedBKD",
            "file": "Controller.sol",
            "element_name": "prepareKeeperRequiredStakedBKD",
            "unique_snippet": "_prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);"
          },
          "downstream_uses": [
            "getKeeperRequiredStakedBKD"
          ],
          "role": "lower_bound"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "RewardHandler.sol",
      "file_name": "RewardHandler.sol",
      "core_purpose_raw": "RewardHandler burns accumulated protocol fees and distributes the resulting tokens to BKD lockers. It interacts with FeeBurner and BkdLocker, and uses SafeERC20 for all token transfers.",
      "core_purpose_digest": "Burns protocol fees and distributes to BKD lockers.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IFeeBurner",
        "IBkdLocker",
        "IController",
        "IAddressProvider",
        "IRewardHandler"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [
        "addressProvider",
        "controller"
      ],
      "key_functions": [
        "burnFees"
      ],
      "external_dependencies": [
        "Authorization",
        "Preparable",
        "SafeERC20"
      ],
      "security_notes": [
        "Uses SafeERC20 for all token transfers to handle non-standard ERC20s."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "StakerVault.sol",
      "file_name": "StakerVault.sol",
      "core_purpose_raw": "StakerVault handles staking of LP tokens from Backd pools. It tracks user balances, supports staking/unstaking, and interacts with gauges for reward distribution. It is not ERC-20 compliant and should not be integrated with protocols expecting ERC-20 tokens.",
      "core_purpose_digest": "Handles staking of LP tokens, tracks balances, and interacts with gauges.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IStakerVault",
        "IController",
        "IInflationManager",
        "ILiquidityPool",
        "ILpGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GOVERNANCE"
      ],
      "key_state_vars": [
        "_allowances",
        "_poolTotalStaked",
        "actionLockedBalances",
        "addressProvider",
        "balances",
        "controller",
        "inflationManager",
        "strategies",
        "strategiesTotalStaked",
        "token"
      ],
      "key_functions": [
        "approve",
        "stake",
        "stakeFor",
        "transfer",
        "transferFrom",
        "unstake",
        "unstakeFor"
      ],
      "external_dependencies": [
        "Authorization",
        "Pausable",
        "Preparable",
        "SafeERC20",
        "ScaledMath"
      ],
      "security_notes": [
        "Not ERC-20 compliant; do not integrate with protocols expecting ERC-20 tokens.",
        "Uses SafeERC20 for all token transfers."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "AmmGauge.sol",
      "file_name": "AmmGauge.sol",
      "core_purpose_raw": "AmmGauge tracks staking and reward distribution for AMM LP tokens. It allows users to stake/unstake, claim rewards, and supports pool checkpointing for inflation accrual. Only the controller's inflation manager can kill the gauge.",
      "core_purpose_digest": "Tracks AMM LP staking and distributes rewards based on inflation schedule.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IController",
        "IAmmGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GAUGE_ZAP"
      ],
      "key_state_vars": [
        "ammLastUpdated",
        "ammStakedIntegral",
        "ammToken",
        "balances",
        "controller",
        "killed",
        "perUserShare",
        "perUserStakedIntegral",
        "totalStaked"
      ],
      "key_functions": [
        "claimRewards",
        "poolCheckpoint",
        "stake",
        "stakeFor",
        "unstake",
        "unstakeFor"
      ],
      "external_dependencies": [
        "Authorization",
        "SafeERC20",
        "ScaledMath"
      ],
      "security_notes": [
        "Uses SafeERC20 for all token transfers."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "AmmGauge.scaledDiv",
          "file": "AmmGauge.sol",
          "element_name": "poolCheckpoint",
          "op": "div",
          "lhs": "(controller.inflationManager().getAmmRateForToken(ammToken) * (block.timestamp - uint256(ammLastUpdated)))",
          "rhs": "totalStaked",
          "scale": 1,
          "comment": "Integral update for AMM staking uses scaled division."
        }
      ]
    },
    {
      "id": "BkdToken.sol",
      "file_name": "BkdToken.sol",
      "core_purpose_raw": "BkdToken is the ERC20 implementation of the protocol's governance token. Only the designated minter can mint new tokens.",
      "core_purpose_digest": "ERC20 governance token, mintable only by authorized minter.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IBkdToken"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "MINTER"
      ],
      "key_state_vars": [
        "minter"
      ],
      "key_functions": [
        "mint"
      ],
      "external_dependencies": [
        "ERC20"
      ],
      "security_notes": [
        "Minting restricted to minter address."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "minter",
          "expected_setters": [
            "constructor"
          ],
          "observed_setters": [
            "constructor"
          ],
          "note": "Only minter can mint new BKD tokens."
        }
      ],
      "math_scale_hints": []
    },
    {
      "id": "FeeBurner.sol",
      "file_name": "FeeBurner.sol",
      "core_purpose_raw": "FeeBurner converts accumulated protocol fees (in various tokens) into a single target LP token. It swaps tokens as needed and deposits into the target pool, then returns the resulting LP tokens to the caller.",
      "core_purpose_digest": "Converts protocol fees to a target LP token via swaps and deposits.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IFeeBurner",
        "ILiquidityPool",
        "ISwapperRouter",
        "IAddressProvider"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [
        "_addressProvider"
      ],
      "key_functions": [
        "burnToTarget"
      ],
      "external_dependencies": [
        "AddressProviderHelpers",
        "SafeERC20"
      ],
      "security_notes": [
        "Uses SafeERC20 for all token transfers."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "InflationManager.sol",
      "file_name": "InflationManager.sol",
      "core_purpose_raw": "InflationManager controls the distribution of BKD token rewards across LPs, keepers, and AMM participants. It manages gauges, pool weights, and interacts with the Minter to mint rewards according to the protocol's inflation schedule.",
      "core_purpose_digest": "Manages BKD inflation distribution and gauge weights for rewards.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IStakerVault",
        "IInflationManager",
        "IKeeperGauge",
        "IAmmGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GOVERNANCE",
        "INFLATION_MANAGER"
      ],
      "key_state_vars": [
        "_ammGauges",
        "_keeperGauges",
        "addressProvider",
        "gauges",
        "minter",
        "totalAmmTokenWeight",
        "totalKeeperPoolWeight",
        "totalLpPoolWeight"
      ],
      "key_functions": [
        "executeAmmTokenWeight",
        "executeKeeperPoolWeight",
        "executeLpPoolWeight",
        "mintRewards",
        "prepareAmmTokenWeight",
        "prepareKeeperPoolWeight",
        "prepareLpPoolWeight"
      ],
      "external_dependencies": [
        "Authorization",
        "EnumerableMapping",
        "Preparable"
      ],
      "security_notes": [
        "Two-phase commit for weight updates; only authorized roles can update weights.",
        "Gauges must be whitelisted before minting rewards."
      ],
      "static_findings": [],
      "config_params": [
        {
          "name": "keeperWeight",
          "storage_key": "_KEEPER_WEIGHT_KEY",
          "load_site": {
            "id": "InflationManager.prepareKeeperPoolWeight",
            "file": "InflationManager.sol",
            "element_name": "prepareKeeperPoolWeight",
            "unique_snippet": "_prepare(key, newPoolWeight);"
          },
          "downstream_uses": [
            "executeKeeperPoolWeight"
          ],
          "role": "multiplier"
        },
        {
          "name": "lpWeight",
          "storage_key": "_LP_WEIGHT_KEY",
          "load_site": {
            "id": "InflationManager.prepareLpPoolWeight",
            "file": "InflationManager.sol",
            "element_name": "prepareLpPoolWeight",
            "unique_snippet": "_prepare(key, newPoolWeight);"
          },
          "downstream_uses": [
            "executeLpPoolWeight"
          ],
          "role": "multiplier"
        },
        {
          "name": "ammWeight",
          "storage_key": "_AMM_WEIGHT_KEY",
          "load_site": {
            "id": "InflationManager.prepareAmmTokenWeight",
            "file": "InflationManager.sol",
            "element_name": "prepareAmmTokenWeight",
            "unique_snippet": "_prepare(key, newTokenWeight);"
          },
          "downstream_uses": [
            "executeAmmTokenWeight"
          ],
          "role": "multiplier"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "KeeperGauge.sol",
      "file_name": "KeeperGauge.sol",
      "core_purpose_raw": "KeeperGauge tracks and distributes rewards to keepers based on the value of collateral top-ups they execute. It records fees per epoch, calculates claimable rewards, and interacts with the InflationManager for minting.",
      "core_purpose_digest": "Tracks keeper activity and distributes rewards per epoch.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IController",
        "IKeeperGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GAUGE_ZAP"
      ],
      "key_state_vars": [
        "controller",
        "epoch",
        "keeperRecords",
        "killed",
        "lastUpdated",
        "perPeriodTotalFees",
        "perPeriodTotalInflation",
        "pool"
      ],
      "key_functions": [
        "advanceEpoch",
        "claimRewards",
        "poolCheckpoint",
        "reportFees"
      ],
      "external_dependencies": [
        "Authorization",
        "ScaledMath"
      ],
      "security_notes": [],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "LpGauge.sol",
      "file_name": "LpGauge.sol",
      "core_purpose_raw": "LpGauge tracks staking and reward distribution for LP stakers. It checkpoints user and pool statistics, calculates claimable rewards, and interacts with the InflationManager for minting.",
      "core_purpose_digest": "Tracks LP staking and distributes rewards based on inflation schedule.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IStakerVault",
        "IController",
        "ILpGauge",
        "IRewardsGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GAUGE_ZAP"
      ],
      "key_state_vars": [
        "controller",
        "inflationManager",
        "perUserShare",
        "perUserStakedIntegral",
        "poolLastUpdate",
        "poolStakedIntegral",
        "stakerVault"
      ],
      "key_functions": [
        "claimRewards",
        "poolCheckpoint",
        "userCheckpoint"
      ],
      "external_dependencies": [
        "Authorization",
        "ScaledMath"
      ],
      "security_notes": [],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "LpGauge.scaledDiv",
          "file": "LpGauge.sol",
          "element_name": "_poolCheckpoint",
          "op": "div",
          "lhs": "(currentRate * (block.timestamp - poolLastUpdate))",
          "rhs": "poolTotalStaked",
          "scale": 1,
          "comment": "Integral update for LP staking uses scaled division."
        }
      ]
    },
    {
      "id": "Minter.sol",
      "file_name": "Minter.sol",
      "core_purpose_raw": "Minter mints BKD tokens according to the protocol's inflation schedule. It enforces supply caps, manages inflation decay, and restricts minting to authorized contracts.",
      "core_purpose_digest": "Mints BKD tokens per inflation schedule, enforcing supply caps.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IController",
        "IBkdToken",
        "IMinter"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GOVERNANCE"
      ],
      "key_state_vars": [
        "annualInflationDecayAmm",
        "annualInflationDecayKeeper",
        "annualInflationDecayLp",
        "controller",
        "currentInflationAmountAmm",
        "currentInflationAmountKeeper",
        "currentInflationAmountLp",
        "currentTotalInflation",
        "initialAnnualInflationRateAmm",
        "initialAnnualInflationRateKeeper",
        "initialAnnualInflationRateLp",
        "initialPeriodAmmInflation",
        "initialPeriodKeeperInflation",
        "issuedNonInflationSupply",
        "lastEvent",
        "lastInflationDecay",
        "nonInflationDistribution",
        "token",
        "totalAvailableToNow",
        "totalMintedToNow"
      ],
      "key_functions": [
        "executeInflationRateUpdate",
        "getAmmInflationRate",
        "getKeeperInflationRate",
        "getLpInflationRate",
        "mint",
        "mintNonInflationTokens"
      ],
      "external_dependencies": [
        "Authorization",
        "ReentrancyGuard",
        "SafeERC20",
        "ScaledMath"
      ],
      "security_notes": [
        "Enforces totalMintedToNow <= totalAvailableToNow to prevent over-minting."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "VestedEscrow.sol",
      "file_name": "VestedEscrow.sol",
      "core_purpose_raw": "VestedEscrow manages vesting of reward tokens over time. It allows an admin to fund recipients, tracks vesting schedules, and lets users claim vested tokens. It supports airdropped tokens and is based on Convex's Vested Escrow.",
      "core_purpose_digest": "Manages vesting and claiming of reward tokens for recipients.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IVestedEscrow"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "admin",
        "fundAdmin"
      ],
      "key_state_vars": [
        "admin",
        "endTime",
        "fundAdmin",
        "holdingContract",
        "initialLocked",
        "initialLockedSupply",
        "initializedSupply",
        "rewardToken",
        "startTime",
        "totalClaimed",
        "totalTime",
        "unallocatedSupply"
      ],
      "key_functions": [
        "balanceOf",
        "claim",
        "fund",
        "lockedOf",
        "lockedSupply",
        "vestedOf",
        "vestedSupply"
      ],
      "external_dependencies": [
        "Math",
        "ReentrancyGuard",
        "SafeERC20"
      ],
      "security_notes": [
        "Admin/fundAdmin can fund recipients; only vested tokens can be claimed."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "VestedEscrowRevocable.sol",
      "file_name": "VestedEscrowRevocable.sol",
      "core_purpose_raw": "VestedEscrowRevocable extends VestedEscrow to allow the admin to revoke vesting for a recipient. Unvested tokens are sent to the treasury holding contract. Treasury cannot be revoked.",
      "core_purpose_digest": "Vesting contract with admin revocation; unvested tokens go to treasury.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IVestedEscrowRevocable"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "admin",
        "treasury"
      ],
      "key_state_vars": [
        "_vestedBefore",
        "revokedTime",
        "treasury"
      ],
      "key_functions": [
        "balanceOf",
        "claim",
        "lockedOf",
        "revoke",
        "vestedOf"
      ],
      "external_dependencies": [
        "Math",
        "ReentrancyGuard",
        "SafeERC20",
        "VestedEscrow"
      ],
      "security_notes": [
        "Admin can revoke vesting for any recipient except treasury."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "CvxMintAmount.sol",
      "file_name": "CvxMintAmount.sol",
      "core_purpose_raw": "CvxMintAmount provides a utility to calculate the amount of CVX tokens to mint based on CRV earned, following a cliff-based emission schedule.",
      "core_purpose_digest": "Utility for CVX minting calculation based on CRV earned and cliff schedule.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "getCvxMintAmount"
      ],
      "external_dependencies": [
        "IERC20",
        "UncheckedMath"
      ],
      "security_notes": [],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "Preparable.sol",
      "file_name": "Preparable.sol",
      "core_purpose_raw": "Preparable implements a two-phase commit pattern for updating contract configuration. It enforces a minimum delay for changes and supports resetting and executing pending updates for both addresses and uint256 values.",
      "core_purpose_digest": "Two-phase commit for config changes with enforced delay.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPreparable"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [
        "currentAddresses",
        "currentUInts256",
        "deadlines",
        "pendingAddresses",
        "pendingUInts256"
      ],
      "key_functions": [
        "_executeAddress",
        "_executeUInt256",
        "_prepare",
        "_resetAddressConfig",
        "_resetUInt256Config",
        "_setConfig"
      ],
      "external_dependencies": [],
      "security_notes": [
        "Enforces minimum delay for config changes; deadlines must be checked before execution."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    },
    {
      "id": "PoolMigrationZap.sol",
      "file_name": "PoolMigrationZap.sol",
      "core_purpose_raw": "PoolMigrationZap assists users in migrating their balances from old Backd pools to new ones. It handles token transfers, withdrawal, and deposit into new pools, ensuring a smooth migration process.",
      "core_purpose_digest": "Assists users in migrating balances from old to new Backd pools.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPoolMigrationZap",
        "IAddressProvider",
        "ILiquidityPool"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [
        "_underlyingNewPools"
      ],
      "key_functions": [
        "migrate",
        "migrateAll"
      ],
      "external_dependencies": [
        "SafeERC20"
      ],
      "security_notes": [
        "Uses SafeERC20 for all token transfers."
      ],
      "static_findings": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The Backd Protocol is a decentralized finance (DeFi) platform that provides a comprehensive ecosystem for liquidity provision, staking, and yield generation. The protocol is built around several key components: Liquidity Pools, Staker Vaults, Vaults and Strategies, BKD Token, and Inflation Management. It implements a sophisticated tokenomics and rewards system, including BKD Locker, Gauges, Inflation Manager, and Vested Escrow. Governance and access control are managed via Role Manager and Authorization contracts. Fee management is handled by Fee Burner and Reward Handler. The protocol supports multiple actors (users, governance, keepers, strategies, liquidity providers) and exposes main entry points for deposits, staking, locking, claiming, and protocol management.",
    "overall_goal_digest": "Comprehensive DeFi protocol for liquidity, staking, yield, and BKD tokenomics.",
    "actors_capabilities": [
      "Governance: control parameters, upgrades",
      "Keepers: maintain protocol, receive rewards",
      "Liquidity Providers: supply assets to pools/AMMs",
      "Strategies: generate yield",
      "Users: deposit, stake, lock BKD, claim rewards"
    ],
    "core_assets": [
      "BKD token",
      "Gauges",
      "InflationManager",
      "Liquidity pools",
      "Staker vaults",
      "VestedEscrow"
    ],
    "critical_interactions": [
      "LiquidityPool.deposit/depositFor",
      "LiquidityPool.redeem",
      "StakerVault.stake/stakeFor",
      "StakerVault.unstake/unstakeFor",
      "BkdLocker.lock/lockFor",
      "BkdLocker.prepareUnlock/executeUnlocks",
      "BkdLocker.claimFees",
      "KeeperGauge.reportFees/claimRewards",
      "LpGauge.claimRewards",
      "AmmGauge.stake/unstake/claimRewards",
      "InflationManager.executeKeeperPoolWeight/executeLpPoolWeight/executeAmmTokenWeight",
      "RewardHandler.burnFees",
      "Controller.addStakerVault/removePool"
    ],
    "key_assumptions": [
      {
        "id": "safeerc20-assumption",
        "source": "docs",
        "context_type": "best_practice",
        "details": "All token transfers use SafeERC20 to handle non-standard ERC20s and prevent token lockup."
      },
      {
        "id": "enumerableset-assumption",
        "source": "docs",
        "context_type": "best_practice",
        "details": "All EnumerableSet add/remove operations are checked with require() to avoid silent failures."
      },
      {
        "id": "upgradeability-assumption",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Upgradeable contracts use initializers, storage gaps, and strong RBAC for upgrade logic."
      }
    ],
    "invariants": [
      {
        "id": "invariant-1",
        "description": "After grantRole, the account must be recorded as a member of the role",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-2",
        "description": "After revokeRole, the account must no longer be a member of the role",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-3",
        "description": "getRoleMember must return a valid non-zero address for each index less than getRoleMemberCount",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-4",
        "description": "Each initialized address key must map to a non-zero configured address",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-5",
        "description": "safeGetPoolForToken returns zero address when pool not set",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-6",
        "description": "isPool returns true iff the token-to-pool mapping matches",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-7",
        "description": "totalLocked equals the sum of all user balances",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-8",
        "description": "totalLockedBoosted equals the sum of each balance scaled by its boost factor",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-9",
        "description": "Each user boost factor must lie between the configured start and max boosts",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-10",
        "description": "After depositFees, feeIntegral increases exactly by amount/totalLockedBoosted",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-11",
        "description": "Contract token balance must always cover staked balances",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-12",
        "description": "Sum of _poolTotalStaked and strategiesTotalStaked equals total of balances",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-13",
        "description": "Allowances never exceed the owner's staked balance",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-14",
        "description": "totalStaked equals the sum of per-user balances in the AMM gauge",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-15",
        "description": "ammStakedIntegral never decreases on poolCheckpoint",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-16",
        "description": "Only the configured minter address can call BkdToken.mint",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-17",
        "description": "burnToTarget returns exactly the LP tokens minted and transferred back to sender",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-18",
        "description": "totalKeeperPoolWeight equals the sum of all keeper weight configs",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-19",
        "description": "totalLpPoolWeight equals the sum of all lp-pool weight configs",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-20",
        "description": "totalAmmTokenWeight equals the sum of all amm-token weight configs",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-21",
        "description": "The Minter never mints more than allowed: totalMintedToNow <= totalAvailableToNow",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-22",
        "description": "getLpInflationRate is zero before inflation start and non-negative afterwards",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-23",
        "description": "After executing a prepared uint config, pending and deadline reset to zero",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-24",
        "description": "Total claimed per user never exceeds their initially locked amount",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-25",
        "description": "Revoking a user sends their unvested tokens to the treasury holding contract",
        "related_code": [],
        "origin": "doc"
      },
      {
        "id": "invariant-26",
        "description": "CvxMintAmount.getCvxMintAmount never exceeds crvEarned",
        "related_code": [],
        "origin": "doc"
      }
    ],
    "general_security_ctx": [
      {
        "id": "safeerc20-note",
        "source": "docs",
        "context_type": "best_practice",
        "details": "SafeERC20 is used to wrap all ERC20 operations, ensuring compatibility with non-standard tokens and preventing token lockup."
      },
      {
        "id": "upgradeability-note",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Upgradeable contracts use initializers, storage gaps, and strong RBAC for upgrade logic. Avoid storage collisions and always initialize implementations."
      },
      {
        "id": "enumerableset-note",
        "source": "docs",
        "context_type": "best_practice",
        "details": "EnumerableSet add/remove must be checked with require() to avoid silent failures."
      }
    ],
    "static_summary": null
  }
}