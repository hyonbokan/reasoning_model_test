{
  "analyzed_contracts": [
    {
      "id": "Authorization.sol",
      "file_name": "Authorization.sol",
      "core_purpose_raw": "Authorization provides a base for role-based access control, delegating role checks to an external IRoleManager contract. It is used as a parent for contracts that require authorization logic, ensuring that only accounts with the correct roles can execute sensitive functions.",
      "core_purpose_digest": "Base contract for role-based access control via external RoleManager.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IRoleManager"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GOVERNANCE"
      ],
      "key_state_vars": [
        "__roleManager"
      ],
      "key_functions": [
        "_roleManager"
      ],
      "external_dependencies": [
        "AuthorizationBase",
        "IRoleManager"
      ],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "RoleManager.sol",
      "file_name": "RoleManager.sol",
      "core_purpose_raw": "RoleManager manages roles and permissions for the protocol. It allows governance to grant and revoke roles, check role membership, and enumerate role members. It uses OpenZeppelin's EnumerableSet for efficient set operations and supports custom roles for pools, vaults, and governance. It is the central authority for access control in the protocol.",
      "core_purpose_digest": "Central contract for managing protocol roles and permissions.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IAddressProvider",
        "IRoleManager"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GAUGE_ZAP",
        "GOVERNANCE",
        "MAINTENANCE",
        "POOL",
        "POOL_FACTORY",
        "VAULT"
      ],
      "key_state_vars": [
        "_roleMembers",
        "_roles",
        "addressProvider"
      ],
      "key_functions": [
        "addGaugeZap",
        "addGovernor",
        "getRoleMember",
        "getRoleMemberCount",
        "grantRole",
        "hasRole",
        "removeGaugeZap",
        "renounceGovernance",
        "revokeRole"
      ],
      "external_dependencies": [
        "AddressProviderKeys",
        "EnumerableSet",
        "IAddressProvider",
        "Roles"
      ],
      "security_notes": [
        "Always check the return value of EnumerableSet.add/remove with require() to avoid silent failures.",
        "Role revocation for GOVERNANCE is prevented if only one governor remains."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "GOVERNANCE",
          "expected_setters": [
            "grantRole",
            "addGovernor",
            "renounceGovernance"
          ],
          "observed_setters": [
            "_grantRole",
            "_revokeRole"
          ],
          "note": "Tracks governance membership; cannot revoke last governor."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "AddressProvider.sol",
      "file_name": "AddressProvider.sol",
      "core_purpose_raw": "AddressProvider is a central registry for contract addresses and configuration keys in the protocol. It manages pools, vaults, staker vaults, fee handlers, and other key addresses. It supports upgradability of addresses via prepare/execute/reset patterns, and enforces immutability via freezing. It also manages whitelists and provides utility functions for querying and updating protocol components.",
      "core_purpose_digest": "Central registry for protocol contract addresses and configuration.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IGasBank",
        "IAddressProvider",
        "IStakerVault",
        "IOracleProvider"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GOVERNANCE",
        "POOL",
        "POOL_FACTORY"
      ],
      "key_state_vars": [
        "_actions",
        "_addressKeyMetas",
        "_stakerVaults",
        "_tokenToPools",
        "_vaults",
        "_whiteListedFeeHandlers"
      ],
      "key_functions": [
        "addPool",
        "addStakerVault",
        "executeAddress",
        "freezeAddress",
        "initializeAddress",
        "prepareAddress",
        "removePool",
        "resetAddress"
      ],
      "external_dependencies": [
        "AddressProviderKeys",
        "AddressProviderMeta",
        "AuthorizationBase",
        "EnumerableMapping",
        "EnumerableSet",
        "Preparable"
      ],
      "security_notes": [
        "Each initialized address key must map to a non-zero configured address.",
        "safeGetPoolForToken returns zero address when pool not set.",
        "isPool returns true iff the token-to-pool mapping matches."
      ],
      "config_params": [
        {
          "name": "ROLE_MANAGER",
          "storage_key": "AddressProviderKeys._ROLE_MANAGER_KEY",
          "load_site": {
            "id": "AddressProvider_getAddress_ROLE_MANAGER_KEY",
            "file": "AddressProvider.sol",
            "element_name": "getAddress",
            "unique_snippet": "return currentAddresses[key];"
          },
          "downstream_uses": [
            "AddressProvider._roleManager"
          ],
          "role": "address_key"
        },
        {
          "name": "TREASURY",
          "storage_key": "AddressProviderKeys._TREASURY_KEY",
          "load_site": {
            "id": "AddressProvider_getAddress_TREASURY_KEY",
            "file": "AddressProvider.sol",
            "element_name": "getAddress",
            "unique_snippet": "return currentAddresses[key];"
          },
          "downstream_uses": [],
          "role": "address_key"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "BkdLocker.sol",
      "file_name": "BkdLocker.sol",
      "core_purpose_raw": "BkdLocker allows users to lock governance tokens (BKD) for boosted rewards and voting power. It manages user balances, boost factors, and the distribution of reward tokens. It supports fee deposit, claiming, migration of reward tokens, and enforces withdrawal delays. It uses SafeERC20 for all token transfers to prevent issues with non-standard ERC20s.",
      "core_purpose_digest": "BKD token locker for boosted rewards, voting, and fee distribution.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IBkdLocker",
        "IMigrationContract"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GOVERNANCE"
      ],
      "key_state_vars": [
        "balances",
        "boostFactors",
        "govToken",
        "rewardToken",
        "totalLocked",
        "totalLockedBoosted"
      ],
      "key_functions": [
        "claimFees",
        "computeNewBoost",
        "depositFees",
        "executeUnlocks",
        "lock",
        "lockFor",
        "prepareUnlock",
        "userCheckpoint"
      ],
      "external_dependencies": [
        "Authorization",
        "Preparable",
        "SafeERC20",
        "ScaledMath"
      ],
      "security_notes": [
        "Uses SafeERC20 for all token transfers to handle non-standard ERC20s.",
        "Withdrawal delay is enforced for unlocking tokens."
      ],
      "config_params": [
        {
          "name": "startBoost",
          "storage_key": "_START_BOOST",
          "load_site": {
            "id": "BkdLocker_currentUInts256_START_BOOST",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_START_BOOST, startBoost);"
          },
          "downstream_uses": [
            "computeNewBoost"
          ],
          "role": "lower_bound"
        },
        {
          "name": "maxBoost",
          "storage_key": "_MAX_BOOST",
          "load_site": {
            "id": "BkdLocker_currentUInts256_MAX_BOOST",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_MAX_BOOST, maxBoost);"
          },
          "downstream_uses": [
            "computeNewBoost"
          ],
          "role": "upper_bound"
        },
        {
          "name": "increasePeriod",
          "storage_key": "_INCREASE_PERIOD",
          "load_site": {
            "id": "BkdLocker_currentUInts256_INCREASE_PERIOD",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_INCREASE_PERIOD, increasePeriod);"
          },
          "downstream_uses": [
            "computeNewBoost"
          ],
          "role": "misc"
        },
        {
          "name": "withdrawDelay",
          "storage_key": "_WITHDRAW_DELAY",
          "load_site": {
            "id": "BkdLocker_currentUInts256_WITHDRAW_DELAY",
            "file": "BkdLocker.sol",
            "element_name": "initialize",
            "unique_snippet": "_setConfig(_WITHDRAW_DELAY, withdrawDelay);"
          },
          "downstream_uses": [
            "prepareUnlock"
          ],
          "role": "misc"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [
        {
          "id": "BkdLocker_totalLocked",
          "name": "totalLocked",
          "must_increase_on": [
            "lockFor"
          ],
          "must_decrease_on": [
            "executeUnlocks"
          ]
        },
        {
          "id": "BkdLocker_totalLockedBoosted",
          "name": "totalLockedBoosted",
          "must_increase_on": [
            "_userCheckpoint"
          ],
          "must_decrease_on": [
            "_userCheckpoint"
          ]
        }
      ],
      "delay_guards": [
        {
          "id": "BkdLocker_withdrawDelay",
          "guard_fn": "prepareUnlock/executeUnlocks",
          "delay_type": "timestamp",
          "period": 0
        }
      ]
    },
    {
      "id": "Controller.sol",
      "file_name": "Controller.sol",
      "core_purpose_raw": "Controller coordinates protocol components, manages staker vaults and pools, and interacts with the InflationManager for reward distribution. It enforces governance and pool factory permissions, manages the minimum staked BKD required for keepers, and provides utility functions for gas estimation and protocol configuration.",
      "core_purpose_digest": "Coordinates protocol components, manages vaults/pools, and enforces keeper requirements.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IAction",
        "IAddressProvider",
        "IController",
        "IStakerVault",
        "ILiquidityPool",
        "IInflationManager"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "CONTROLLER",
        "GOVERNANCE",
        "POOL_FACTORY"
      ],
      "key_state_vars": [
        "addressProvider",
        "inflationManager"
      ],
      "key_functions": [
        "addStakerVault",
        "canKeeperExecuteAction",
        "executeKeeperRequiredStakedBKD",
        "getKeeperRequiredStakedBKD",
        "prepareKeeperRequiredStakedBKD",
        "removePool",
        "resetKeeperRequiredStakedBKD"
      ],
      "external_dependencies": [
        "AddressProviderHelpers",
        "Authorization",
        "Preparable"
      ],
      "security_notes": [
        "Only governance or pool factory can add staker vaults.",
        "Only governance can remove pools.",
        "Minimum staked BKD for keepers is configurable and enforced."
      ],
      "config_params": [
        {
          "name": "KEEPER_REQUIRED_STAKED_BKD",
          "storage_key": "_KEEPER_REQUIRED_STAKED_BKD",
          "load_site": {
            "id": "Controller_currentUInts256_KEEPER_REQUIRED_STAKED_BKD",
            "file": "Controller.sol",
            "element_name": "getKeeperRequiredStakedBKD",
            "unique_snippet": "return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];"
          },
          "downstream_uses": [
            "canKeeperExecuteAction"
          ],
          "role": "lower_bound"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "RewardHandler",
      "file_name": "RewardHandler.sol",
      "core_purpose_raw": "Handles the burning of accumulated fees and pays them out to the BKD locker. It collects fees from various pools, converts them to a target LP token, and deposits the resulting tokens into the BKD locker contract.",
      "core_purpose_digest": "Burns fees from pools and deposits rewards to BKD locker.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IFeeBurner",
        "IBkdLocker",
        "IController",
        "IAddressProvider",
        "IRewardHandler"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "addressProvider",
        "controller"
      ],
      "key_state_vars": [
        "addressProvider",
        "controller"
      ],
      "key_functions": [
        "_approve",
        "burnFees"
      ],
      "external_dependencies": [
        "../interfaces/IAddressProvider.sol",
        "../interfaces/IBkdLocker.sol",
        "../interfaces/IController.sol",
        "../interfaces/IFeeBurner.sol",
        "../interfaces/IRewardHandler.sol",
        "../libraries/AddressProviderHelpers.sol",
        "../libraries/UncheckedMath.sol",
        "./access/Authorization.sol",
        "./utils/Preparable.sol",
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      ],
      "security_notes": [
        "Approves infinite allowance for feeBurner and bkdLocker.",
        "Relies on external contracts for fee burning and reward distribution."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "StakerVault",
      "file_name": "StakerVault.sol",
      "core_purpose_raw": "Handles staked tokens from Backd pools. Not ERC-20 compliant. Allows staking, unstaking, transferring, and tracking of staked balances, including those locked by actions. Integrates with LP gauge and inflation manager for rewards. Pausable for emergency situations.",
      "core_purpose_digest": "Manages staking, unstaking, and tracking of Backd pool tokens (not ERC-20).",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IStakerVault",
        "IAddressProvider",
        "IVault",
        "IRewardsGauge",
        "IInflationManager",
        "ILiquidityPool",
        "ILpGauge",
        "IERC20Full"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "addressProvider",
        "controller",
        "governance",
        "inflationManager"
      ],
      "key_state_vars": [
        "_allowances",
        "_poolTotalStaked",
        "actionLockedBalances",
        "addressProvider",
        "balances",
        "controller",
        "inflationManager",
        "strategies",
        "strategiesTotalStaked",
        "token"
      ],
      "key_functions": [
        "addStrategy",
        "approve",
        "decreaseActionLockedBalance",
        "executeLpGauge",
        "increaseActionLockedBalance",
        "initialize",
        "initializeLpGauge",
        "poolCheckpoint",
        "prepareLpGauge",
        "stake",
        "stakeFor",
        "transfer",
        "transferFrom",
        "unstake",
        "unstakeFor"
      ],
      "external_dependencies": [
        "../interfaces/IAddressProvider.sol",
        "../interfaces/IERC20Full.sol",
        "../interfaces/IStakerVault.sol",
        "../interfaces/IVault.sol",
        "../interfaces/pool/ILiquidityPool.sol",
        "../interfaces/tokenomics/IInflationManager.sol",
        "../interfaces/tokenomics/ILpGauge.sol",
        "../interfaces/tokenomics/IRewardsGauge.sol",
        "../libraries/AddressProviderHelpers.sol",
        "../libraries/Errors.sol",
        "../libraries/ScaledMath.sol",
        "../libraries/UncheckedMath.sol",
        "./Controller.sol",
        "./access/Authorization.sol",
        "./pool/LiquidityPool.sol",
        "./utils/Pausable.sol",
        "./utils/Preparable.sol",
        "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      ],
      "security_notes": [
        "Not ERC-20 compliant; should not be integrated with protocols expecting ERC-20.",
        "Pausable: only withdraw/unstake allowed when paused.",
        "Allowance logic for transferFrom and unstakeFor.",
        "Relies on external contracts for LP gauge and inflation management."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "StakerVault-scaledMath-1",
          "file": "StakerVault.sol",
          "element_name": "stakeFor",
          "op": "div",
          "lhs": "amount",
          "rhs": "scale",
          "scale": 1,
          "comment": null
        }
      ],
      "aggregate_trackers": [
        {
          "id": "StakerVault-poolTotalStaked",
          "name": "_poolTotalStaked",
          "must_increase_on": [
            "stakeFor"
          ],
          "must_decrease_on": [
            "unstakeFor"
          ]
        },
        {
          "id": "StakerVault-strategiesTotalStaked",
          "name": "strategiesTotalStaked",
          "must_increase_on": [
            "stakeFor"
          ],
          "must_decrease_on": [
            "unstakeFor"
          ]
        }
      ],
      "delay_guards": []
    },
    {
      "id": "AmmGauge",
      "file_name": "AmmGauge.sol",
      "core_purpose_raw": "Handles staking and reward distribution for AMM tokens. Tracks balances, staking integrals, and allows users to claim rewards. Can be killed (shut down) by the inflation manager, after which no new rewards accrue but existing can be claimed.",
      "core_purpose_digest": "Manages staking and reward distribution for AMM tokens.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IController",
        "IAmmGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "controller",
        "inflationManager"
      ],
      "key_state_vars": [
        "ammLastUpdated",
        "ammStakedIntegral",
        "ammToken",
        "balances",
        "controller",
        "killed",
        "perUserShare",
        "perUserStakedIntegral",
        "totalStaked"
      ],
      "key_functions": [
        "_userCheckpoint",
        "claimRewards",
        "kill",
        "poolCheckpoint",
        "stake",
        "stakeFor",
        "unstake",
        "unstakeFor"
      ],
      "external_dependencies": [
        "../../interfaces/IController.sol",
        "../../interfaces/tokenomics/IAmmGauge.sol",
        "../../libraries/AddressProviderHelpers.sol",
        "../../libraries/Errors.sol",
        "../../libraries/ScaledMath.sol",
        "../access/Authorization.sol",
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      ],
      "security_notes": [
        "Only inflationManager can kill the gauge.",
        "Accrued rewards can be claimed after shutdown.",
        "Relies on external contracts for inflation rate and minting."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "killed",
          "expected_setters": [
            "kill"
          ],
          "observed_setters": [
            "kill"
          ],
          "note": "Disables new reward accrual when true."
        }
      ],
      "math_scale_hints": [
        {
          "id": "AmmGauge-scaledMath-1",
          "file": "AmmGauge.sol",
          "element_name": "claimableRewards",
          "op": "div",
          "lhs": "(controller.inflationManager().getAmmRateForToken(ammToken) * (block.timestamp - uint256(ammLastUpdated)))",
          "rhs": "totalStaked",
          "scale": 1,
          "comment": null
        }
      ],
      "aggregate_trackers": [
        {
          "id": "AmmGauge-totalStaked",
          "name": "totalStaked",
          "must_increase_on": [
            "stakeFor"
          ],
          "must_decrease_on": [
            "unstakeFor"
          ]
        }
      ],
      "delay_guards": []
    },
    {
      "id": "BkdToken",
      "file_name": "BkdToken.sol",
      "core_purpose_raw": "ERC20 token contract for BKD. Only the designated minter can mint new tokens. Used for reward distribution and protocol incentives.",
      "core_purpose_digest": "ERC20 token for BKD, mintable only by minter.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IBkdToken"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "minter"
      ],
      "key_state_vars": [
        "minter"
      ],
      "key_functions": [
        "mint"
      ],
      "external_dependencies": [
        "../../interfaces/tokenomics/IBkdToken.sol",
        "../../libraries/Errors.sol",
        "../../libraries/ScaledMath.sol",
        "@openzeppelin/contracts/token/ERC20/ERC20.sol"
      ],
      "security_notes": [
        "Only minter can mint new tokens."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "FeeBurner",
      "file_name": "FeeBurner.sol",
      "core_purpose_raw": "Converts all of the caller's Backd LP Tokens to a single target Backd LP Token. Burns pool LP tokens for underlying, swaps all underlyings for the target pool underlying, and deposits into the target pool to get the target LP token. Handles both ETH and ERC20 tokens.",
      "core_purpose_digest": "Burns and swaps LP tokens to a target LP token for the caller.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IFeeBurner",
        "ILiquidityPool",
        "ISwapperRouter",
        "IAddressProvider"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "addressProvider"
      ],
      "key_state_vars": [
        "_addressProvider"
      ],
      "key_functions": [
        "_approve",
        "_depositInPool",
        "_swapperRouter",
        "burnToTarget"
      ],
      "external_dependencies": [
        "../../interfaces/IAddressProvider.sol",
        "../../interfaces/IFeeBurner.sol",
        "../../interfaces/ISwapperRouter.sol",
        "../../interfaces/pool/ILiquidityPool.sol",
        "../../libraries/AddressProviderHelpers.sol",
        "../../libraries/Errors.sol",
        "../../libraries/UncheckedMath.sol",
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      ],
      "security_notes": [
        "Handles both ETH and ERC20 tokens.",
        "Approves infinite allowance for swapperRouter and pool.",
        "Relies on external contracts for swaps and deposits."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "InflationManager",
      "file_name": "InflationManager.sol",
      "core_purpose_raw": "Manages the distribution and configuration of inflation rewards across different pools (keepers, LPs, AMMs) in a DeFi protocol. Handles the registration and removal of gauges, weight updates (with time delays), and the minting of rewards via a Minter contract. Enforces role-based access control for sensitive operations and supports batch operations for efficiency. Integrates with external address providers and ensures that inflation weights are updated securely and transparently.",
      "core_purpose_digest": "Manages inflation rewards and gauge weights for pools, enforcing role-based access and secure updates.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IStakerVault",
        "IInflationManager",
        "IKeeperGauge",
        "IAmmGauge"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "Controller",
        "Governance",
        "Inflation Manager"
      ],
      "key_state_vars": [
        "_ammGauges",
        "_keeperGauges",
        "gauges",
        "minter",
        "totalAmmTokenWeight",
        "totalKeeperPoolWeight",
        "totalLpPoolWeight",
        "weightBasedKeeperDistributionDeactivated"
      ],
      "key_functions": [
        "addGaugeForVault",
        "advanceKeeperGaugeEpoch",
        "batchExecuteAmmTokenWeights",
        "batchExecuteKeeperPoolWeights",
        "batchExecuteLpPoolWeights",
        "batchPrepareAmmTokenWeights",
        "batchPrepareKeeperPoolWeights",
        "batchPrepareLpPoolWeights",
        "checkpointAllGauges",
        "deactivateWeightBasedKeeperDistribution",
        "executeAmmTokenWeight",
        "executeKeeperPoolWeight",
        "executeLpPoolWeight",
        "getAllAmmGauges",
        "getAmmRateForToken",
        "getKeeperRateForPool",
        "getLpRateForStakerVault",
        "mintRewards",
        "prepareAmmTokenWeight",
        "prepareKeeperPoolWeight",
        "prepareLpPoolWeight",
        "removeAmmGauge",
        "removeKeeperGauge",
        "setAmmGauge",
        "setKeeperGauge",
        "setMinter"
      ],
      "external_dependencies": [
        "IAddressProvider",
        "IAmmGauge",
        "IKeeperGauge",
        "IStakerVault",
        "Minter"
      ],
      "security_notes": [
        "All weight updates are subject to time delays unless called by the INFLATION_MANAGER role.",
        "Role-based access enforced for all sensitive operations.",
        "Gauges are not deleted from the map immediately to allow claiming of remaining balances.",
        "Minting is only possible if the minter address is set and inflation is started."
      ],
      "config_params": [
        {
          "name": "keeperWeight",
          "storage_key": "_KEEPER_WEIGHT_KEY",
          "load_site": {
            "id": "InflationManager_keeperWeight",
            "file": "InflationManager.sol",
            "element_name": null,
            "unique_snippet": "bytes32 internal constant _KEEPER_WEIGHT_KEY = \"keeperWeight\";"
          },
          "downstream_uses": [],
          "role": "misc"
        },
        {
          "name": "ammWeight",
          "storage_key": "_AMM_WEIGHT_KEY",
          "load_site": {
            "id": "InflationManager_ammWeight",
            "file": "InflationManager.sol",
            "element_name": null,
            "unique_snippet": "bytes32 internal constant _AMM_WEIGHT_KEY = \"ammWeight\";"
          },
          "downstream_uses": [],
          "role": "misc"
        },
        {
          "name": "lpWeight",
          "storage_key": "_LP_WEIGHT_KEY",
          "load_site": {
            "id": "InflationManager_lpWeight",
            "file": "InflationManager.sol",
            "element_name": null,
            "unique_snippet": "bytes32 internal constant _LP_WEIGHT_KEY = \"lpWeight\";"
          },
          "downstream_uses": [],
          "role": "misc"
        }
      ],
      "flag_trackers": [
        {
          "name": "weightBasedKeeperDistributionDeactivated",
          "expected_setters": [
            "deactivateWeightBasedKeeperDistribution"
          ],
          "observed_setters": [
            "deactivateWeightBasedKeeperDistribution"
          ],
          "note": "Disables weight-based keeper distribution; only settable once."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [
        {
          "id": "totalKeeperPoolWeight",
          "name": "totalKeeperPoolWeight",
          "must_increase_on": [
            "executeKeeperPoolWeight",
            "batchExecuteKeeperPoolWeights"
          ],
          "must_decrease_on": [
            "executeKeeperPoolWeight",
            "batchExecuteKeeperPoolWeights"
          ]
        },
        {
          "id": "totalLpPoolWeight",
          "name": "totalLpPoolWeight",
          "must_increase_on": [
            "executeLpPoolWeight",
            "batchExecuteLpPoolWeights"
          ],
          "must_decrease_on": [
            "executeLpPoolWeight",
            "batchExecuteLpPoolWeights"
          ]
        },
        {
          "id": "totalAmmTokenWeight",
          "name": "totalAmmTokenWeight",
          "must_increase_on": [
            "executeAmmTokenWeight",
            "batchExecuteAmmTokenWeights"
          ],
          "must_decrease_on": [
            "executeAmmTokenWeight",
            "batchExecuteAmmTokenWeights"
          ]
        }
      ],
      "delay_guards": [
        {
          "id": "keeperPoolWeightDelay",
          "guard_fn": "prepareKeeperPoolWeight/executeKeeperPoolWeight",
          "delay_type": "timestamp",
          "period": 0
        },
        {
          "id": "lpPoolWeightDelay",
          "guard_fn": "prepareLpPoolWeight/executeLpPoolWeight",
          "delay_type": "timestamp",
          "period": 0
        },
        {
          "id": "ammTokenWeightDelay",
          "guard_fn": "prepareAmmTokenWeight/executeAmmTokenWeight",
          "delay_type": "timestamp",
          "period": 0
        }
      ]
    },
    {
      "id": "KeeperGauge",
      "file_name": "KeeperGauge.sol",
      "core_purpose_raw": "Tracks and distributes inflation rewards to keepers based on fees generated in a given pool. Maintains per-epoch accounting for each keeper, allows reporting of fees, advances epochs, and enables keepers to claim rewards proportional to their contribution. Can be killed by the InflationManager, after which rewards can still be claimed but no new accrual occurs.",
      "core_purpose_digest": "Distributes inflation rewards to keepers per pool, based on fees generated and epochs.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IKeeperGauge",
        "IController"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GaugeZap",
        "InflationManager"
      ],
      "key_state_vars": [
        "controller",
        "epoch",
        "keeperRecords",
        "killed",
        "lastUpdated",
        "perPeriodTotalFees",
        "perPeriodTotalInflation",
        "pool"
      ],
      "key_functions": [
        "advanceEpoch",
        "claimRewards",
        "claimableRewards",
        "kill",
        "poolCheckpoint",
        "reportFees"
      ],
      "external_dependencies": [
        "IController",
        "IKeeperGauge"
      ],
      "security_notes": [
        "Only the InflationManager can kill the gauge or advance epochs.",
        "Claiming rewards requires either the beneficiary or GAUGE_ZAP role.",
        "Rewards are only claimable if accrued; zero-claim is not allowed."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "killed",
          "expected_setters": [
            "kill"
          ],
          "observed_setters": [
            "kill"
          ],
          "note": "Stops new accrual but allows claiming of already accrued rewards."
        }
      ],
      "math_scale_hints": [
        {
          "id": "KeeperGauge_scaledDiv",
          "file": "KeeperGauge.sol",
          "element_name": "_calcTotalClaimable",
          "op": "div",
          "lhs": "keeperRecords[beneficiary].feesInPeriod[i]",
          "rhs": "perPeriodTotalFees[i]",
          "scale": 1,
          "comment": "Scaled division for proportional reward calculation."
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "LpGauge",
      "file_name": "LpGauge.sol",
      "core_purpose_raw": "Distributes inflation rewards to LP stakers in a pool. Tracks per-user and per-pool integrals to ensure fair reward distribution based on staked balances and time. Integrates with a StakerVault and the InflationManager for rate queries and reward minting. Allows users to claim rewards and checkpoints their statistics.",
      "core_purpose_digest": "Distributes inflation rewards to LP stakers based on pool and user integrals.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "ILpGauge",
        "IRewardsGauge",
        "IStakerVault",
        "IController"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "GaugeZap"
      ],
      "key_state_vars": [
        "controller",
        "inflationManager",
        "perUserShare",
        "perUserStakedIntegral",
        "poolLastUpdate",
        "poolStakedIntegral",
        "stakerVault"
      ],
      "key_functions": [
        "claimRewards",
        "claimableRewards",
        "poolCheckpoint",
        "userCheckpoint"
      ],
      "external_dependencies": [
        "IController",
        "IInflationManager",
        "IStakerVault"
      ],
      "security_notes": [
        "Claiming rewards requires either the beneficiary or GAUGE_ZAP role.",
        "Checkpointing ensures up-to-date reward calculations."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [
        {
          "id": "LpGauge_scaledDiv",
          "file": "LpGauge.sol",
          "element_name": "_poolCheckpoint",
          "op": "div",
          "lhs": "(currentRate * (block.timestamp - poolLastUpdate))",
          "rhs": "poolTotalStaked",
          "scale": 1,
          "comment": "Scaled division for per-pool reward integral."
        }
      ],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "Minter",
      "file_name": "Minter.sol",
      "core_purpose_raw": "Handles the minting of BKD tokens according to a piecewise linear inflation schedule, with separate rates and decay for LPs, keepers, and AMMs. Enforces a cap on non-inflationary token distribution. Only the controller or governance can mint tokens, and inflation can only start once. Ensures that total minted tokens do not exceed the available inflation supply.",
      "core_purpose_digest": "Mints BKD tokens per inflation schedule, enforcing caps and role-based access.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IMinter",
        "IController",
        "IBkdToken"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "Controller",
        "Governance"
      ],
      "key_state_vars": [
        "annualInflationDecayAmm",
        "annualInflationDecayKeeper",
        "annualInflationDecayLp",
        "controller",
        "currentInflationAmountAmm",
        "currentInflationAmountKeeper",
        "currentInflationAmountLp",
        "currentTotalInflation",
        "initialAnnualInflationRateAmm",
        "initialAnnualInflationRateKeeper",
        "initialAnnualInflationRateLp",
        "initialPeriodAmmInflation",
        "initialPeriodEnded",
        "initialPeriodKeeperInflation",
        "issuedNonInflationSupply",
        "lastEvent",
        "lastInflationDecay",
        "nonInflationDistribution",
        "token",
        "totalAvailableToNow",
        "totalMintedToNow"
      ],
      "key_functions": [
        "executeInflationRateUpdate",
        "getAmmInflationRate",
        "getKeeperInflationRate",
        "getLpInflationRate",
        "mint",
        "mintNonInflationTokens",
        "setToken",
        "startInflation"
      ],
      "external_dependencies": [
        "BkdToken",
        "IController"
      ],
      "security_notes": [
        "Minting is only possible if called by the controller or governance.",
        "Total minted tokens cannot exceed the available inflation supply.",
        "Non-inflationary minting is capped by nonInflationDistribution."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "initialPeriodEnded",
          "expected_setters": [
            "_executeInflationRateUpdate"
          ],
          "observed_setters": [
            "_executeInflationRateUpdate"
          ],
          "note": "Tracks whether the initial period for inflation has ended."
        }
      ],
      "math_scale_hints": [
        {
          "id": "Minter_scaledMul",
          "file": "Minter.sol",
          "element_name": "_executeInflationRateUpdate",
          "op": "mul",
          "lhs": "currentInflationAmountLp",
          "rhs": "annualInflationDecayLp",
          "scale": 1,
          "comment": "Scaled multiplication for decaying inflation."
        }
      ],
      "aggregate_trackers": [
        {
          "id": "totalAvailableToNow",
          "name": "totalAvailableToNow",
          "must_increase_on": [
            "_executeInflationRateUpdate",
            "_mint"
          ],
          "must_decrease_on": []
        },
        {
          "id": "totalMintedToNow",
          "name": "totalMintedToNow",
          "must_increase_on": [
            "_mint"
          ],
          "must_decrease_on": []
        }
      ],
      "delay_guards": []
    },
    {
      "id": "VestedEscrow",
      "file_name": "VestedEscrow.sol",
      "core_purpose_raw": "Manages the vesting and claiming of reward tokens for users over a linear schedule. Allows an admin or fundAdmin to allocate rewards to users, which are then claimable over time. Users can claim vested tokens, and the contract supports initialization of the unallocated supply and tracking of claimed/locked balances. Inspired by Convex Finance's Vested Escrow.",
      "core_purpose_digest": "Manages linear vesting and claiming of reward tokens for users.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IVestedEscrow"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "Admin",
        "FundAdmin"
      ],
      "key_state_vars": [
        "admin",
        "endTime",
        "fundAdmin",
        "holdingContract",
        "initialLocked",
        "initialLockedSupply",
        "initializedSupply",
        "rewardToken",
        "startTime",
        "totalClaimed",
        "totalTime",
        "unallocatedSupply"
      ],
      "key_functions": [
        "balanceOf",
        "claim",
        "fund",
        "initializeUnallocatedSupply",
        "lockedOf",
        "lockedSupply",
        "setAdmin",
        "setFundAdmin",
        "vestedOf",
        "vestedSupply"
      ],
      "external_dependencies": [
        "IERC20"
      ],
      "security_notes": [
        "Only admin or fundAdmin can allocate funds.",
        "Unallocated supply must be initialized before funding.",
        "Claiming is non-reentrant and only possible for vested tokens."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "initializedSupply",
          "expected_setters": [
            "initializeUnallocatedSupply"
          ],
          "observed_setters": [
            "initializeUnallocatedSupply"
          ],
          "note": "Ensures supply is only initialized once."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "VestedEscrowRevocable.sol",
      "file_name": "VestedEscrowRevocable.sol",
      "core_purpose_raw": "Rewrite of Convex Finance's Vested Escrow. Changes: remove safe math (default from Solidity >=0.8), remove claim and stake logic, remove safeTransferFrom logic and add support for 'airdropped' reward token, add revoke logic to allow admin to stop vesting for a recipient. Allows admin to revoke vesting for a recipient, transferring unvested tokens to treasury.",
      "core_purpose_digest": "Vesting contract with admin revocation, treasury recovery, and airdropped token support.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IVestedEscrowRevocable"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "admin",
        "recipient",
        "treasury"
      ],
      "key_state_vars": [
        "_vestedBefore",
        "holdingContract",
        "initialLocked",
        "revokedTime",
        "totalClaimed",
        "treasury"
      ],
      "key_functions": [
        "balanceOf",
        "claim",
        "lockedOf",
        "revoke",
        "vestedOf"
      ],
      "external_dependencies": [
        "../../interfaces/tokenomics/IVestedEscrowRevocable.sol",
        "../../libraries/Errors.sol",
        "./VestedEscrow.sol",
        "@openzeppelin/contracts/security/ReentrancyGuard.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol",
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
        "@openzeppelin/contracts/utils/math/Math.sol"
      ],
      "security_notes": [
        "Admin can revoke vesting for any recipient except treasury.",
        "ReentrancyGuard is used for claim function.",
        "Treasury cannot be revoked."
      ],
      "config_params": [],
      "flag_trackers": [
        {
          "name": "revokedTime",
          "expected_setters": [
            "revoke"
          ],
          "observed_setters": [
            "revoke"
          ],
          "note": "Tracks if/when a recipient's vesting is revoked."
        }
      ],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "CvxMintAmount.sol",
      "file_name": "CvxMintAmount.sol",
      "core_purpose_raw": "Abstract contract to calculate the amount of CVX tokens to mint based on CRV earned, using a cliff-based emission schedule. Ensures max supply is not exceeded and emission rate decreases as supply increases.",
      "core_purpose_digest": "Calculates CVX mint amount from CRV earned using cliff-based emission.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [
        "_CLIFF_COUNT",
        "_CLIFF_SIZE",
        "_CVX_TOKEN",
        "_MAX_SUPPLY"
      ],
      "key_functions": [
        "getCvxMintAmount"
      ],
      "external_dependencies": [
        "../../libraries/UncheckedMath.sol",
        "@openzeppelin/contracts/token/ERC20/IERC20.sol"
      ],
      "security_notes": [
        "Ensures CVX emission does not exceed max supply.",
        "Uses unchecked math for some operations."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [
        {
          "id": "cvxTotalSupply",
          "name": "CVX Total Supply",
          "must_increase_on": [],
          "must_decrease_on": []
        }
      ],
      "delay_guards": []
    },
    {
      "id": "Preparable.sol",
      "file_name": "Preparable.sol",
      "core_purpose_raw": "Implements base logic for a two-phase commit for configuration changes. Allows preparing and executing address and uint256 config updates with a minimum enforced delay. No access control is implemented in this contract; callers must enforce it.",
      "core_purpose_digest": "Two-phase commit for config changes with enforced delay, no access control.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPreparable"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [
        "_MIN_DELAY",
        "currentAddresses",
        "currentUInts256",
        "deadlines",
        "pendingAddresses",
        "pendingUInts256"
      ],
      "key_functions": [
        "_executeAddress",
        "_executeUInt256",
        "_prepare",
        "_resetAddressConfig",
        "_resetUInt256Config",
        "_setConfig"
      ],
      "external_dependencies": [
        "../../interfaces/IPreparable.sol",
        "../../libraries/Errors.sol"
      ],
      "security_notes": [
        "No access control; must be enforced by caller.",
        "Minimum delay of 3 days for config changes.",
        "Deadlines must be unique per key."
      ],
      "config_params": [
        {
          "name": "pendingUInts256",
          "storage_key": "bytes32 key",
          "load_site": {
            "id": "Preparable.sol:pendingUInts256",
            "file": "Preparable.sol",
            "element_name": "pendingUInts256",
            "unique_snippet": "mapping(bytes32 => uint256) public pendingUInts256;"
          },
          "downstream_uses": [
            "Preparable.sol:_executeUInt256"
          ],
          "role": "misc"
        },
        {
          "name": "pendingAddresses",
          "storage_key": "bytes32 key",
          "load_site": {
            "id": "Preparable.sol:pendingAddresses",
            "file": "Preparable.sol",
            "element_name": "pendingAddresses",
            "unique_snippet": "mapping(bytes32 => address) public pendingAddresses;"
          },
          "downstream_uses": [
            "Preparable.sol:_executeAddress"
          ],
          "role": "misc"
        },
        {
          "name": "deadlines",
          "storage_key": "bytes32 key",
          "load_site": {
            "id": "Preparable.sol:deadlines",
            "file": "Preparable.sol",
            "element_name": "deadlines",
            "unique_snippet": "mapping(bytes32 => uint256) public deadlines;"
          },
          "downstream_uses": [
            "Preparable.sol:_prepareDeadline",
            "Preparable.sol:_executeDeadline"
          ],
          "role": "lower_bound"
        }
      ],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": [
        {
          "id": "Preparable.sol:config_delay",
          "guard_fn": "_prepareDeadline",
          "delay_type": "timestamp",
          "period": 259200
        }
      ]
    },
    {
      "id": "PoolMigrationZap.sol",
      "file_name": "PoolMigrationZap.sol",
      "core_purpose_raw": "Zap contract to assist in migration from V1 Backd Pools to new Backd Pools. Maps underlyings to new pools, allows users to migrate all or individual pool balances, ensuring no withdrawal fee and correct token approvals.",
      "core_purpose_digest": "Assists users in migrating LP tokens from old to new Backd pools.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [
        "IPoolMigrationZap",
        "IAddressProvider",
        "ILiquidityPool"
      ],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "user"
      ],
      "key_state_vars": [
        "_underlyingNewPools"
      ],
      "key_functions": [
        "migrate",
        "migrateAll"
      ],
      "external_dependencies": [
        "../../interfaces/IAddressProvider.sol",
        "../../interfaces/pool/ILiquidityPool.sol",
        "../../interfaces/zaps/IPoolMigrationZap.sol",
        "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"
      ],
      "security_notes": [
        "Requires user to have LP token balance in old pool.",
        "Requires withdrawal fee to be zero.",
        "Approves max allowance for new pools."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ICurveSwap.sol",
      "file_name": "ICurveSwap.sol",
      "core_purpose_raw": "Interface for Curve swap contracts, supporting various liquidity and swap operations, including adding/removing liquidity, exchanging tokens, and querying pool parameters.",
      "core_purpose_digest": "Interface for Curve pool swaps and liquidity operations.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "add_liquidity",
        "calc_token_amount",
        "calc_withdraw_one_coin",
        "coins",
        "exchange",
        "get_dy",
        "get_virtual_price",
        "remove_liquidity",
        "remove_liquidity_imbalance",
        "remove_liquidity_one_coin"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "ICvxLocker.sol",
      "file_name": "ICvxLocker.sol",
      "core_purpose_raw": "Defines the interface for a CvxLocker contract, which allows users to lock tokens, earn rewards, and manage boost parameters. The interface exposes functions for locking, unlocking, processing expired locks, claiming rewards, and setting boost parameters. It also provides view functions for querying balances and reward data, and emits events for staking, withdrawals, rewards, and recovery.",
      "core_purpose_digest": "Interface for token locking, reward claiming, and boost management in a CvxLocker contract.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.10",
      "identified_roles": [
        "boost manager",
        "locker",
        "reward claimer"
      ],
      "key_state_vars": [],
      "key_functions": [
        "balanceOf",
        "checkpointEpoch",
        "getReward",
        "lock",
        "lockedBalanceOf",
        "maximumBoostPayment",
        "processExpiredLocks",
        "rewardData",
        "setBoost",
        "withdrawExpiredLocksTo"
      ],
      "external_dependencies": [],
      "security_notes": [],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    },
    {
      "id": "UncheckedMath.sol",
      "file_name": "UncheckedMath.sol",
      "core_purpose_raw": "Provides a library of arithmetic functions (increment, addition, subtraction) that use Solidity's unchecked block to skip overflow checks for gas efficiency. Intended for use in contexts where overflow is either impossible or already checked elsewhere.",
      "core_purpose_digest": "Library for unchecked arithmetic (inc, add, sub) to save gas when overflows are impossible.",
      "upgradeability_pattern": null,
      "consumed_interfaces": [],
      "compiler_version": "0.8.10",
      "identified_roles": [],
      "key_state_vars": [],
      "key_functions": [
        "uncheckedAdd",
        "uncheckedInc",
        "uncheckedSub"
      ],
      "external_dependencies": [],
      "security_notes": [
        "UncheckedMath functions skip overflow checks; use only when overflows are impossible or checked elsewhere."
      ],
      "config_params": [],
      "flag_trackers": [],
      "math_scale_hints": [],
      "aggregate_trackers": [],
      "delay_guards": []
    }
  ],
  "project_context": {
    "overall_goal_raw": "The Backd Protocol is a decentralized finance (DeFi) platform that provides a comprehensive ecosystem for liquidity provision, staking, and yield generation. The protocol is built around several key components: Liquidity Pools, Staker Vaults, Vaults and Strategies, BKD Token, and Inflation Management. It implements a sophisticated tokenomics and rewards system, role-based governance, and robust fee management.",
    "overall_goal_digest": "DeFi protocol for liquidity, staking, yield, and BKD tokenomics with robust governance.",
    "actors_capabilities": [
      "Governance: controls parameters, upgrades, and permissions",
      "Keepers: maintain protocol operations, receive rewards",
      "Liquidity Providers: supply assets to pools and AMMs",
      "Strategies: generate yield on assets",
      "Users: deposit assets, stake LP tokens, lock BKD, claim rewards"
    ],
    "core_assets": [
      "BKD token",
      "Governance contracts",
      "Liquidity pool tokens",
      "Staker vaults"
    ],
    "critical_interactions": [
      "LiquidityPool.deposit/depositFor: asset deposits",
      "LiquidityPool.redeem: asset withdrawals",
      "StakerVault.stake/stakeFor: staking LP tokens",
      "StakerVault.unstake/unstakeFor: unstaking LP tokens",
      "BkdLocker.lock/lockFor: lock BKD for rewards",
      "BkdLocker.prepareUnlock/executeUnlocks: manage BKD unlocking",
      "BkdLocker.claimFees: claim accumulated fees",
      "KeeperGauge.reportFees/claimRewards: keeper rewards",
      "LpGauge.claimRewards: LP staker rewards",
      "AmmGauge.stake/unstake/claimRewards: AMM staking/rewards",
      "InflationManager.executeKeeperPoolWeight/executeLpPoolWeight/executeAmmTokenWeight: update inflation weights",
      "RewardHandler.burnFees: burn/distribute fees",
      "Controller.addStakerVault/removePool: manage protocol components"
    ],
    "key_assumptions": [
      {
        "id": "SafeERC20_usage",
        "source": "docs",
        "context_type": "best_practice",
        "details": "SafeERC20 is used for all token transfers to handle non-standard ERC20s and prevent token lockup."
      },
      {
        "id": "EnumerableSet_require_check",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Always check the return value of EnumerableSet.add/remove with require() to avoid silent failures."
      },
      {
        "id": "Upgradeable_contracts_initializer",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Upgradeable contracts must use initializer functions and never constructors for state initialization."
      }
    ],
    "invariants": [
      {
        "id": "RoleManager_grantRole_invariant",
        "description": "After grantRole, the account must be recorded as a member of the role",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "RoleManager_revokeRole_invariant",
        "description": "After revokeRole, the account must no longer be a member of the role",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "RoleManager_getRoleMember_invariant",
        "description": "getRoleMember must return a valid non-zero address for each index less than getRoleMemberCount",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "AddressProvider_initializeAddress_invariant",
        "description": "Each initialized address key must map to a non-zero configured address",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "AddressProvider_safeGetPoolForToken_invariant",
        "description": "safeGetPoolForToken returns zero address when pool not set",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "AddressProvider_isPool_invariant",
        "description": "isPool returns true iff the token-to-pool mapping matches",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "BkdLocker_totalLocked_invariant",
        "description": "totalLocked equals the sum of all user balances",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "BkdLocker_totalLockedBoosted_invariant",
        "description": "totalLockedBoosted equals the sum of each balance scaled by its boost factor",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "BkdLocker_boost_factor_bounds_invariant",
        "description": "Each user boost factor must lie between the configured start and max boosts",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "BkdLocker_depositFees_integral_invariant",
        "description": "After depositFees, feeIntegral increases exactly by amount/totalLockedBoosted",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "invariant-1",
        "description": "Only the minter can mint new BKD tokens.",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "invariant-2",
        "description": "Only inflationManager can kill the AmmGauge.",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "invariant-3",
        "description": "StakerVault balances cannot be negative and must be updated correctly on stake/unstake/transfer.",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "invariant_no_overmint",
        "description": "totalMintedToNow must never exceed totalAvailableToNow in Minter.",
        "related_code": [
          "Minter._mint"
        ],
        "origin": "check"
      },
      {
        "id": "invariant_single_init_supply",
        "description": "initializedSupply in VestedEscrow can only be set once.",
        "related_code": [
          "VestedEscrow.initializeUnallocatedSupply"
        ],
        "origin": "check"
      },
      {
        "id": "cvx-supply-cap",
        "description": "CVX total supply must not exceed 100 million tokens.",
        "related_code": [],
        "origin": "check"
      },
      {
        "id": "vesting-treasury-not-revoked",
        "description": "Treasury cannot be revoked as a recipient.",
        "related_code": [],
        "origin": "check"
      }
    ],
    "general_security_ctx": [
      {
        "id": "SafeERC20_security_note",
        "source": "docs",
        "context_type": "best_practice",
        "details": "SafeERC20 is critical for handling non-standard ERC20s and preventing token lockup."
      },
      {
        "id": "EnumerableSet_security_note",
        "source": "docs",
        "context_type": "best_practice",
        "details": "EnumerableSet.add/remove do not revert on failure; always check return value."
      },
      {
        "id": "Upgradeable_contracts_security_note",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Use initializer functions and storage gaps to prevent storage collisions in upgradeable contracts."
      },
      {
        "id": "security-1",
        "source": "code_comment",
        "context_type": "best_practice",
        "details": "Pausable: only withdraw/unstake allowed when paused."
      },
      {
        "id": "ctx_gauge_claiming",
        "source": "docs",
        "context_type": "best_practice",
        "details": "Gauges are not deleted from the gauges map immediately to allow claiming of remaining balances."
      }
    ],
    "static_summary": null
  }
}