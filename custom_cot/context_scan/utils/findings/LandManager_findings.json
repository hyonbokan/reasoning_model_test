[
    {
        "Issue": "Schnibbles mint can overflow to `2^256-1` by supplying a negative bonus",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "Reward calculation converts a signed bonus back to an unsigned integer without validating its range.  \n\n```solidity\n// bonus coming from on-chain config\nfinalBonus = int16(REALM_BONUSES[...]) + int16(int8(RARITY_BONUSES[rarity]));\n\nschnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\n\n// \u26a0\ufe0f result cast back to uint256 **after** the signed arithmetic\nschnibblesTotal = uint256( (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100 );\n```\n\n`RARITY_BONUSES` is stored as `uint8[]` in the config contract but is cast to **int8** inside `LandManager`.  Any value \u2265\u2006128 becomes negative once cast (`uint8(200)` \u21d2 `int8(200)` = \u201156).  By configuring a rarity bonus \u2264\u2006155 the summed `finalBonus` can reach \u2013101 or lower.  The numerator becomes a large **negative** number; dividing by 100 keeps it negative and the subsequent cast to `uint256` wraps it into a value close to `2^256`, crediting the caller with essentially unlimited Schnibbles.  Landlords\u2019 share is computed from that inflated amount, so the whole economy is broken.\n\nBecause the arrays are fully controlled by the on-chain `ConfigStorage` owner, an attacker that gains this role \u2013 or a buggy upgrade script \u2013 can trivially set one entry to e.g. `255`, making the bonus \u20131\u0305, and mint the maximum possible reward in a single block.",
        "Recommendation": "",
        "Detector": "context_scan_default_o3-2025-04-16_0",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 0
    },
    {
        "Issue": "`toilerState.plotId` is never updated when a Munchable moves to a new plot",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "During a plot move, occupancy bitmaps are updated but the struct that drives farming logic keeps the **old** plot id:  \n\n```solidity\nfunction transferToUnoccupiedPlot(uint256 tokenId, uint256 plotId) ... {\n    ...\n    toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate; // \u2190 plotId forgotten\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot(false, 0);\n    plotOccupied[_toiler.landlord][plotId]    = Plot(true , tokenId);\n}\n```\n\nSubsequent calls to `_farmPlots` still use the previous `plotId`. If the landlord later reduces his number of plots below that stale id, the `dirty` flag branch is triggered and the contract starts paying rewards **with the timestamp of `lastUpdated` instead of `block.timestamp`**, effectively granting the farmer retroactive Schnibbles that were never earned.  In addition, other invariant-checking off-chain systems (or future contract upgrades) may assume `plotId` consistency and malfunction.",
        "Recommendation": "",
        "Detector": "context_scan_default_o3-2025-04-16_0",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 1
    },
    {
        "Issue": "Off-by-one lets a user stake more than the maximum 10 Munchables",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "`stakeMunchable` is supposed to cap each player at ten active stakes, but the condition uses `>` instead of `>=`:  \n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n...\nmunchablesStaked[mainAccount].push(tokenId); // length can become 11\n```\n\nWhen a player already has exactly ten tokens staked the check passes and the eleventh stake succeeds, violating the stated limit and all invariants depending on it.",
        "Recommendation": "",
        "Detector": "context_scan_default_o3-2025-04-16_0",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 2
    },
    {
        "Issue": "Division-by-zero DoS if `PRICE_PER_PLOT` is mis-configured",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "`PRICE_PER_PLOT` is loaded straight from `ConfigStorage` without validation.  If it is ever set to `0`, every call that needs `_getNumPlots` reverts:\n\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT; // \u2190 div 0\n}\n```\n\nLandlords would be unable to stake, transfer or farm, effectively freezing the whole module.  A faulty governance update or a malicious config owner could brick the contract permanently.",
        "Recommendation": "",
        "Detector": "context_scan_default_o3-2025-04-16_0",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 3
    },
    {
        "Issue": "External `AccountManager.updatePlayer` calls enable re-entrancy into state-changing functions",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "`_farmPlots` issues two external calls per loop iteration:\n\n```solidity\naccountManager.updatePlayer(landlord, landlordMetadata); // inside loop\n...\naccountManager.updatePlayer(mainAccount, renterMetadata); // after loop\n```\n\nBecause neither `stakeMunchable`, `unstakeMunchable` nor `transferToUnoccupiedPlot` is protected by `nonReentrant`, a malicious or compromised `AccountManager` implementation can call back into LandManager via any public function while the original one is still executing.  Re-entrancy lands in a partially updated state (e.g. `plotOccupied` set but `toilerState` not yet written), opening up possibilities for double-stake, bypassing length checks or stealing NFTs.  All user-facing entry points use the `forceFarmPlots` modifier, so every stake/unstake exposes this attack surface.",
        "Recommendation": "",
        "Detector": "context_scan_default_o3-2025-04-16_0",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 4
    },
    {
        "Issue": "Missing plotId update in transferToUnoccupiedPlot",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `transferToUnoccupiedPlot` function allows users to move their staked Munchable NFT from one plot to another unoccupied plot belonging to the same landlord. However, while the function updates the `plotOccupied` mapping to reflect the token's new location, it fails to update the `plotId` value in the `toilerState` mapping for the token.\n\n```solidity\nfunction transferToUnoccupiedPlot(\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    ToilerState memory _toiler = toilerState[tokenId];\n    uint256 oldPlotId = _toiler.plotId;\n    uint256 totalPlotsAvail = _getNumPlots(_toiler.landlord);\n    if (_toiler.landlord == address(0)) revert NotStakedError();\n    if (munchableOwner[tokenId] != mainAccount) revert InvalidOwnerError();\n    if (plotOccupied[_toiler.landlord][plotId].occupied)\n        revert OccupiedPlotError(_toiler.landlord, plotId);\n    if (plotId >= totalPlotsAvail) revert PlotTooHighError();\n\n    toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]\n        .currentTaxRate;\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({\n        occupied: false,\n        tokenId: 0\n    });\n    plotOccupied[_toiler.landlord][plotId] = Plot({\n        occupied: true,\n        tokenId: tokenId\n    });\n\n    emit FarmPlotLeave(_toiler.landlord, tokenId, oldPlotId);\n    emit FarmPlotTaken(toilerState[tokenId], tokenId);\n}\n```\n\nNotice that while the function updates `plotOccupied` for both the old and new plot locations, it only updates `toilerState[tokenId].latestTaxRate` but never updates `toilerState[tokenId].plotId` to the new plot ID.\n\nThis creates a critical inconsistency between the two data structures that track where Munchables are staked. The `plotOccupied` mapping will show the Munchable at the new plot, but `toilerState` will still reference the old plot.\n\nThis issue can lead to serious consequences in the farming system. In the `_farmPlots` function, the contract uses `_toiler.plotId` to determine if a Munchable's plot is still valid:\n\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n```\n\nWith the incorrect plotId, a Munchable might be incorrectly marked as \"dirty\" (or not marked when it should be), preventing users from earning rewards properly. Additionally, any function that relies on the accurate plot ID in `toilerState` will operate with incorrect data, potentially leading to further inconsistencies in the contract state.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 5
    },
    {
        "Issue": "Permanent disabling of plots with dirty flag",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The LandManager contract has a mechanism to mark plots as \"dirty\" when a landlord no longer has enough plots to support the plotId where a Munchable is staked. Once a plot is marked as dirty, there is no mechanism to clear this flag, effectively permanently disabling farming on that plot, even if the landlord later increases their plot count.\n\n```solidity\nfunction _farmPlots(address _sender) internal {\n    // ...\n    for (uint8 i = 0; i < staked.length; i++) {\n        timestamp = block.timestamp;\n        tokenId = staked[i];\n        _toiler = toilerState[tokenId];\n        if (_toiler.dirty) continue;  // Skip dirty plots\n        landlord = _toiler.landlord;\n        \n        if (_getNumPlots(landlord) < _toiler.plotId) {\n            timestamp = plotMetadata[landlord].lastUpdated;\n            toilerState[tokenId].dirty = true;  // Mark as dirty\n        }\n        // ... farming logic ...\n    }\n    // ...\n}\n```\n\nIn this code, when the contract detects that a landlord has fewer plots than needed for a staked Munchable (due to reduced locked tokens), it sets the `dirty` flag to `true` in the `toilerState` mapping. Subsequently, whenever `_farmPlots` is called, it will skip any Munchable with a dirty flag set.\n\nThe issue is that there is no code path to ever set the `dirty` flag back to `false`, even if the landlord increases their locked tokens and plot count. This creates a permanent penalty for landlords who temporarily reduce their locked tokens, as any Munchables staked on plots that became unavailable will be permanently unable to farm.\n\nThis behavior could lead to frustrated users who can't understand why their Munchables no longer generate rewards, even after the landlord has restored their plot count. The only workaround would be to unstake and restake the Munchable, which carries additional gas costs and disruption to the user experience.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 6
    },
    {
        "Issue": "Off-by-one error in staked Munchable limit check",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The LandManager contract implements a limit on how many Munchables a player can stake, but the check contains an off-by-one error that allows staking one more Munchable than intended.\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    // ...\n    if (munchablesStaked[mainAccount].length > 10)\n        revert TooManyStakedMunchiesError();\n    // ...\n}\n```\n\nThe check `munchablesStaked[mainAccount].length > 10` allows a user to stake up to 11 Munchables (since the condition only triggers when they try to stake the 12th Munchable). If the intended limit is 10 Munchables per user, the check should be `munchablesStaked[mainAccount].length >= 10`.\n\nThis issue allows users to stake slightly more Munchables than intended by the protocol design. While this doesn't represent a serious security threat, it could affect the economic balance or game mechanics if the limit was carefully chosen for specific reasons. Additionally, it creates inconsistency between the documented limits and the actual implementation.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 7
    },
    {
        "Issue": "Integer overflow risk in reward calculation with negative bonuses",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, there's a potential risk of integer overflow when calculating rewards with negative bonus values. While Solidity 0.8.25 has built-in overflow checking for arithmetic operations, the conversion between int256 and uint256 types could still cause issues:\n\n```solidity\nfinalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\nschnibblesTotal =\n    (timestamp - _toiler.lastToilDate) *\n    BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) +\n        (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nThe issue arises in the calculation of `schnibblesTotal`. If `finalBonus` is highly negative (potentially less than -100), then `(int256(schnibblesTotal) * finalBonus)` could be a large negative number. When this is added to `int256(schnibblesTotal)`, the result might still be negative.\n\nWhen a negative int256 value is converted to uint256 using the `uint256()` cast, Solidity will not revert but will instead perform a wrapping conversion that essentially adds 2^256 to the negative value. This could result in an unexpectedly large schnibbles amount being calculated, though the division by 100 might mitigate this in many cases.\n\nFor example, if `finalBonus` is -110 and `schnibblesTotal` starts at 100, the calculation would be:\n\n```\n(100 + (100 * -110)) / 100 = (100 - 11000) / 100 = -10900 / 100 = -109\n```\n\nConverting -109 to uint256 would yield a very large number rather than reverting, potentially causing incorrect reward calculations. While this issue requires very specific conditions (large negative bonuses), it represents a potential vulnerability in the reward calculation logic.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 8
    },
    {
        "Issue": "Inefficient account updates in _farmPlots function",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_farmPlots` function updates landlord data inside the loop for each staked Munchable, but only updates the main account data once outside the loop. This creates inefficient interaction with the AccountManager contract that could lead to higher gas costs.\n\n```solidity\nfunction _farmPlots(address _sender) internal {\n    // ...\n    for (uint8 i = 0; i < staked.length; i++) {\n        // ... calculations ...\n        \n        landlordMetadata.unfedSchnibbles += schnibblesLandlord;\n        landlordMetadata.lastPetMunchable = uint32(timestamp);\n        accountManager.updatePlayer(landlord, landlordMetadata);  // Updates landlord data in each iteration\n        \n        // ... more code ...\n    }\n    accountManager.updatePlayer(mainAccount, renterMetadata);  // Updates main account data once\n}\n```\n\nIf a user has multiple Munchables staked with the same landlord, the contract will unnecessarily make multiple calls to `accountManager.updatePlayer()` for the same landlord address. For example, if 5 Munchables are staked with Landlord A and 5 with Landlord B, the function will make 10 calls to update landlord data rather than 2 optimized updates.\n\nThis inefficiency doesn't affect the correctness of the calculations, but it does lead to higher gas costs for users who call `farmPlots()`. The gas costs increase linearly with the number of staked Munchables, which could make farming less economical for users who are heavily invested in the platform.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 9
    },
    {
        "Issue": "Unclear configuration parameter retrieval in _reconfigure",
        "Severity": "Info",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_reconfigure` function appears to use storage keys that don't match the expected parameter types, potentially leading to incorrect initialization of important contract parameters.\n\n```solidity\nfunction _reconfigure() internal {\n    // ...\n    \n    MIN_TAX_RATE = IConfigStorage(configStorage).getUint(\n        StorageKey.LockManager\n    );\n    MAX_TAX_RATE = IConfigStorage(configStorage).getUint(\n        StorageKey.AccountManager\n    );\n    DEFAULT_TAX_RATE = IConfigStorage(configStorage).getUint(\n        StorageKey.ClaimManager\n    );\n    BASE_SCHNIBBLE_RATE = IConfigStorage(configStorage).getUint(\n        StorageKey.MigrationManager\n    );\n    PRICE_PER_PLOT = IConfigStorage(configStorage).getUint(\n        StorageKey.NFTOverlord\n    );\n    \n    // ...\n}\n```\n\nIn this code, the function uses enum values like `StorageKey.LockManager` and `StorageKey.AccountManager` as keys to retrieve uint values. Based on the naming, these keys appear to be intended for retrieving contract addresses rather than numerical parameters.\n\nFor example, `StorageKey.LockManager` is used elsewhere to retrieve the LockManager contract address, but here it's being used to set the `MIN_TAX_RATE` value. This suggests either a naming confusion or an incorrect implementation of the configuration retrieval system.\n\nWithout seeing the full implementation of the ConfigStorage contract and the StorageKey enum, it's challenging to determine if this is actually incorrect or just an unintuitive naming convention. However, it presents a risk that the contract might be initialized with incorrect parameters, potentially affecting various contract operations including tax rates, schnibble generation, and plot pricing.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 10
    },
    {
        "Issue": "Incomplete validation in stakeMunchable function",
        "Severity": "Info",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function does not validate whether the `landlord` parameter has initialized their plot metadata, which could lead to unexpected behavior when interacting with uninitialized landlords.\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    if (landlord == mainAccount) revert CantStakeToSelfError();\n    if (plotOccupied[landlord][plotId].occupied)\n        revert OccupiedPlotError(landlord, plotId);\n    if (munchablesStaked[mainAccount].length > 10)\n        revert TooManyStakedMunchiesError();\n    if (munchNFT.ownerOf(tokenId) != mainAccount)\n        revert InvalidOwnerError();\n\n    uint256 totalPlotsAvail = _getNumPlots(landlord);\n    if (plotId >= totalPlotsAvail) revert PlotTooHighError();\n    \n    // ... more code ...\n    \n    toilerState[tokenId] = ToilerState({\n        lastToilDate: block.timestamp,\n        plotId: plotId,\n        landlord: landlord,\n        latestTaxRate: plotMetadata[landlord].currentTaxRate,\n        dirty: false\n    });\n    \n    // ... more code ...\n}\n```\n\nThe function checks various conditions such as plot availability and ownership but doesn't verify that `plotMetadata[landlord].lastUpdated != 0`, which would indicate that the landlord has initialized their metadata.\n\nLandlords are expected to initialize their metadata by calling `triggerPlotMetadata()` or having it initialized by the AccountManager. If staking to a landlord who hasn't initialized their metadata, the `latestTaxRate` in the `toilerState` would be set to whatever default value is in the uninitialized `plotMetadata` mapping (likely 0).\n\nThis could lead to unexpected behavior in reward calculations. For example, if the tax rate is 0 due to uninitialized metadata, landlords might not receive their expected share of schnibbles from farming operations.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 11
    },
    {
        "Issue": "Limited counter type for munchables loop",
        "Severity": "Best Practices",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, a `uint8` counter is used to iterate through the staked Munchables array, which limits the maximum number of staked Munchables that can be processed to 255.\n\n```solidity\nfunction _farmPlots(address _sender) internal {\n    // ...\n    uint256[] memory staked = munchablesStaked[mainAccount];\n    // ...\n    for (uint8 i = 0; i < staked.length; i++) {\n        // ... farming logic ...\n    }\n    // ...\n}\n```\n\nWhile this is unlikely to be an issue in practice since there's a separate check in `stakeMunchable` that limits the number of staked Munchables to around 10, it's generally a best practice to use the same data type for array indexes and loop counters that you use for the array's length.\n\nIn this case, since `staked.length` is of type `uint256`, the loop counter should also be of type `uint256` to avoid any potential type conversion issues or artificial limitations on the loop's range. Using a smaller type doesn't provide any significant gas savings and could introduce unexpected behavior if the contract is modified in the future to allow more staked Munchables.",
        "Recommendation": "",
        "Detector": "context_scan_default_claude-3-7-sonnet-20250219_1",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 12
    },
    {
        "Issue": "Stale plotId in toilerState after transferring to unoccupied plot",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "Missing update of `toilerState[tokenId].plotId` in `transferToUnoccupiedPlot` leads to stale `plotId` stored for a staked NFT. After moving the NFT to a new plot, `toilerState[tokenId].plotId` remains the old value. This has critical consequences:\n\n- Unstaking uses the stale `plotId`, freeing the old plot instead of the new one, leaving the new plot occupied forever and preventing future staking on that plot.\n- Farming operations and emitted events use the outdated plotId, leading to incorrect reward calculations and misleading logs.\n\n```solidity\nfunction transferToUnoccupiedPlot(\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    ToilerState memory _toiler = toilerState[tokenId];\n    uint256 oldPlotId = _toiler.plotId;\n    // ...\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({ occupied: false, tokenId: 0 });\n    plotOccupied[_toiler.landlord][plotId] = Plot({ occupied: true, tokenId: tokenId });\n    // Missing update: toilerState[tokenId].plotId = plotId;\n    emit FarmPlotTaken(toilerState[tokenId], tokenId);\n}\n```",
        "Recommendation": "",
        "Detector": "context_scan_default_o4-mini-2025-04-16_2",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 13
    },
    {
        "Issue": "Division by zero in _getNumPlots when PRICE_PER_PLOT is zero",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The function `_getNumPlots` calculates the number of available plots by dividing the locked weighted value by `PRICE_PER_PLOT`. However, there is no check to ensure that `PRICE_PER_PLOT` is non-zero. If `PRICE_PER_PLOT` is zero (due to misconfiguration or malicious config update), this leads to a division by zero and causes all calls to `stakeMunchable`, `transferToUnoccupiedPlot`, and `_farmPlots` (through the `forceFarmPlots` modifier) to revert, effectively halting key functionality.\n\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n}\n```",
        "Recommendation": "",
        "Detector": "context_scan_default_o4-mini-2025-04-16_2",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 14
    },
    {
        "Issue": "Missing reentrancy guard on functions performing external calls",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "Functions such as `farmPlots`, `stakeMunchable`, `unstakeMunchable`, and `transferToUnoccupiedPlot` invoke external calls (e.g., `accountManager.updatePlayer` and `munchNFT.transferFrom`) without any `nonReentrant` protection. This opens up potential reentrancy attacks if the `accountManager` or NFT contract is malicious or contains unexpected callbacks, allowing an attacker to reenter and manipulate state before previous operations complete.\n\n```solidity\nmodifier forceFarmPlots(address _account) {\n    _farmPlots(_account);\n    _;\n}\n\nfunction farmPlots() external override notPaused {\n    _farmPlots(msg.sender);\n}\n```\n\nNo `nonReentrant` modifier is applied to prevent nested invocations.",
        "Recommendation": "",
        "Detector": "context_scan_default_o4-mini-2025-04-16_2",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 15
    },
    {
        "Issue": "Off-by-one in maximum staked munchables check allows 11 NFTs",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function limits the number of staked Munchables per user by checking `if (munchablesStaked[mainAccount].length > 10) revert TooManyStakedMunchiesError();`. This condition only reverts when more than 10 munchables are already staked, allowing a user to stake the 11th munchable (when length == 10) without error, exceeding intended limits.\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```",
        "Recommendation": "",
        "Detector": "context_scan_default_o4-mini-2025-04-16_2",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 16
    },
    {
        "Issue": "LandManager lacks ERC721Receiver, preventing safeTransferFrom",
        "Severity": "Best Practices",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The contract accepts Munchable NFTs via `transferFrom`, but does not implement the `IERC721Receiver` interface (`onERC721Received`). As a result, any external `safeTransferFrom` of NFTs to this contract will revert because it does not support the ERC-721 token receiver hook, reducing interoperability and risking accidental token loss.\n\n```solidity\n// Missing implementation:\nfunction onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n) external returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n}\n```",
        "Recommendation": "",
        "Detector": "context_scan_default_o4-mini-2025-04-16_2",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 17
    },
    {
        "Issue": "`transferToUnoccupiedPlot` forgets to update `toilerState.plotId`, enabling duplicated-plot occupation and breaking reward accounting",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "When a staked Munchable is moved to another plot the contract frees the old plot and marks the new one as occupied, but it never updates the internal bookkeeping that links the token to its plot.\n\n```solidity\nfunction transferToUnoccupiedPlot(uint256 tokenId, uint256 plotId) ... {\n    ...\n    // plot bookkeeping updated correctly \u2026\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({occupied: false, tokenId: 0});\n    plotOccupied[_toiler.landlord][plotId]     = Plot({occupied: true,  tokenId: tokenId});\n\n    // BUG \u2011- the new plot id is **not** written back\n    // toilerState[tokenId].plotId = plotId;   <-- missing\n    ...\n}\n```\n\nBecause `toilerState[tokenId].plotId` continues to point to the *old* plot:\n1. `plotOccupied` shows the old plot as empty, allowing **another** Munchable to be staked there. Two tokens can now farm while the accounting layer still believes they share a single plot.\n2. `_farmPlots` uses `toilerState[tokenId].plotId` to decide whether the token became \"dirty\" (un-farmable) when the landlord\u2019s number of plots shrank.  The stale value may incorrectly mark the toiler as dirty or, conversely, skip the check completely, letting a token harvest even though its *real* plot no longer exists.\n3. All invariants that rely on `toilerState.plotId` being accurate (see provided invariant list) are violated, permanently corrupting on-chain state and reward distribution.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o3-2025-04-16_3",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 18
    },
    {
        "Issue": "Off-by-one allows staking 11 Munchables although the hard limit is supposed to be 10",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The maximum number of Munchables a player may stake is intended to be ten, nevertheless the condition is checked **before** the new token is appended and uses a strict \u201cgreater-than\u201d comparison:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n...\n// afterwards the list is extended\nmunchablesStaked[mainAccount].push(tokenId);\n```\n\nIf a player already has exactly 10 tokens staked the `require` passes, the `push` executes and the list length becomes **11**.  Subsequent logic (including the invariant `munchablesStaked[mainAccount].length <= 10`) is now broken and future loops that rely on the limit (e.g. the `uint8` counter inside `_farmPlots`) may overflow or revert.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o3-2025-04-16_3",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 19
    },
    {
        "Issue": "Arithmetic overflow danger in Schnibble calculation can brick farming for all players",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "`schnibblesTotal` is computed as the product of an unbounded time interval and `BASE_SCHNIBBLE_RATE`, both loaded from configuration:\n\n```solidity\nschnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE; // unchecked\n```\n\nIf the admin (or a compromised `ConfigStorage`) sets `BASE_SCHNIBBLE_RATE` to a large value the multiplication will overflow and **revert** under Solidity \u2265 0.8.  Because the whole operation is performed inside the common `_farmPlots` modifier, *every* call to `stakeMunchable`, `unstakeMunchable`, `transferToUnoccupiedPlot` or `farmPlots` will start reverting, effectively DoSing the entire LandManager.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o3-2025-04-16_3",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 20
    },
    {
        "Issue": "Critical constants loaded from the wrong storage keys \u2013 mis-configuration can disable the game",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `_reconfigure` the contract fetches parameters from `ConfigStorage`, but the keys used are clearly meant for *addresses* of other contracts:\n\n```solidity\nMIN_TAX_RATE    = config.getUint(StorageKey.LockManager);      // actually holds an address\nMAX_TAX_RATE    = config.getUint(StorageKey.AccountManager);   // address again\nDEFAULT_TAX_RATE= config.getUint(StorageKey.ClaimManager);\nBASE_SCHNIBBLE_RATE = config.getUint(StorageKey.MigrationManager);\nPRICE_PER_PLOT  = config.getUint(StorageKey.NFTOverlord);      // address of another contract\n```\n\nIf those keys are not manually repurposed to store numeric values the contract will treat 20-byte addresses as huge integers (\u224810^47), making most checks revert:\n\u2022 `updateTaxRate` will reject any realistic rate because it is lower than the gigantic `MIN_TAX_RATE`.\n\u2022 `PRICE_PER_PLOT` will be astronomically large, causing `_getNumPlots` to return 0 for everybody, which in turn makes **every** `stakeMunchable` call revert with `PlotTooHighError()`.\n\nA single mis-configured entry therefore bricks the whole protocol.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o3-2025-04-16_3",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 21
    },
    {
        "Issue": "`_farmPlots` loop counter is `uint8` \u2013 more than 255 staked tokens reverts the entire transaction",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "```solidity\nfor (uint8 i = 0; i < staked.length; i++) {\n    ...\n}\n```\n\nIf, through future design changes or a bug in the stake-limit, a player ends up with >255 tokens in `munchablesStaked`, the `i++` at iteration 255 will overflow and revert (Solidity 0.8 checks arithmetic on small integers).  All subsequent farming/staking actions for that user will be impossible until the list length is reduced under 256.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o3-2025-04-16_3",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 22
    },
    {
        "Issue": "State corruption risk \u2013 `transferToUnoccupiedPlot` does not refresh `lastToilDate`",
        "Severity": "Info",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "Moving a token to a new plot leaves `toilerState.lastToilDate` untouched.  If a player instantly calls `farmPlots` again the time delta becomes *zero*, so the first farming round on the new plot yields no Schnibbles.  Updating the timestamp would provide intuitive behaviour and avoid confusion.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o3-2025-04-16_3",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 23
    },
    {
        "Issue": "Incorrect configuration parameter loading",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_reconfigure()` function, the contract loads critical configuration parameters using keys that appear to be mismatched with what they're intended to represent:\n\n```solidity\nMIN_TAX_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.LockManager\n);\nMAX_TAX_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.AccountManager\n);\nDEFAULT_TAX_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.ClaimManager\n);\nBASE_SCHNIBBLE_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.MigrationManager\n);\nPRICE_PER_PLOT = IConfigStorage(configStorage).getUint(\n    StorageKey.NFTOverlord\n);\n```\n\nThese storage keys appear to be intended for contract addresses rather than configuration values, given their names (LockManager, AccountManager, etc.). This mismatch will cause the contract to load completely unrelated values for these critical parameters, resulting in system-wide malfunction. Tax rates could be set to impractical values, reward calculations could break, and the entire land system could operate with incorrect economics.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 24
    },
    {
        "Issue": "Munchables on invalid plots stop earning rewards but remain stuck",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "When a landlord reduces their locked token amount and the number of available plots decreases, Munchables staked on now-invalid plots are marked as \"dirty\" and permanently stop earning rewards:\n\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n\n// Later in the code\nif (_toiler.dirty) continue; // Skip reward calculation\n```\n\nOnce a Munchable is marked as dirty, it continues to be skipped in all future reward calculations. The only way for users to recover these NFTs is through the `unstakeMunchable` function, but there is no notification or clear indication to users that their NFTs have stopped earning rewards. Users might continue to believe their Munchables are earning rewards when they're actually not, leading to confusion and frustration. The contract lacks any mechanism for the user to be informed when their staked Munchable becomes \"dirty\".",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 25
    },
    {
        "Issue": "Potential underflow in reward calculation with negative bonuses",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The Schnibbles reward calculation handles bonuses by first converting to int256, applying the bonus percentage, and then converting back to uint256:\n\n```solidity\nfinalBonus = int16(REALM_BONUSES[...]) + int16(int8(RARITY_BONUSES[...]));\nschnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nIf the `finalBonus` is a large negative value (which is possible since REALM_BONUSES is an int16[] array), the calculation `(int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus))` could result in a negative number. When this negative number is converted back to uint256, it will revert due to underflow.\n\nThis issue is particularly problematic because it would cause the entire `_farmPlots` function to revert, preventing users from unstaking their Munchables or performing other critical operations that rely on the `forceFarmPlots` modifier.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 26
    },
    {
        "Issue": "Logical error in staked Munchables limit check",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `stakeMunchable` function, there's a check to limit the number of Munchables a user can stake:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\n\nThis check uses a \"greater than\" comparison (`>`) instead of \"greater than or equal to\" (`>=`). If the intention is to limit users to a maximum of 10 staked Munchables, the check should be `>=` 10. With the current implementation, users can stake up to 11 Munchables (not 10 as likely intended).\n\nThis inconsistency could lead to unexpected behavior when a user has exactly 10 Munchables staked and tries to stake another one. The system would allow an 11th Munchable to be staked, which may violate assumptions made elsewhere in the codebase or in external systems that interact with this contract.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 27
    },
    {
        "Issue": "Type mismatch in loop counter could lead to overflow",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, a `uint8` type is used for the loop counter when iterating through staked Munchables:\n\n```solidity\nuint256[] memory staked = munchablesStaked[mainAccount];\n// ...\nfor (uint8 i = 0; i < staked.length; i++) {\n    // Processing each staked token\n}\n```\n\nUsing `uint8` limits the counter to a maximum value of 255. While the contract seems to enforce a limit of at most 11 staked Munchables elsewhere, using a `uint8` is inconsistent with this limit and could theoretically cause an overflow if a user somehow accumulated more than 255 staked Munchables. This could lead to an infinite loop or incomplete processing of staked Munchables.\n\nConsistency in data types is important for code clarity and preventing potential bugs as the contract evolves.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 28
    },
    {
        "Issue": "Changing order of staked Munchables array may cause confusion",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_removeTokenIdFromStakedList` function uses a \"swap and pop\" pattern to remove a token ID from the staked Munchables array:\n\n```solidity\nif (munchablesStaked[mainAccount][i] == tokenId) {\n    munchablesStaked[mainAccount][i] = munchablesStaked[\n        mainAccount\n    ][stakedLength - 1];\n    found = true;\n    munchablesStaked[mainAccount].pop();\n    break;\n}\n```\n\nThis approach is gas-efficient but changes the order of the staked Munchables array. When a Munchable is unstaked, the last element in the array is moved to the position of the removed element. If users or external systems rely on the order of staked Munchables remaining consistent (e.g., for UI display or tracking purposes), this could lead to confusion or integration issues.\n\nWhile this doesn't affect the core functionality of the contract, it could impact user experience or cause issues with external systems that expect a consistent ordering.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 29
    },
    {
        "Issue": "Lack of validation for array index access",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, when calculating the reward bonus, there's an array access that could potentially be out of bounds:\n\n```solidity\nfinalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\n```\n\nThe code accesses REALM_BONUSES at index `(uint256(immutableAttributes.realm) * 5) + uint256(landlordMetadata.snuggeryRealm)` and RARITY_BONUSES at index `uint256(immutableAttributes.rarity)` without validating that these indices are within the bounds of their respective arrays. If either NFT attributes or landlord metadata contain unexpected values, these accesses could revert due to out-of-bounds access.\n\nWhile this might be validated in external components (like the NFTAttributesManager), adding explicit bounds checking would make the contract more robust against unexpected inputs.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 30
    },
    {
        "Issue": "No validation that landlord has initialized plot metadata",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `stakeMunchable` function, there's no check to verify that the landlord has initialized their plot metadata:\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    // ... other checks ...\n    \n    toilerState[tokenId] = ToilerState({\n        lastToilDate: block.timestamp,\n        plotId: plotId,\n        landlord: landlord,\n        latestTaxRate: plotMetadata[landlord].currentTaxRate,  // Uses the tax rate without checking initialization\n        dirty: false\n    });\n    // ...\n}\n```\n\nIf the landlord hasn't called `triggerPlotMetadata()` or been initialized through `updatePlotMetadata()`, the `plotMetadata[landlord].currentTaxRate` will be 0, which could be lower than the intended minimum tax rate. This could lead to landlords not receiving any tax when users harvest rewards from Munchables staked on their plots.\n\nThe contract should verify that `plotMetadata[landlord].lastUpdated != 0` before allowing users to stake on a landlord's plots, similar to the check in the `updateTaxRate` function.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_claude-3-7-sonnet-20250219_4",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 31
    },
    {
        "Issue": "Reentrancy via external calls to accountManager.updatePlayer without guard",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_farmPlots` internal function performs external calls to `accountManager.updatePlayer` inside its loop, without any reentrancy protection. Because these calls are made before state changes complete, a malicious or compromised `accountManager` contract can re-enter `LandManager` and invoke functions like `stakeMunchable`, `unstakeMunchable`, or even `farmPlots` itself, manipulating the contract\u2019s state.\n\n```solidity\nfunction _farmPlots(address _sender) internal {\n    ...\n    accountManager.updatePlayer(landlord, landlordMetadata);\n    ...\n    accountManager.updatePlayer(mainAccount, renterMetadata);\n    ...\n}\n```\nWhen `accountManager.updatePlayer` is called, control is transferred to an external contract under no constraints. Without a `nonReentrant` guard, the external contract could call back into `LandManager` (e.g., `unstakeMunchable`), causing unexpected state changes, NFT loss, or incorrect reward accounting.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o4-mini-2025-04-16_5",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 32
    },
    {
        "Issue": "Missing update of `toilerState.plotId` in `transferToUnoccupiedPlot`",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `transferToUnoccupiedPlot` function moves a staked munchable from one plot to another, but fails to update the `plotId` in the `toilerState` mapping. As a result, the internal state and emitted events become inconsistent.\n\n```solidity\nfunction transferToUnoccupiedPlot(... ) {\n    ...\n    toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate;\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({ occupied: false, tokenId: 0 });\n    plotOccupied[_toiler.landlord][plotId] = Plot({ occupied: true, tokenId: tokenId });\n    emit FarmPlotLeave(...);\n    emit FarmPlotTaken(toilerState[tokenId], tokenId);\n}\n```\nThe code never executes:\n```solidity\ntoilerState[tokenId].plotId = plotId;\n```\nTherefore, subsequent calls to `farmPlots` will still reference the old `plotId`, potentially misallocating rewards or blocking further transfers.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o4-mini-2025-04-16_5",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 33
    },
    {
        "Issue": "Unchecked array indexing of REALM_BONUSES and RARITY_BONUSES can revert",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `_farmPlots`, bonuses are fetched from the `REALM_BONUSES` and `RARITY_BONUSES` arrays using indices derived from NFT attributes without any bounds checking. If an attribute value or array configuration is out of range, the contract will revert, potentially blocking all farming operations.\n\n```solidity\nint256 finalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\n```\nNo checks ensure that `(realm * 5 + snuggeryRealm)` or `immutabilityAttributes.rarity` are within array bounds. A single misconfigured attribute or malformed bonus array can cause out-of-bounds errors and revert, DoS-ing the entire farming mechanism.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o4-mini-2025-04-16_5",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 34
    },
    {
        "Issue": "Division by zero in `_getNumPlots` when PRICE_PER_PLOT is zero",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The helper function `_getNumPlots` divides a user\u2019s locked weighted value by `PRICE_PER_PLOT` without validating that `PRICE_PER_PLOT` is non-zero. If `PRICE_PER_PLOT` in configuration is set to 0, any call to `_getNumPlots` (used in staking, transferring, and farming) will revert due to division by zero.\n\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n}\n```\nThis misconfiguration or exploit can completely block users from staking or farming, resulting in a Denial-of-Service condition.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o4-mini-2025-04-16_5",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 35
    },
    {
        "Issue": "Modifier `forceFarmPlots` may cause unintended DoS of staking and unstaking",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `forceFarmPlots` modifier invokes the internal `_farmPlots` function at the start of `stakeMunchable`, `unstakeMunchable`, and `transferToUnoccupiedPlot`. If `_farmPlots` fails (e.g., due to out-of-bounds indexing, external call revert, or other errors), it prevents the rest of the function from executing, blocking staking, unstaking, and transfers.\n\n```solidity\nmodifier forceFarmPlots(address _account) {\n    _farmPlots(_account);\n    _;\n}\n\nfunction stakeMunchable(...) external forceFarmPlots(msg.sender) notPaused {\n    // stake logic\n}\n```\nTightly coupling farming logic with staking operations means any issue in farming (even unrelated to staking) will disable critical user actions, leading to a Denial-of-Service for plot management.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o4-mini-2025-04-16_5",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 36
    },
    {
        "Issue": "Off-by-one error in `stakeMunchable` staking limit",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function is intended to cap the number of staked munchables at 10, but the condition incorrectly allows 11 due to an off-by-one error:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\nWhen `munchablesStaked.length == 10`, the check `> 10` is false, allowing an 11th munchable to be staked. This undermines the intended staking limit.",
        "Recommendation": "",
        "Detector": "context_scan_default_2_o4-mini-2025-04-16_5",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 37
    },
    {
        "Issue": "Incorrect Schnibbles bonus calculation can turn negative and overflow, breaking the whole farming flow",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The reward computation in `_farmPlots()` is mathematically wrong and becomes dangerous when `finalBonus` is negative.\n\n```solidity\nschnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\n// <== Wrong formula \u2013 finalBonus is a % but is *not* scaled by 1e2 here\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n1.  For **positive bonuses** the result is far too small (e.g. a +30 % bonus returns 31 % of the base instead of 130 %), distorting the game economy.\n2.  If `finalBonus <= -2` the numerator becomes negative.  The cast back to `uint256` wraps the value to a huge number close to 2\u00b2\u2075\u2076, which is then used in\n\n```solidity\nschnibblesLandlord = (schnibblesTotal * _toiler.latestTaxRate) / 1e18;\n```\nThis multiplication inevitably overflows and reverts, causing every subsequent call to `farmPlots`, `stakeMunchable`, `unstakeMunchable`, or `transferToUnoccupiedPlot` (all guarded by `forceFarmPlots`) to fail.  A user only needs to stake one NFT whose realm bonus plus rarity bonus is \u2264 \u22122 to permanently DOS their own account \u2013 and by extension any landlord logic interacting with that NFT.\n\nBecause `REALM_BONUSES` is an `int16[]`, negative bonuses are perfectly legal.  The bug therefore has **high impact** (funds/NFTs get stuck, protocol accounting breaks) and **high likelihood** (no privileged role required, just a specific realm\u2013rarity combination).",
        "Recommendation": "",
        "Detector": "context_scan_none_o3-2025-04-16_6",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 38
    },
    {
        "Issue": "External calls inside `_farmPlots` allow re-entrancy into state-changing functions",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "`_farmPlots()` is invoked by the `forceFarmPlots` modifier that wraps every staking, unstaking, and plot-transfer action.  Inside the function two **state-changing external calls** are made to an untrusted contract:\n\n```solidity\naccountManager.updatePlayer(landlord, landlordMetadata);\n...\naccountManager.updatePlayer(mainAccount, renterMetadata);\n```\nNothing prevents a malicious or compromised `AccountManager` implementation from calling back into `LandManager` during these calls (e.g. another `stakeMunchable` or `unstakeMunchable`).  Because `LandManager` has **no re-entrancy guard**, the internal state assumptions that follow the modifier can be violated:\n\n* During `unstakeMunchable` a re-entrant second `unstakeMunchable` executed **before** the first one finishes will pass all ownership checks, transfer the NFT out once and then leave the outer call to revert in `_removeTokenIdFromStakedList`, permanently locking the token.\n* A similar pattern lets an attacker front-run their own `stakeMunchable`, placing the same token in multiple `Plot` structs before the outer call finishes, corrupting mappings and arrays.\n\nEven if the transaction ultimately reverts, the protocol can be frozen by continuously exploiting these inconsistent intermediate states.  The absence of `nonReentrant` (or the checks-effects-interactions pattern) around such external calls makes exploitation realistic.",
        "Recommendation": "",
        "Detector": "context_scan_none_o3-2025-04-16_6",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 39
    },
    {
        "Issue": "Off-by-one staking limit plus uint8 loop counter can brick accounts",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "`stakeMunchable()` is supposed to cap every player at ten staked NFTs, but the condition is written incorrectly:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n        revert TooManyStakedMunchiesError();\n```\nBecause the revert triggers only **after** the length exceeds ten, users can actually stake **eleven** NFTs.  Nothing stops them from repeating the action, so the array can grow well beyond the intended cap.\n\nWhy this matters:\n1. `_farmPlots()` later iterates with a `uint8` index:\n   ```solidity\n   for (uint8 i = 0; i < staked.length; i++) {\n   ```\n   When `staked.length` reaches 256, `i++` overflows and reverts, permanently breaking farming for that user (and every call protected by `forceFarmPlots`).\n2. Several documented invariants (`munchablesStaked[mainAccount].length <= 10`) are silently violated.\n\nExploitability is moderate because players stake NFTs themselves, but the impact is limited to self-DOS, hence **Low** severity.",
        "Recommendation": "",
        "Detector": "context_scan_none_o3-2025-04-16_6",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 40
    },
    {
        "Issue": "Tax-free farming by targeting landlords with un-initialized metadata",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "When a player stakes an NFT, the current tax rate is taken from `plotMetadata[landlord].currentTaxRate`:\n\n```solidity\ntoilerState[tokenId] = ToilerState({\n    ...\n    latestTaxRate: plotMetadata[landlord].currentTaxRate,\n    ...\n});\n```\nIf the chosen landlord **never called `triggerPlotMetadata()`** (and `AccountManager` has not invoked `updatePlotMetadata()` for them), `plotMetadata[landlord]` is the default\u2010initialised struct with `currentTaxRate == 0`.  The staker therefore pays **0 % tax** until the landlord (or a privileged contract) initialises metadata, despite `MIN_TAX_RATE` being enforced elsewhere.\n\nAn attacker can deliberately search for addresses that locked funds but have not initialised metadata, stake their NFTs on those plots, and farm with zero fees\u2014an un-fair economic advantage that was clearly unintended.",
        "Recommendation": "",
        "Detector": "context_scan_none_o3-2025-04-16_6",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 41
    },
    {
        "Issue": "Missing plot ID update in transferToUnoccupiedPlot",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `transferToUnoccupiedPlot` function fails to update the `plotId` field in the `toilerState` mapping when a Munchable is transferred to a new plot. While the function correctly updates the `plotOccupied` mapping for both the old and new plots, it never sets `toilerState[tokenId].plotId` to the new plot ID.\n\n```solidity\nfunction transferToUnoccupiedPlot(\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    // ... validation code ...\n    \n    toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]\n        .currentTaxRate;\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({\n        occupied: false,\n        tokenId: 0\n    });\n    plotOccupied[_toiler.landlord][plotId] = Plot({\n        occupied: true,\n        tokenId: tokenId\n    });\n    // Missing: toilerState[tokenId].plotId = plotId;\n    \n    emit FarmPlotLeave(_toiler.landlord, tokenId, oldPlotId);\n    emit FarmPlotTaken(toilerState[tokenId], tokenId);\n}\n```\n\nThis leads to a critical inconsistency where the `plotOccupied` mapping shows the token on the new plot, but `toilerState` still associates it with the old plot. When `_farmPlots` tries to process rewards, it will use the outdated plot ID from `toilerState`, leading to incorrect reward calculations. Additionally, if another token is subsequently staked on the old plot, there will be conflicting state where two tokens appear to occupy the same plot from different perspectives.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 42
    },
    {
        "Issue": "Potential integer underflow in schnibbles reward calculation",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The reward calculation in `_farmPlots` contains a vulnerability where large negative bonuses can cause underflow in the reward calculation, potentially leading to massive unintended rewards.\n\n```solidity\nfinalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\nschnibblesTotal =\n    (timestamp - _toiler.lastToilDate) *\n    BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) +\n        (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nIf `finalBonus` is a large negative value (less than -100), the calculation can result in a negative number, which when cast to uint256 would become an extremely large positive value due to two's complement representation. \n\nFor example, if finalBonus is -101:\n* `(schnibblesTotal + schnibblesTotal * (-101)) / 100`\n* `= (schnibblesTotal - 101 * schnibblesTotal) / 100`\n* `= schnibblesTotal * (1 - 101) / 100`\n* `= schnibblesTotal * (-100) / 100`\n* `= -schnibblesTotal`\n\nWhen this negative value is cast to uint256, it becomes `2^256 - schnibblesTotal`, which is close to the maximum uint256 value. This could lead to users receiving massive unintended rewards and cause severe economic damage to the protocol.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 43
    },
    {
        "Issue": "Incorrect storage keys used for configuration values",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_reconfigure` function, the contract uses inappropriate storage keys to retrieve configuration values. The code is using contract name keys to retrieve numeric configuration values, which is likely incorrect.\n\n```solidity\nMIN_TAX_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.LockManager  // Inappropriate key - using contract name instead of a value-specific key\n);\nMAX_TAX_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.AccountManager  // Inappropriate key - using contract name instead of a value-specific key\n);\nDEFAULT_TAX_RATE = IConfigStorage(configStorage).getUint(\n    StorageKey.ClaimManager  // Inappropriate key - using contract name instead of a value-specific key\n);\n```\n\nThe actual keys for these values should be something specific to the configuration value (e.g., `StorageKey.MinTaxRate`). Using contract name keys for numeric values will likely retrieve incorrect data or zero values, potentially breaking core functionality like tax rate limits and default values.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 44
    },
    {
        "Issue": "Reentrancy vulnerability in stakeMunchable",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function makes an external call (`transferFrom`) before updating internal state, which violates the Checks-Effects-Interactions pattern and could potentially allow reentrancy attacks.\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    // ... validation checks ...\n    \n    munchNFT.transferFrom(mainAccount, address(this), tokenId);  // External call before state updates\n    \n    // State updates after external call\n    plotOccupied[landlord][plotId] = Plot({\n        occupied: true,\n        tokenId: tokenId\n    });\n    munchablesStaked[mainAccount].push(tokenId);\n    munchableOwner[tokenId] = mainAccount;\n    // ... more state changes ...\n}\n```\n\nIf the `munchNFT` contract contains malicious code or is compromised, it could reenter the `LandManager` during the `transferFrom` call and manipulate the contract state before the subsequent updates. While the impact is limited by the fact that users would primarily be manipulating their own state, it still represents a security vulnerability that violates best practices.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 45
    },
    {
        "Issue": "Unchecked array bounds access in reward calculation",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, the code accesses elements from the `REALM_BONUSES` and `RARITY_BONUSES` arrays without ensuring the calculated indices are within bounds:\n\n```solidity\nfinalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\n```\n\nIf `immutableAttributes.realm`, `landlordMetadata.snuggeryRealm`, or `immutableAttributes.rarity` have values larger than expected, the array access could be out of bounds. Since Solidity 0.8.0, this would cause a panic and revert the transaction. \n\nThis represents a potential denial-of-service vulnerability, as malicious users could craft values that intentionally cause out-of-bounds access. Additionally, if these values come from user input or can be influenced indirectly, it could prevent legitimate users from farming their rewards.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 46
    },
    {
        "Issue": "Potential division by zero in _getNumPlots",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_getNumPlots` function divides by `PRICE_PER_PLOT` without verifying that it's non-zero:\n\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n}\n```\n\nIf `PRICE_PER_PLOT` is set to 0 through admin error or misconfiguration, this function will revert on all calls due to division by zero. Since this function is central to the land management system and is called by core functions like `stakeMunchable` and `transferToUnoccupiedPlot`, a division by zero error would render these functions unusable and potentially lock user funds by preventing unstaking.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 47
    },
    {
        "Issue": "Missing zero address checks for external contracts",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_reconfigure` function retrieves addresses for external contracts but doesn't check if they're valid (non-zero addresses):\n\n```solidity\nfunction _reconfigure() internal {\n    lockManager = ILockManager(\n        IConfigStorage(configStorage).getAddress(StorageKey.LockManager)\n    );\n    accountManager = IAccountManager(\n        IConfigStorage(configStorage).getAddress(StorageKey.AccountManager)\n    );\n    munchNFT = IERC721(configStorage.getAddress(StorageKey.MunchNFT));\n    nftAttributesManager = INFTAttributesManager(\n        IConfigStorage(configStorage).getAddress(\n            StorageKey.NFTAttributesManager\n        )\n    );\n    // ... rest of function ...\n}\n```\n\nIf any of these addresses are set to the zero address (due to misconfiguration or admin error), calls to these contracts will fail silently or revert, potentially breaking core functionality of the system. This is especially concerning for upgradeable contracts where configuration can change over time.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 48
    },
    {
        "Issue": "Incorrect limit check on staked Munchables array",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function contains a check to limit the number of Munchables a user can stake, but the check is incorrectly implemented:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\n\nThis check will only revert when a user has already staked 11 or more Munchables, not when they attempt to stake their 11th. The check should use `>=` instead of `>` to properly enforce a limit of 10 staked Munchables.\n\nWith the current implementation, users can stake exactly 11 Munchables (10 existing + 1 new one) before the check triggers on the 12th attempt. While this doesn't pose a security risk, it does violate the intended business logic of the contract.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 49
    },
    {
        "Issue": "Potential DoS in farm plots loop",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_farmPlots` function contains a loop that processes rewards for all staked tokens, with multiple storage reads and external calls inside the loop:\n\n```solidity\nfor (uint8 i = 0; i < staked.length; i++) {\n    // ... multiple storage operations ...\n    immutableAttributes = nftAttributesManager.getImmutableAttributes(tokenId);\n    // ... reward calculation ...\n    accountManager.updatePlayer(landlord, landlordMetadata);\n    // ... more operations ...\n}\naccountManager.updatePlayer(mainAccount, renterMetadata);\n```\n\nThis pattern has several issues that could lead to denial of service:\n\n1. The loop counter uses uint8, limiting the maximum to 255 staked tokens\n2. External calls inside loops can be gas-inefficient and prone to failure\n3. If gas costs increase or if users stake many tokens, the function could hit block gas limits\n\nIf the function becomes too gas-intensive to execute, users wouldn't be able to harvest their rewards or potentially unstake their tokens (since unstaking uses the `forceFarmPlots` modifier).",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 50
    },
    {
        "Issue": "Centralization risk in configuration management",
        "Severity": "Info",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The contract relies heavily on centralized configuration via the ConfigStorage contract, with no apparent limits on how these values can be modified:\n\n```solidity\nMIN_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.LockManager);\nMAX_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.AccountManager);\nDEFAULT_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.ClaimManager);\nBASE_SCHNIBBLE_RATE = IConfigStorage(configStorage).getUint(StorageKey.MigrationManager);\nPRICE_PER_PLOT = IConfigStorage(configStorage).getUint(StorageKey.NFTOverlord);\n```\n\nIf the ConfigStorage contract is compromised or controlled by a malicious admin, they could:\n\n1. Set unreasonable tax rates to extract excessive fees\n2. Change PRICE_PER_PLOT to manipulate the number of plots users get for their locked tokens\n3. Modify BASE_SCHNIBBLE_RATE to affect reward distribution\n4. Change bonuses to favor certain players or realms\n\nWhile this is a design choice rather than a bug, it represents a centralization risk that users should be aware of.",
        "Recommendation": "",
        "Detector": "context_scan_none_claude-3-7-sonnet-20250219_7",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 51
    },
    {
        "Issue": "Negative bonus calculation can overflow into huge unsigned rewards",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The reward calculation in `_farmPlots` applies a signed `finalBonus` percentage to the base schnibbles and then converts the result back to `uint256`. If `finalBonus` is negative and its absolute value exceeds 100, the intermediate `int256` result becomes negative. Converting a negative `int256` to `uint256` produces a very large value, allowing arbitrary inflation of rewards. For example:\n\n```solidity\n// inside _farmPlots\nfinalBonus = int16(\n    REALM_BONUSES[...]  // could be negative\n) + int16(int8(RARITY_BONUSES[...]));\n\n// base rewards\nschnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\n\n// signed adjustment, then cast to uint\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nIf `finalBonus` < -100, `(int256(schnibblesTotal) + ...)` is negative, and the cast to `uint256` wraps to a huge number, minting an excessive amount of schnibbles.",
        "Recommendation": "",
        "Detector": "context_scan_none_o4-mini-2025-04-16_8",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 52
    },
    {
        "Issue": "Division by zero possible if PRICE_PER_PLOT is zero",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The helper function `_getNumPlots` divides by `PRICE_PER_PLOT` without checking for zero. If `PRICE_PER_PLOT` is ever configured as zero, all calls to this function (used in `stakeMunchable`, `farmPlots`, etc.) will revert with a division\u2010by\u2010zero error, effectively DoS-ing staking and farming:\n\n```solidity\nfunction _getNumPlots(address _account) internal view returns (uint256) {\n    return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n}\n```",
        "Recommendation": "",
        "Detector": "context_scan_none_o4-mini-2025-04-16_8",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 53
    },
    {
        "Issue": "`transferToUnoccupiedPlot` does not update stored plotId",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "When moving a staked munchable to a new plot, the code updates occupancy mappings but fails to set the new `plotId` in storage. The `toilerState[tokenId].plotId` remains the old plot, causing inconsistent state and misleading events:\n\n```solidity\n// In transferToUnoccupiedPlot:\nToilerState memory _toiler = toilerState[tokenId];\nuint256 oldPlotId = _toiler.plotId;\n// ... update mappings:\nplotOccupied[_toiler.landlord][oldPlotId] = Plot({ occupied: false, tokenId: 0 });\nplotOccupied[_toiler.landlord][plotId]   = Plot({ occupied: true,  tokenId: tokenId });\n\n// Emit using stale storage value\nemit FarmPlotTaken(toilerState[tokenId], tokenId);\n```\n\nMissing assignment:\n```solidity\ntoilerState[tokenId].plotId = plotId;\n```",
        "Recommendation": "",
        "Detector": "context_scan_none_o4-mini-2025-04-16_8",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 54
    },
    {
        "Issue": "Off-by-one in stake limit allows 11st stake",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The check in `stakeMunchable` uses `> 10` instead of `>= 10`, allowing a 11th munchable to be staked before hitting the limit:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n// When length == 10, this check passes (10 > 10 is false), then push => length == 11.\nmunchablesStaked[mainAccount].push(tokenId);\n```",
        "Recommendation": "",
        "Detector": "context_scan_none_o4-mini-2025-04-16_8",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 55
    },
    {
        "Issue": "Underflow in reward calculation causes DoS and traps NFTs",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `_farmPlots`:\n\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n// ...\nuint256 schnibblesTotal =\n    (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\n```\n\nIf `plotMetadata[landlord].lastUpdated` is less than `_toiler.lastToilDate`, the subtraction underflows and reverts under Solidity 0.8's checked arithmetic. Because `unstakeMunchable` is guarded by the `forceFarmPlots` modifier, this revert prevents tenants from calling `unstakeMunchable` (or any function using `forceFarmPlots`), permanently locking their NFTs in the contract. A landlord can trigger this by reducing their locked-plot value below the staked `plotId` without updating `lastUpdated`.",
        "Recommendation": "",
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 56
    },
    {
        "Issue": "Staking on unregistered landlord can permanently trap NFTs",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `stakeMunchable`:\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    // Missing check for landlord registration\n    if (landlord == mainAccount) revert CantStakeToSelfError();\n    if (plotOccupied[landlord][plotId].occupied)\n        revert OccupiedPlotError(landlord, plotId);\n    // ...\n    munchNFT.transferFrom(mainAccount, address(this), tokenId);\n    // ...\n}\n```\n\nThe function does not verify that the `landlord` address is registered in the `accountManager`. Later, every call guarded by `forceFarmPlots` (including `unstakeMunchable`) invokes `_farmPlots`, which calls `_getMainAccountRequireRegistered(landlord)` and will always revert for an unregistered landlord. Therefore, a user can stake a munchable on an unregistered landlord and then be unable to unstake it, permanently locking their NFT in the contract.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 57
    },
    {
        "Issue": "Signed integer conversion in reward calculation can revert due to negative bonus, causing DoS and trapping NFTs",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `_farmPlots`:\n\n```solidity\nschnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) + (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nBecause `finalBonus` (derived from `REALM_BONUSES` and `RARITY_BONUSES`) can be negative, the intermediate signed value inside the `uint256` conversion can be negative. Under Solidity 0.8, converting a negative `int256` to `uint256` reverts. Since `_farmPlots` is invoked via the `forceFarmPlots` modifier in `unstakeMunchable`, any negative-bonus scenario will revert the entire call and permanently lock the NFT in the contract.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 58
    },
    {
        "Issue": "Missing validation for registered landlord leads to NFT lock-up",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The function `stakeMunchable` allows staking a munchable NFT to any address with available plots, but never checks that the `landlord` is a registered player (i.e. has account metadata). Later, all state\u2010changing functions (including `unstakeMunchable` and `farmPlots`) use `forceFarmPlots`, which calls `_farmPlots(_sender)` and internally calls `_getMainAccountRequireRegistered(landlord)`. If `landlord` is unregistered, `_getMainAccountRequireRegistered` will revert, aborting the entire farming or unstaking process. For example:\n\n```solidity\nfunction stakeMunchable(address landlord, uint256 tokenId, uint256 plotId) external {\n    // no check that plotMetadata[landlord].lastUpdated != 0 or that landlord is registered\n    munchNFT.transferFrom(msg.sender, address(this), tokenId);\n    // state is updated to record the stake\n}\n\nfunction unstakeMunchable(uint256 tokenId) external forceFarmPlots(msg.sender) {\n    // forceFarmPlots will call _farmPlots(msg.sender)\n    // inside _farmPlots, for each toiler:\n    (, Player memory landlordMetadata) = _getMainAccountRequireRegistered(landlord);\n    // this reverts if landlord has registrationDate == 0\n    // so unstakeMunchable never reaches the code that returns the NFT\n}\n```\n\nAn attacker or even an end user could deliberately (or accidentally via a buggy UI) stake a munchable to an unregistered landlord address that has available plots, irreversibly locking the NFT inside the contract because any subsequent call to unstake or farm will revert.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 59
    },
    {
        "Issue": "Reentrancy vulnerability allows bypass of staking limits and occupancy checks",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "Several core functions in LandManager make external calls before updating internal state and have no reentrancy guard. For example, in stakeMunchable:\n\n```solidity\nfunction stakeMunchable(address landlord, uint256 tokenId, uint256 plotId)\n    external\n    forceFarmPlots(msg.sender)\n    notPaused\n{\n    // \u2026 validation checks \u2026\n    munchNFT.transferFrom(mainAccount, address(this), tokenId);\n    // only now do we update state:\n    plotOccupied[landlord][plotId] = Plot({occupied: true, tokenId: tokenId});\n    munchablesStaked[mainAccount].push(tokenId);\n    munchableOwner[tokenId] = mainAccount;\n    toilerState[tokenId] = \u2026;\n    emit FarmPlotTaken(toilerState[tokenId], tokenId);\n}\n```\n\nBecause transferFrom is an external call and no nonReentrant modifier is used, a malicious ERC-721 implementation (or a malicious accountManager callback in _farmPlots) can reenter back into stakeMunchable, unstakeMunchable, transferToUnoccupiedPlot, or farmPlots, all of which mutate shared state. An attacker could, for example, reenter and call stakeMunchable multiple times before munchablesStaked is updated, bypassing the 10-token limit, corrupting occupancy mappings, stealing or permanently locking other users' tokens, or inflating rewards.",
        "Recommendation": "",
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 60
    },
    {
        "Issue": "Off-by-one in off-plot detection allows perpetual farming of invalid plots",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `_farmPlots` the contract checks:\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n```\nThis wrongly uses `<` instead of `<=`. If a landlord's available plots is reduced to exactly the munchable's `plotId` (e.g., by withdrawing or expiring locked funds), the condition is false and the munchable is never marked `dirty`. As a result, a munchable staked at that slot continues to earn rewards indefinitely on an invalid plot (even when `getNumPlots` becomes zero), enabling unlimited reward farming.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 61
    },
    {
        "Issue": "Arithmetic underflow in reward calculation via negative finalBonus",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `_farmPlots`, the reward calculation can underflow:\n\n```solidity\nint256 finalBonus = int16(REALM_BONUSES[...] ) + int16(int8(RARITY_BONUSES[...]));\nuint256 schnibblesTotal = (timestamp - _toiler.lastToilDate) * BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256((int256(schnibblesTotal) + int256(schnibblesTotal) * finalBonus) / 100);\n```\nIf `finalBonus` is \u2264 -100 (e.g., due to negative `REALM_BONUSES` entries or casting a large `RARITY_BONUSES` value into `int8`), the numerator becomes negative. Casting that negative `int256` to `uint256` underflows, resulting in a massive `schnibblesTotal`. An attacker controlling NFT attributes or relying on a malicious configuration can exploit this to mint unbounded schnibbles.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 62
    },
    {
        "Issue": "Misconfigured Tax Rate Bounds Allowing Arbitrary and Excessive Tax Rates",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "```solidity\nfunction _reconfigure() internal {\n    MIN_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.LockManager);\n    MAX_TAX_RATE = IConfigStorage(configStorage).getUint(StorageKey.AccountManager);\n}\n\nfunction updateTaxRate(uint256 newTaxRate) external override notPaused {\n    if (newTaxRate < MIN_TAX_RATE || newTaxRate > MAX_TAX_RATE)\n        revert InvalidTaxRateError();\n    plotMetadata[landlord].currentTaxRate = newTaxRate;\n}\n```\nBecause `MIN_TAX_RATE` and `MAX_TAX_RATE` are mistakenly loaded from config keys meant for contract addresses, landlords can set `newTaxRate` far outside the intended [0, 1e18] range (including >100%). This breaks the schnibble split calculation: when `latestTaxRate > 1e18`, `schnibblesLandlord = schnibblesTotal * latestTaxRate / 1e18` can exceed `schnibblesTotal`, causing underflow in `(schnibblesTotal - schnibblesLandlord)` and reverting `_farmPlots`. This results in a denial-of-service for tenants (farm, stake, and unstake always revert) and enables landlords to front-run and block or steal rewards.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 63
    },
    {
        "Issue": "Missing validation of DEFAULT_TAX_RATE allows out-of-bounds default tax",
        "Severity": "High",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "```solidity\nfunction _reconfigure() internal {\n    DEFAULT_TAX_RATE = IConfigStorage(configStorage).getUint(\n        StorageKey.ClaimManager\n    );\n    // ...\n}\n\nfunction triggerPlotMetadata() external override notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    plotMetadata[mainAccount] = PlotMetadata({\n        lastUpdated: block.timestamp,\n        currentTaxRate: DEFAULT_TAX_RATE\n    });\n    emit UpdatePlotsMeta(mainAccount);\n}\n```\nThe value `DEFAULT_TAX_RATE` is never checked against `MIN_TAX_RATE` or `MAX_TAX_RATE`. If `DEFAULT_TAX_RATE` is misconfigured (e.g., >1e18), newly initialized plots inherit an excessive tax rate. In `_farmPlots`, this causes:\n```solidity\nuint256 schnibblesLandlord = (schnibblesTotal * _toiler.latestTaxRate) / 1e18;\n// schnibblesLandlord > schnibblesTotal \u2192 underflow on (schnibblesTotal - schnibblesLandlord)\n```\nresulting in a revert and permanent denial-of-service for renters.",
        "Recommendation": "",
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 64
    },
    {
        "Issue": "Off-by-one error allows staking of 11 munchables instead of maximum 10",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In stakeMunchable:\n\n```solidity\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\n\nThis check only reverts when the current staked count is greater than 10, permitting the 11th munchable to be staked (length == 10 before push) and thus breaking the intended limit of 10 munchables per account.",
        "Recommendation": "",
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 65
    },
    {
        "Issue": "Missing validation of plot metadata initialization in stakeMunchable",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In stakeMunchable:\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    ...\n    // No check for plotMetadata[landlord].lastUpdated != 0\n    munchNFT.transferFrom(mainAccount, address(this), tokenId);\n    ...\n    toilerState[tokenId] = ToilerState({\n        lastToilDate: block.timestamp,\n        plotId: plotId,\n        landlord: landlord,\n        latestTaxRate: plotMetadata[landlord].currentTaxRate,\n        dirty: false\n    });\n    ...\n}\n```\n\nBecause `plotMetadata[landlord].lastUpdated` may be zero if the landlord has not initialized their metadata, `currentTaxRate` defaults to zero. Renters can stake munchables at a zero tax rate, collecting 100% of schnibbles and depriving landlords of intended revenue.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 66
    },
    {
        "Issue": "Off-by-One Error in Munchable Staking Limit Allows 11 Tokens",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function intends to limit each account to 10 staked munchables but uses the wrong comparison operator:\n\n```solidity\n// Should revert when length >= 10, but checks > 10\nif (munchablesStaked[mainAccount].length > 10)\n    revert TooManyStakedMunchiesError();\n```\n\nWhen `munchablesStaked[mainAccount].length` is exactly 10, the condition `10 > 10` is false, allowing an 11th token to be staked. This violates the invariant:\n\n```solidity\n// Invariant expects: munchablesStaked[mainAccount].length <= 10\nmunchablesStaked[mainAccount].length <= 10\n```\n\nBy staking an extra munchable beyond the intended cap, a user can occupy more plots and earn excessive rewards, undermining the protocol's design.",
        "Recommendation": "",
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 67
    },
    {
        "Issue": "Missing toilerState.plotId update in transferToUnoccupiedPlot leads to ghost plot occupancy",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In transferToUnoccupiedPlot the new plot assignment never updates the token's stored plotId. For example:\n\n```solidity\nfunction transferToUnoccupiedPlot(uint256 tokenId, uint256 plotId) external {\n    ToilerState memory _toiler = toilerState[tokenId];\n    uint256 oldPlotId = _toiler.plotId;\n    // ... validations ...\n    toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate;\n    // MISSING: toilerState[tokenId].plotId = plotId;\n    plotOccupied[_toiler.landlord][oldPlotId] = Plot({occupied:false, tokenId:0});\n    plotOccupied[_toiler.landlord][plotId]   = Plot({occupied:true,  tokenId:tokenId});\n}\n```\nBecause toilerState[tokenId].plotId remains the oldPlotId, calling unstakeMunchable(tokenId) only frees the original plot and leaves the newly occupied plot permanently marked as occupied. This ghost occupancy blocks that plot from ever being reused, causing a denial-of-service on land slots.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 68
    },
    {
        "Issue": "Incorrect update of toilerState.plotId in transferToUnoccupiedPlot leads to ghost occupancy and plot denial-of-service",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In `transferToUnoccupiedPlot` the code updates only the tax rate but never updates the stored `plotId` for the munchable:\n\n```solidity\nuint256 oldPlotId = _toiler.plotId;\n// ...\ntoilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate;\nplotOccupied[_toiler.landlord][oldPlotId] = Plot({ occupied: false, tokenId: 0 });\nplotOccupied[_toiler.landlord][plotId]      = Plot({ occupied: true, tokenId: tokenId });\n// missing: toilerState[tokenId].plotId = plotId\n```\nBecause `toilerState[tokenId].plotId` remains the original slot, every call to `transferToUnoccupiedPlot` clears only the initial slot and never removes occupancy from previously claimed slots. A malicious tenant can repeatedly transfer a single munchable across all available plot IDs and accumulate \"ghost\" occupancies, blocking all plots and preventing other renters from staking (denial-of-service).",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 69
    },
    {
        "Issue": "No high-risk vulnerabilities found in triggerPlotMetadata or associated logic",
        "Severity": "Info",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "After in-depth analysis, the triggerPlotMetadata function only allows a one-time initialization of plot metadata for a registered main account, sets no unexpected values, and emits an event. There are no direct value transfers, no reentrancy targets, and no bypasses that lead to theft or loss of funds. All checks (registration, one-time only, notPaused) function as intended, and any further tax-rate changes are bounded by MIN_TAX_RATE and MAX_TAX_RATE in updateTaxRate.",
        "Recommendation": null,
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 70
    },
    {
        "Issue": "No Cooldown on Tax Rate Changes",
        "Severity": "Best Practices",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "```solidity\nfunction updateTaxRate(uint256 newTaxRate) external override notPaused {\n    (address landlord, ) = _getMainAccountRequireRegistered(msg.sender);\n    if (newTaxRate < MIN_TAX_RATE || newTaxRate > MAX_TAX_RATE)\n        revert InvalidTaxRateError();\n    if (plotMetadata[landlord].lastUpdated == 0)\n        revert PlotMetadataNotUpdatedError();\n    uint256 oldTaxRate = plotMetadata[landlord].currentTaxRate;\n    plotMetadata[landlord].currentTaxRate = newTaxRate;\n    emit TaxRateChanged(landlord, oldTaxRate, newTaxRate);\n}\n```\nThe function permits landlords to adjust their plot's tax rate at any time without any enforced delay or cooldown. This allows rapid or front-running changes\u2014e.g., a landlord could observe a renter's pending farmPlots call, increase the tax rate to capture a larger schnibble share, then immediately revert it\u2014resulting in unpredictable economic outcomes and disadvantaging renters.",
        "Recommendation": "",
        "Detector": "multi_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 71
    },
    {
        "Issue": "Lack of validation for tokenId existence in stakeMunchable function",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function does not validate if the tokenId exists before attempting to stake it. While the function checks if the caller is the owner of the token using `munchNFT.ownerOf(tokenId)`, this check will revert if the token doesn't exist. However, this creates an unclear error message that doesn't properly indicate the issue to users.\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    if (landlord == mainAccount) revert CantStakeToSelfError();\n    if (plotOccupied[landlord][plotId].occupied)\n        revert OccupiedPlotError(landlord, plotId);\n    if (munchablesStaked[mainAccount].length > 10)\n        revert TooManyStakedMunchiesError();\n    if (munchNFT.ownerOf(tokenId) != mainAccount)\n        revert InvalidOwnerError();\n    // ...\n}\n```\n\nIf a user attempts to stake a non-existent token, the transaction will revert with a generic ERC721 error rather than a specific error message from the contract. This can lead to confusion for users and potential support issues.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 72
    },
    {
        "Issue": "Unbounded array growth in munchablesStaked mapping",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function allows users to stake munchables, which are stored in the `munchablesStaked` mapping. While there is a check to ensure that a user doesn't stake more than 10 munchables, this check can be bypassed by unstaking and restaking munchables.\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    // ...\n    if (munchablesStaked[mainAccount].length > 10)\n        revert TooManyStakedMunchiesError();\n    // ...\n    munchablesStaked[mainAccount].push(tokenId);\n    // ...\n}\n```\n\nThe issue arises in the `_removeTokenIdFromStakedList` function, which is called during unstaking:\n\n```solidity\nfunction _removeTokenIdFromStakedList(\n    address mainAccount,\n    uint256 tokenId\n) internal {\n    uint256 stakedLength = munchablesStaked[mainAccount].length;\n    bool found = false;\n    for (uint256 i = 0; i < stakedLength; i++) {\n        if (munchablesStaked[mainAccount][i] == tokenId) {\n            munchablesStaked[mainAccount][i] = munchablesStaked[\n                mainAccount\n            ][stakedLength - 1];\n            found = true;\n            munchablesStaked[mainAccount].pop();\n            break;\n        }\n    }\n\n    if (!found) revert InvalidTokenIdError();\n}\n```\n\nA malicious user could repeatedly stake and unstake munchables, causing the `munchablesStaked` array to grow in size. While each individual operation is limited to 10 staked munchables at a time, there's no limit on how many times a user can perform these operations. This could lead to increased gas costs for legitimate users and potential denial of service if the array becomes too large to iterate through in the `_farmPlots` function.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 73
    },
    {
        "Issue": "Missing validation for zero address in stakeMunchable function",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `stakeMunchable` function does not validate if the landlord address is the zero address. This could lead to tokens being staked to the zero address, effectively locking them permanently.\n\n```solidity\nfunction stakeMunchable(\n    address landlord,\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    if (landlord == mainAccount) revert CantStakeToSelfError();\n    // No check for landlord == address(0)\n    // ...\n}\n```\n\nIf a user accidentally or maliciously provides the zero address as the landlord, the function will proceed to stake the munchable to this address. Since the zero address cannot perform any actions, the munchable would be permanently locked in the contract. This is particularly problematic because the `unstakeMunchable` function requires the original owner to call it, but the token would be associated with an address that cannot initiate transactions.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 74
    },
    {
        "Issue": "Potential integer overflow in _farmPlots function",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, there's a calculation that could potentially overflow, leading to incorrect schnibbles calculations:\n\n```solidity\nfinalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\n```\n\nThe issue is in the array index calculation: `(uint256(immutableAttributes.realm) * 5) + uint256(landlordMetadata.snuggeryRealm)`. If `immutableAttributes.realm` or `landlordMetadata.snuggeryRealm` are large enough, this calculation could result in an index that's out of bounds for the `REALM_BONUSES` array. This would cause the transaction to revert, preventing users from farming their plots.\n\nAdditionally, there's no validation that `immutableAttributes.rarity` is within the bounds of the `RARITY_BONUSES` array, which could also lead to an out-of-bounds access.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 75
    },
    {
        "Issue": "Incorrect dirty flag handling in _farmPlots function",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, there's a mechanism to handle the case where a plot ID no longer fits within the landlord's available plots. This is done by setting a `dirty` flag and using the last updated plot metadata time instead of the current time:\n\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n```\n\nHowever, once a toiler state is marked as dirty, it's skipped in all future farming operations:\n\n```solidity\nfor (uint8 i = 0; i < staked.length; i++) {\n    timestamp = block.timestamp;\n    tokenId = staked[i];\n    _toiler = toilerState[tokenId];\n    if (_toiler.dirty) continue;\n    // ...\n}\n```\n\nThis means that if a landlord reduces their locked value (reducing the number of available plots) and then later increases it again, any munchables that were staked on plots that temporarily became unavailable will be permanently marked as dirty and will never be farmed again. This could lead to a loss of rewards for users who have staked munchables on these plots.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 76
    },
    {
        "Issue": "Potential for stale tax rates in _farmPlots function",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, the tax rate used for calculating schnibbles is the one stored in the toiler state, which is only updated when the munchable is staked or when farming occurs:\n\n```solidity\nschnibblesLandlord =\n    (schnibblesTotal * _toiler.latestTaxRate) /\n    1e18;\n\ntoilerState[tokenId].lastToilDate = timestamp;\ntoilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]\n    .currentTaxRate;\n```\n\nThis means that if a landlord changes their tax rate, the new rate will only apply to munchables that are farmed after the change. If a munchable hasn't been farmed for a long time, it will continue to use the old tax rate until it's farmed again. This could lead to inconsistencies where some munchables are using the new tax rate while others are still using the old one, potentially causing confusion for users.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 77
    },
    {
        "Issue": "Lack of validation for plotId in transferToUnoccupiedPlot function",
        "Severity": "Low",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `transferToUnoccupiedPlot` function allows users to transfer their staked munchable to a different plot. However, it doesn't validate that the new plot ID is different from the current one:\n\n```solidity\nfunction transferToUnoccupiedPlot(\n    uint256 tokenId,\n    uint256 plotId\n) external override forceFarmPlots(msg.sender) notPaused {\n    (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n    ToilerState memory _toiler = toilerState[tokenId];\n    uint256 oldPlotId = _toiler.plotId;\n    uint256 totalPlotsAvail = _getNumPlots(_toiler.landlord);\n    if (_toiler.landlord == address(0)) revert NotStakedError();\n    if (munchableOwner[tokenId] != mainAccount) revert InvalidOwnerError();\n    if (plotOccupied[_toiler.landlord][plotId].occupied)\n        revert OccupiedPlotError(_toiler.landlord, plotId);\n    if (plotId >= totalPlotsAvail) revert PlotTooHighError();\n    // No check for plotId == oldPlotId\n    // ...\n}\n```\n\nIf a user attempts to transfer a munchable to the same plot it's already on, the function will proceed with the transfer, which will emit misleading events indicating that the munchable has left one plot and entered another, when in reality it hasn't moved. This could cause confusion for users and for any systems that rely on these events.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 78
    },
    {
        "Issue": "No Slippage Parameter in Schnibbles Calculation",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_farmPlots` function calculates schnibbles rewards without any slippage protection. When a user farms their plots, the function calculates rewards based on the time elapsed and various bonuses, but there is no minimum amount check to ensure users receive at least a certain amount of rewards.\n\n```solidity\nschnibblesTotal =\n    (timestamp - _toiler.lastToilDate) *\n    BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) +\n        (int256(schnibblesTotal) * finalBonus)) / 100\n);\nschnibblesLandlord =\n    (schnibblesTotal * _toiler.latestTaxRate) /\n    1e18;\n\ntoilerState[tokenId].lastToilDate = timestamp;\ntoilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]\n    .currentTaxRate;\n\nrenterMetadata.unfedSchnibbles += (schnibblesTotal -\n    schnibblesLandlord);\n\nlandlordMetadata.unfedSchnibbles += schnibblesLandlord;\n```\n\nThis is problematic because the landlord can update their tax rate right before a user farms their plots, potentially taking a much larger percentage of the rewards than expected. Since there's no slippage protection, users have no way to specify a minimum amount of rewards they expect to receive, and the transaction will succeed even if they receive significantly less than anticipated due to a last-minute tax rate change.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 79
    },
    {
        "Issue": "No Expiration Deadline for Tax Rate Changes",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `updateTaxRate` function allows landlords to change their tax rate without any deadline parameter. This means that transactions to update tax rates can sit in the mempool for an extended period and be executed at a potentially unfavorable time for toilers (users who have staked munchables on the landlord's plots).\n\n```solidity\nfunction updateTaxRate(uint256 newTaxRate) external override notPaused {\n    (address landlord, ) = _getMainAccountRequireRegistered(msg.sender);\n    if (newTaxRate < MIN_TAX_RATE || newTaxRate > MAX_TAX_RATE)\n        revert InvalidTaxRateError();\n    if (plotMetadata[landlord].lastUpdated == 0)\n        revert PlotMetadataNotUpdatedError();\n    uint256 oldTaxRate = plotMetadata[landlord].currentTaxRate;\n    plotMetadata[landlord].currentTaxRate = newTaxRate;\n    emit TaxRateChanged(landlord, oldTaxRate, newTaxRate);\n}\n```\n\nWithout a deadline parameter, a transaction to update the tax rate could be executed at a time when it would be most disadvantageous to toilers, such as right before they farm their plots. This could result in toilers receiving significantly fewer rewards than expected.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 80
    },
    {
        "Issue": "Incorrect Slippage Calculation in Schnibbles Distribution",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, the calculation of schnibbles distribution between landlord and renter uses the tax rate stored at the time of staking (`_toiler.latestTaxRate`) rather than the current tax rate. This creates a situation where the actual slippage protection is based on outdated information.\n\n```solidity\nschnibblesLandlord =\n    (schnibblesTotal * _toiler.latestTaxRate) /\n    1e18;\n\ntoilerState[tokenId].lastToilDate = timestamp;\ntoilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]\n    .currentTaxRate;\n\nrenterMetadata.unfedSchnibbles += (schnibblesTotal -\n    schnibblesLandlord);\n\nlandlordMetadata.unfedSchnibbles += schnibblesLandlord;\n```\n\nThe issue is that the function first calculates the landlord's share using the old tax rate (`_toiler.latestTaxRate`), then updates the stored tax rate to the current one (`plotMetadata[_toiler.landlord].currentTaxRate`). This means that if a landlord changes their tax rate, it won't affect existing stakers until they farm their plots, at which point the new rate will be stored for the next farming operation. This creates an inconsistency where users might expect the current tax rate to apply immediately to all farming operations.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 81
    },
    {
        "Issue": "Mismatched Slippage Precision in Schnibbles Calculation",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "The `_farmPlots` function contains a precision issue in the calculation of schnibbles rewards. The function first calculates the total schnibbles with a division by 100, and then calculates the landlord's share with a division by 1e18, which represents a significant mismatch in precision.\n\n```solidity\nschnibblesTotal =\n    (timestamp - _toiler.lastToilDate) *\n    BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) +\n        (int256(schnibblesTotal) * finalBonus)) / 100\n);\nschnibblesLandlord =\n    (schnibblesTotal * _toiler.latestTaxRate) /\n    1e18;\n```\n\nThe issue is that the finalBonus is applied with a division by 100, suggesting it's a percentage value, while the tax rate is applied with a division by 1e18, suggesting it's a value with 18 decimal places. This mismatch in precision could lead to unexpected results, especially for small values of schnibbles or when the tax rate is very low. It could also lead to precision loss if the tax rate is not properly scaled.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 82
    },
    {
        "Issue": "No Oracle Implementation Found",
        "Severity": "Info",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "After analyzing the provided smart contract, no oracle implementation was found. The contract does not interact with any price feeds or oracle services like Chainlink, Pyth, or other oracle providers. The contract primarily manages land plots, staking of NFTs, and schnibble farming mechanics without relying on external price data.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 83
    },
    {
        "Issue": "Division Before Multiplication in Schnibbles Calculation",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, there is a division before multiplication when calculating the final schnibbles amount, which can lead to precision loss:\n\n```solidity\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) +\n        (int256(schnibblesTotal) * finalBonus)) / 100\n);\n```\n\nThe calculation divides by 100 before the result is used in subsequent calculations. This division truncates any remainder, causing precision loss. If `finalBonus` is small or `schnibblesTotal` is not a multiple of 100, the calculation will lose precision.\n\nFor example, if `schnibblesTotal` is 199 and `finalBonus` is 1, the calculation would be:\n`(199 + (199 * 1)) / 100 = (199 + 199) / 100 = 398 / 100 = 3`\n\nThe correct approach would be to perform the division after all multiplications:\n`199 + ((199 * 1) / 100) = 199 + 1 = 200`\n\nThis precision loss affects the rewards distributed to both landlords and renters, potentially leading to users receiving fewer schnibbles than they should.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 84
    },
    {
        "Issue": "Division Before Multiplication in Landlord Schnibbles Calculation",
        "Severity": "Medium",
        "Contracts": [
            "LandManager.sol"
        ],
        "Description": "In the `_farmPlots` function, there is another instance of division before multiplication when calculating the landlord's share of schnibbles:\n\n```solidity\nschnibblesLandlord =\n    (schnibblesTotal * _toiler.latestTaxRate) /\n    1e18;\n```\n\nThe tax rate is a percentage value stored with 18 decimal places (1e18 precision). When calculating the landlord's share, the function first multiplies `schnibblesTotal` by the tax rate and then divides by 1e18. If `schnibblesTotal` is small enough, this division can result in significant precision loss or even round down to zero.\n\nFor example, if `schnibblesTotal` is 1000 and `_toiler.latestTaxRate` is 0.1e18 (10%), the calculation would be:\n`(1000 * 0.1e18) / 1e18 = 100`\n\nHowever, if `schnibblesTotal` is very small (e.g., 9) and `_toiler.latestTaxRate` is 0.1e18 (10%), the calculation would be:\n`(9 * 0.1e18) / 1e18 = 0`\n\nThis means the landlord would receive 0 schnibbles even though they should receive 0.9 schnibbles (which would round down to 0 in integer arithmetic). This precision loss can accumulate over time, especially for landlords with many plots and small schnibble generation rates.",
        "Recommendation": "",
        "Detector": "specialized_agents",
        "Mitigation": null,
        "CounterArgument": null,
        "Justification": null,
        "index": 85
    }
]