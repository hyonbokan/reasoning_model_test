| # | **Broad Class** | Merges / Covers | Typical Triggers & Heuristics | Example issues (from *backd* set) |
|---|-----------------|-----------------|--------------------------------|-----------------------------------|
| **1** | **Init-State Bugs** | INIT-UNINIT · RE-INIT · FIRST-MOVER (default-0 exploits) | • critical vars never set (stay 0) <br>• `initialize()` callable twice <br>• logic that assumes non-zero “lastEvent” etc. | #1 startInflation bypass · #10 poolLastUpdate=0 · #15 BkdLocker re-init |
| **2** | **Accounting / Checkpoint Drift** | TIME-DRIFT · ORDER-BUG · VIEW-MISMATCH | • tokenomics that rely on `checkpoint()`; skipped or wrong order mutates integrals <br>• view funcs use stale values <br>• weight update before checkpoint | #2 non-deterministic supply · #4/#5 first-staker unfair shares · #6 weight update bug · #8 decay before checkpoint · #11 inconsistent view |
| **3** | **Math & Preconditions** | ARITH-ZERODIV · generic arithmetic faults (overflow if <0.8, cast, unchecked) | • denominator may be 0 <br>• unchecked math blocks <br>• unsafe cast / scaling errors | #3 division-by-zero DoS |
| **4** | **Reward-Manipulation** | FLASH-REWARD · STRAT-BY-PASS · FIRST-MOVER (reward skew) | • stake/unstake right before fee surge <br>• strategies mis-classified and earn rewards <br>• reward integral sensitive to timing | #4 1-wei stake controls shares · #7 depositFees frontrun · #16 strategy reward steal |
| **5** | **External-Interaction / Oracle Failure** | ORACLE-FALLBACK plus unsafe external-call slippage | • fallback to `minOut = 0` when oracle fails <br>• unchecked `price == 0` branches | #9 FeeBurner swap without slippage |
| **6** | **Admin & Dependency Risks** | CENTRAL-RUG · DEPN-ORPHAN · FUNDS-STUCK | • single-EOA or owner can upgrade / drain <br>• removing gauge/pool breaks callers (DoS) <br>• delisted pool leaves assets stuck | #12 rug vectors · #14 keeperGauge removal DoS · #17 fees stuck |
| **7** | **State-Integrity / Invariant Violation** | In-memory or storage fields that must evolve **atomically** drift apart, breaking one-to-one relationships or flags that gate behaviour.<br><br>Heuristics:  <br>• multiple mappings/structs updated, but one field omitted  <br>• “dirty” or “occupied” flag not reset  <br>• invariant *“at most one occupier per slot”* violated  | • Single plot occupied by multiple renters (plotId not updated)  <br>• `transferToUnoccupiedPlot` doesn’t clear `dirty` flag |
| **8** | **Allowance / Authorization Misuse** | Users (or the contract) leave **ERC-20/ERC-721 approvals** in place so the contract can move assets after intent expires; or boundary checks on counts/limits are off-by-one.<br><br>Heuristics:  <br>• lingering `isApprovedForAll` / `getApproved` relied upon without re-verification  <br>• stake/withdraw limit uses `>` instead of `≥` (off-by-one) | • Lingering token approvals enable unwanted staking  <br>• Max-10 stake check allows 11 tokens |
| **9** | **Signature / Replay-Protection Failures** | Signed messages are accepted on the wrong chain or with missing domain fields; artist/royalty settings can be hijacked by re-using someone else’s ECDSA proof. <br><br>Heuristics: missing `chainId` / salt in hash, signature not bound to caller or parameters. | • *signatureClaim* replay across chains <br>• `createArt` replay to change royalties |
| **10** | **Re-Entrancy / Cool-Down Bypass** | Classic or cross-function re-entrancy lets an attacker violate temporal-logic (cool-down, lock) or skim rewards via flash-loan. <br><br>Heuristics: external call before sensitive state update, missing `nonReentrant`, re-entrancy used to sidestep a `lastTradeTimestamp`. | • Flash-loan sell after `buyShareCred` refund callback |
| **11** | **Access-Control & Pausing Lapses** | Functions that should be gated (`onlyOwner`, `whenNotPaused`) are callable by anyone; internal helpers exposed publicly. <br><br>Heuristics: critical state-mutating func has no modifier **and** is in public API; pause modifier absent/ineffective. | • Public `_addCredIdPerAddress` / `_removeCredIdPerAddress` <br>• `updateArtSettings` callable while paused <br>• `PhiNFT1155` pause ineffective |
| **12** | **Economic Parameters / Fee Mis-configuration** | Fixed-value “fees” treated as *percent*, refunds sent to wrong sender, setters capped at wrong units, creator royalty rounding to zero. <br><br>Heuristics: fee setters treat bps as absolute, refund uses `msg.sender` that can be a proxy, multiplication before division truncates to 0 for low-dec tokens. | • `setProtocolFee` stuck at 10 000 wei <br>• Over-payment refund goes to factory contract <br>• Royalty rounds down to 0 on low-decimals |
| **13** | **Gas / Storage-Growth Denial-of-Service** | Unbounded `EnumerableMap` or loop over ever-growing arrays makes core functions revert once item count is high enough. <br><br>Heuristics: `for (i=0; i<map.length(); i++)` on user-insertable map without deletion, or deletion sets value to 0 instead of removing key. | • `shareBalance` map bloats beyond ~4 000 → rewards cannot be distributed |
|---|---------------|----------------------------|------------------|
| **14** | **Cross-Chain / Bridge Idempotency & Replay Faults** | Contracts that rely on LayerZero (or similar) messages fail to mark them *consumed* on the first attempt → a retried or duplicated message mints / releases the same asset twice. Also covers max-bridge limits being ignored. <br><br>Heuristics: `lzReceive` / `retryMessage` logic without “processed” flag, missing `maxBridge` check, duplicate NFT IDs across chains. | • *GovNFT*: failure path lets the same tokenId mint on chains A & B <br>• `maxBridge` variable never enforced |