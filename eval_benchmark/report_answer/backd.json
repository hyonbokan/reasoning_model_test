[
  {
    "Issue": "Minter.sol#startInflation() can be bypassed.",
    "Severity": "High",
    "Description": "\n\n```solidity\nfunction startInflation() external override onlyGovernance {\n        require(lastEvent == 0, \"Inflation has already started.\");\n        lastEvent = block.timestamp;\n        lastInflationDecay = block.timestamp;\n    }\n```\n\nAs lastEvent and lastInflationDecay are not initialized in the constructor(), they will remain to the default value of 0.\n\nHowever, the permissionless executeInflationRateUpdate() method does not check the value of lastEvent and lastInflationDecay and used them directly.\n\nAs a result, if `executeInflationRateUpdate()` is called before `startInflation()`:\nthe check of if `_INFLATION_DECAY_PERIOD` has passed since `lastInflationDecay` will be true, and `initialPeriodEnded` will be set to true right away;\n\nsince the lastEvent in `totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));` is 0, the `totalAvailableToNow` will be set to `totalAvailableToNow ≈ currentTotalInflation * 52 years`, which renders the constrains of totalAvailableToNow incorrect and useless.\n\n````solidity\nfunction executeInflationRateUpdate() external override returns (bool) {\n        return _executeInflationRateUpdate();\n    }\n\n function _executeInflationRateUpdate() internal returns (bool) {\n        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n        lastEvent = block.timestamp;\n        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n            if (initialPeriodEnded) {\n                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                    annualInflationDecayKeeper\n                );\n                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                    annualInflationDecayAmm\n                );\n            } else {\n                currentInflationAmountKeeper =\n                    initialAnnualInflationRateKeeper /\n                    _INFLATION_DECAY_PERIOD;\n\n                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n                initialPeriodEnded = true;\n            }\n            currentTotalInflation =\n                currentInflationAmountLp +\n                currentInflationAmountKeeper +\n                currentInflationAmountAmm;\n            controller.inflationManager().checkpointAllGauges();\n            lastInflationDecay = block.timestamp;\n        }\n        return true;\n    }\n\n    // Used for final safety check to ensure inflation is not exceeded\n    uint256 public totalAvailableToNow;\n\n    function _mint(address beneficiary, uint256 amount) internal returns (bool) {\n        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);\n        uint256 newTotalMintedToNow = totalMintedToNow + amount;\n        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n        totalMintedToNow = newTotalMintedToNow;\n        lastEvent = block.timestamp;\n        token.mint(beneficiary, amount);\n        _executeInflationRateUpdate();\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/Minter.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Total Supply is not guaranteed and is not deterministic.",
    "Severity": "High",
    "Description": "The actual total supply of the token is random and depends on when _executeInflationRateUpdate is executed.\n\nThe README and tokenomic documentation clearly states that “The token supply is limited to a total of 268435456 tokens.” However when executing _executeInflationRateUpdate, it first uses the current inflation rate to update the total available before checking if it needs to be reduced.\n\nTherefore if no one mints or calls executeInflationRateUpdate for some time around the decay point, the inflation will be updated using the previous rate so the totalAvailableToNow will grow too much.",
    "Contract": [""],
    "Recommendation": ""
  },
  {
    "Issue": "DoS on KeeperGauge due to division by zero",
    "Severity": "Medium",
    "Description": "In the `_calcTotalClaimable()` function it should be validated that `perPeriodTotalFees[i] != 0` since otherwise it would generate a DoS in claimableRewards() and claimRewards().\nThis would be possible since if advanceEpoch() or kill() is executed by the InflationManager address, the epoch will go up without perPeriodTotalFees[newIndexEpoch] is 0.\nThe negative of this is that every time the InflationManager executes these two methods (kill() and advanceEpoch()) DoS is generated until you run reportFees().\nAnother possible case is that kill() or advanceEpoch() are executed 2 times in a row and there is no way of a perPeriodTotalFees[epoch-1] updating its value, therefore it would be an irreversible DoS.\n\n```solidity\n    function _calcTotalClaimable(\n        address beneficiary,\n        uint256 startEpoch,\n        uint256 endEpoch\n    ) internal view returns (uint256) {\n        uint256 totalClaimable;\n        for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {\n            totalClaimable += (\n                keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])\n            ).scaledMul(perPeriodTotalInflation[i]);\n        }\n        return totalClaimable;\n    }\n}\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/KeeperGauge.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "The first AMM Staker will have control over how the shares are calculated.",
    "Severity": "Medium",
    "Description": "The first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The reasons of this are related on how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero). The origin of this vulnerability relies on the evaluation of the totalStaked variable on its inception.\n\nTo illustrate this attack an environment of testing was made in order to track the token flows and how the variables are being updated and read.\n\nThe initial or border conditions taken into account are the same as the used by the team to perform the tests and just a few assumptions and simplifications were taken.\n\nThe inflation rate is fixed for simplicity (0.001). This is valid within a short period of time because it is not a function of how the tokens are distributed or their flows. By tracking how the inflation rate is calculated an updated, we see that it is managed by the currentInflationAmountAmm within the Minter.sol contract, which value is modified by _executeInflationRateUpdate() three lines below the last code permalink. Its value depends on non-token balance related parameters (such as inflation decays and annual rates).\nFor the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment.\nThe controller is not used because it is used to retrieve the inflation rate and it is now fixed because of 1).\nEach user state is updated whenever he calls either stake, unstake or claimRewards.\n\n**Steps:**\n\nAlice is the first staker and deposits 1wei worth of DummyERC20.\nBob takes one day to find out this new protocol and decides to stake 10 ETH amount of tokens (10 * 10**decimals()).\nAlice, who was scanning the mempool, frontruns Bob with the same amount he was willing to stake. Her txn is mined first.\nThen Bobs' transaction is mined for the 10 ETH worth.\nSometime after this, the pool is checkpointed.\nA few days pass, and Bob wants to stake even more tokens. The same amount as before.\nAlice frontruns him again updating her shares.\nBobs' transaction is mined and his shares are also updated.\nThe pool is checkpointed again. And Alice managed to increase considerably her amount of shares.\nBoth cases were evaluated (with and without staking 1 wei first). The attack scenario outputs a 100% more shares to Alice than Bob in comparison with the ethical/non-attack situation.\n\n```solidity\nfunction poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (totalStaked > 0) {\n            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n        }\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    function _userCheckpoint(address user) internal virtual returns (bool) {\n        poolCheckpoint();\n        perUserShare[user] += balances[user].scaledMul(\n            ammStakedIntegral - perUserStakedIntegral[user]\n        );\n        perUserStakedIntegral[user] = ammStakedIntegral;\n        return true;\n    }\n}\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/AmmGauge.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "The first AMM Staker may not receive according rewards because of poor checkpoints",
    "Severity": "Medium",
    "Description": "The first staker within the AmmGauge may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.\n\n\nA testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.\n\nThe inflation rate is fixed for simplicity (0.001).\nFor the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment.\nThe minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the _executeInflationRateUpdate call. Not while staking.\nIn order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.\n\n**Vulnerable Situation:**\n\nAlice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake.\nThey all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David.\nThere is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes).\nSometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.\nNon Vulnerable Situation:\n\nThe same as before but calling externally _poolCheckpoint() between Alice stake call and Bobs' and before checking the accumulated rewards.\nThe code to show this has a secureCheckpoints toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.\n\n```solidity\nfunction claimRewards(address beneficiary) external virtual override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        controller.inflationManager().mintRewards(beneficiary, amount);\n        emit RewardClaimed(beneficiary, amount);\n        return amount;\n    }\n\nfunction poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (totalStaked > 0) {\n            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n        }\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/AmmGauge.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Amount distributed can be inaccurate when updating weights",
    "Severity": "Medium",
    "Description": "When updating pool inflation rates, other pools see their currentRate being modified without having poolCheckpoint called, which leads to false computations. This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the totalAvailableToNow requirement in Minter \n\n```solidity \n require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n\nfunction _executeLpPoolWeight(\n        bytes32 key,\n        address lpToken,\n        address stakerVault,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IStakerVault(stakerVault).poolCheckpoint();\n        totalLpPoolWeight = totalLpPoolWeight - currentUInts256[key] + pendingUInts256[key];\n        totalLpPoolWeight = totalLpPoolWeight > 0 ? totalLpPoolWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        emit NewLpWeight(lpToken, currentUInts256[key]);\n        return true;\n    }\n\n    function _executeAmmTokenWeight(\n        address token,\n        bytes32 key,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IAmmGauge(_ammGauges.get(token)).poolCheckpoint();\n        totalAmmTokenWeight = totalAmmTokenWeight - currentUInts256[key] + pendingUInts256[key];\n        totalAmmTokenWeight = totalAmmTokenWeight > 0 ? totalAmmTokenWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        // Do pool checkpoint to update the pool integrals\n        emit NewAmmTokenWeight(token, currentUInts256[key]);\n        return true;\n    }\n\n    function _executeKeeperPoolWeight(\n        bytes32 key,\n        address pool,\n        bool isWeightManager\n    ) internal returns (bool) {\n        IKeeperGauge(_keeperGauges.get(pool)).poolCheckpoint();\n        totalKeeperPoolWeight = totalKeeperPoolWeight - currentUInts256[key] + pendingUInts256[key];\n        totalKeeperPoolWeight = totalKeeperPoolWeight > 0 ? totalKeeperPoolWeight : 0;\n        isWeightManager ? _setConfig(key, pendingUInts256[key]) : _executeUInt256(key);\n        emit NewKeeperWeight(pool, currentUInts256[key]);\n        return true;\n    }\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/InflationManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "BkdLocker#depositFees() can be front run to steal the newly added rewardToken",
    "Severity": "Medium",
    "Description": "Every time the BkdLocker#depositFees() gets called, there will be a surge of rewards per locked token for the existing stakeholders.\n\nThis enables a well-known attack vector, in which the attacker will take a large portion of the shares before the surge, then claim the rewards and exit immediately.\n\nWhile the _WITHDRAW_DELAY can be set longer to mitigate this issue in the current implementation, it is possible for the admin to configure it to a very short period of time or even 0.\n\nIn which case, the attack will be very practical and effectively steal the major part of the newly added rewards.\n\n```solidity\n    function depositFees(uint256 amount) external override {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(totalLockedBoosted > 0, Error.NOT_ENOUGH_FUNDS);\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];\n\n        curRewardTokenData.feeIntegral += amount.scaledDiv(totalLockedBoosted);\n        curRewardTokenData.feeBalance += amount;\n        emit FeesDeposited(amount);\n    }\n```\n\n",
    "Contract": ["protocol/contracts/BkdLocker.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Minter.sol#_executeInflationRateUpdate() inflationManager().checkpointAllGauges() is called after InflationRate is updated, causing users to lose rewards",
    "Severity": "Medium",
    "Description": "When `Minter.sol#_executeInflationRateUpdate()` is called, if an `_INFLATION_DECAY_PERIOD` has past since lastInflationDecay, it will update the InflationRate for all of the gauges.\n\nHowever, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using inflationManager().checkpointAllGauges().\n\nIf the _INFLATION_DECAY_PERIOD has passed for a long time before Minter.sol#executeInflationRateUpdate() is called, the users may lose a significant amount of rewards.\n\nOn a side note, totalAvailableToNow is updated correctly.\n\n```solidity\nfunction _executeInflationRateUpdate() internal returns (bool) {\n    totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n    lastEvent = block.timestamp;\n    if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n        currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n        if (initialPeriodEnded) {\n            currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                annualInflationDecayKeeper\n            );\n            currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                annualInflationDecayAmm\n            );\n        } else {\n            currentInflationAmountKeeper =\n                initialAnnualInflationRateKeeper /\n                _INFLATION_DECAY_PERIOD;\n\n            currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n            initialPeriodEnded = true;\n        }\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n        controller.inflationManager().checkpointAllGauges();\n        lastInflationDecay = block.timestamp;\n    }\n    return true;\n}\n\nfunction checkpointAllGauges() external override returns (bool) {\n    uint256 length = _keeperGauges.length();\n    for (uint256 i; i < length; i = i.uncheckedInc()) {\n        IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();\n    }\n    address[] memory stakerVaults = addressProvider.allStakerVaults();\n    for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {\n        IStakerVault(stakerVaults[i]).poolCheckpoint();\n    }\n\n    length = _ammGauges.length();\n    for (uint256 i; i < length; i = i.uncheckedInc()) {\n        IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();\n    }\n    return true;\n}\n\nfunction poolCheckpoint() public override returns (bool) {\n    if (killed) return false;\n    uint256 timeElapsed = block.timestamp - uint256(lastUpdated);\n    uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);\n    perPeriodTotalInflation[epoch] += currentRate * timeElapsed;\n    lastUpdated = uint48(block.timestamp);\n    return true;\n}\n\nfunction getKeeperRateForPool(address pool) external view override returns (uint256) {\n    if (minter == address(0)) {\n        return 0;\n    }\n    uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();\n    // After deactivation of weight based dist, KeeperGauge handles the splitting\n    if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;\n    if (totalKeeperPoolWeight == 0) return 0;\n    bytes32 key = _getKeeperGaugeKey(pool);\n    uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /\n        totalKeeperPoolWeight;\n    return poolInflationRate;\n}\n\n    function getKeeperInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountKeeper;\n    }\n```\n\n",
    "Contract": [
      "protocol/contracts/tokenomics/Minter.sol",
      "protocol/contracts/tokenomics/InflationManager.sol",
      "protocol/contracts/tokenomics/KeeperGauge.sol"
    ],
    "Recommendation": ""
  },
  {
    "Issue": "FeeBurner initiates swap without any slippage checks if Chainlink oracle fails",
    "Severity": "Medium",
    "Description": "While the SwapperRouter contract isn't explicitly in scope, it's a dependency of the FeeBurner contract which is in scope. So I think it's valid to make this submission.\n\nThe SwapperRouter contract uses the chainlink oracle to compute the minimum amount of tokens it should expect from the swap. The value is then used for the slippage check. But, if the chainlink oracle fails, for whatever reason, the contract uses 0 for the slippage check instead. Thus there's a scenario where swaps initiated by the FeeBurner contract can be sandwiched.\n\n```solidity\n  function burnToTarget(address[] memory tokens_, address targetLpToken_)\n        public\n        payable\n        override\n        returns (uint256 received)\n    {\n        require(tokens_.length != 0, \"No tokens to burn\");\n\n        // Swapping tokens for WETH\n        ILiquidityPool targetPool_ = _addressProvider.getPoolForToken(targetLpToken_);\n        address targetUnderlying_ = targetPool_.getUnderlying();\n        ISwapperRouter swapperRouter_ = _swapperRouter();\n        bool burningEth_;\n        for (uint256 i; i < tokens_.length; i = i.uncheckedInc()) {\n            IERC20 token_ = IERC20(tokens_[i]);\n\n            // Handling ETH\n            if (address(token_) == address(0)) {\n                if (msg.value == 0) continue;\n                burningEth_ = true;\n                swapperRouter_.swapAll{value: msg.value}(address(token_), _WETH);\n                continue;\n            }\n\n            // Handling ERC20\n            uint256 tokenBalance_ = token_.balanceOf(msg.sender);\n            if (tokenBalance_ == 0) continue;\n            token_.safeTransferFrom(msg.sender, address(this), tokenBalance_);\n            if (address(token_) == targetUnderlying_) continue;\n            _approve(address(token_), address(swapperRouter_));\n            swapperRouter_.swap(address(token_), _WETH, tokenBalance_);\n        }\n        require(burningEth_ || msg.value == 0, Error.INVALID_VALUE);\n\n        // Swapping WETH for target underlying\n        _approve(_WETH, address(swapperRouter_));\n        swapperRouter_.swapAll(_WETH, targetUnderlying_);\n\n        // Depositing target underlying into target pool\n        uint256 targetLpTokenBalance_ = _depositInPool(targetUnderlying_, targetPool_);\n\n        // Transfering LP tokens back to sender\n        IERC20(targetLpToken_).safeTransfer(msg.sender, targetLpTokenBalance_);\n        emit Burned(targetLpToken_, targetLpTokenBalance_);\n        return targetLpTokenBalance_;\n    }\n\n    function _minTokenAmountOut(uint256 wethAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        uint256 priceInEth_ = _getPriceInEth(token_);\n        if (priceInEth_ == 0) return 0;\n        return\n            wethAmount_.scaledDiv(priceInEth_).scaledMul(slippageTolerance).scaleTo(\n                IERC20Full(token_).decimals()\n            );\n    }\n\n\n    function _minWethAmountOut(uint256 tokenAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        uint256 priceInEth_ = _getPriceInEth(token_);\n        if (priceInEth_ == 0) return 0;\n        return\n            tokenAmount_.scaledMul(priceInEth_).scaledMul(slippageTolerance).scaleFrom(\n                IERC20Full(token_).decimals()\n            );\n    }\n```\n\n",
    "Contract": [
      "protocol/contracts/tokenomics/FeeBurner.sol",
      "protocol/contracts/swappers/SwapperRouter.sol"
    ],
    "Recommendation": ""
  },
  {
    "Issue": "Users can claim extremely large rewards or lock rewards from LpGauge due to uninitialised poolLastUpdate variable",
    "Severity": "Medium",
    "Description": "A user can claim all of the available governance tokens or prevent any rewards from being claimed in LpGauge.sol if sufficient time is left between deploying the contract and initialising it in the StakerVault.sol contract by calling initalizeLPGauge() OR if a new LPGauge contract is deployed and added to StakerVault using prepareLPGauge.\n\nInside LPGauge.sol when calling _poolCheckPoint(), the lastUpdated variable is not initalised so defaults to a value of 0, therefore if the user has managed to stake tokens in the StakerVault then the calculated poolStakedIntegral will be very large (as block.timestamp is very large). Therefore a user can mint most current available governance tokens for themselves when they claim their rewards (or prevent any governance tokens from being claimed).\n\n```solidity\n    function _poolCheckpoint() internal returns (bool) {\n        uint256 currentRate = inflationManager.getLpRateForStakerVault(address(stakerVault));\n        // Update the integral of total token supply for the pool\n        uint256 poolTotalStaked = stakerVault.getPoolTotalStaked();\n        if (poolTotalStaked > 0) {\n            poolStakedIntegral += (currentRate * (block.timestamp - poolLastUpdate)).scaledDiv(\n                poolTotalStaked\n            );\n        }\n        poolLastUpdate = block.timestamp;\n        return true;\n    }\n```\n\n \n\n```solidity\nfunction stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = addressProvider.getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/LpGauge.sol", "protocol/contracts/StakerVault.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "BkdLocker depositFees can be blocked",
    "Severity": "Medium",
    "Description": "burnFees will fail if none of the pool tokens have underlying token as native ETH token. This is shown below. Since burnFees fails so no fees is deposited in BKDLocker\n\nAssume RewardHandler.sol has currently amount 5 as address(this).balance (ethBalance) (even attacker can send a small balance to this contract to do this dos attack)\nNone of the pools have underlying as address(0) so no ETH tokens and only ERC20 tokens are present\nNow feeBurner.burnToTarget is called passing current ETH balance of amount 5 with all pool tokens\nfeeBurner loops through all tokens and swap them to WETH. Since none of the token is ETH so burningEth_ variable is false\nNow the below require condition fails since burningEth_ is false\nrequire(burningEth_ || msg.value == 0, Error.INVALID_VALUE);\nThis fails the burnFees function.\n\nfeeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken);",
    "Contract": ["protocol/contracts/RewardHandler.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "There are multiple ways for admins/governance to rug users",
    "Severity": "Medium",
    "Description": "Centralisation risks. A malicious admin can steal user funds or lock their balances forever. Even if the user is benevolent the fact that there is a rug vector available may negatively impact the protocol's reputation.",
    "Contract": [""],
    "Recommendation": ""
  },
  {
    "Issue": "Inconsistency in view functions can lead to users believing they're due for more BKD rewards",
    "Severity": "Medium",
    "Description": "Inconsistency in view functions can lead to users believing they're due for more BKD rewards\n\nThe view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y.\n\nIf the inflationRecipient is set, then poolStakedIntegral will be incremented in claimableRewards() but not in any other function like allClaimableRewards() or poolCheckpoint().\n\nIf a user calls claimableRewards() after the inflationRepient has been set, claimableRewards() will return a larger value than allClaimableRewards() or the amount actually returned by claimRewards().\n\n```solidity\nfunction claimableRewards(address user) external view virtual override returns (uint256) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (user == inflationRecipient) {\n            return\n                perUserShare[inflationRecipient] +\n                IController(controller).inflationManager().getAmmRateForToken(ammToken) *\n                timeElapsed;\n        }\n        if (!killed && totalStaked > 0) {\n            ammStakedIntegral_ +=\n                IController(controller).inflationManager().getAmmRateForToken(ammToken) *\n                timeElapsed.scaledDiv(totalStaked);\n        }\n        return\n            perUserShare[user] +\n            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n    }\n\n   function allClaimableRewards(address user) external view override returns (uint256[3] memory) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        uint256 crvStakedIntegral_ = crvStakedIntegral;\n        uint256 cvxStakedIntegral_ = cvxStakedIntegral;\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n\n        // This might lead to some inaccuracies in between poolCheckpoints if someone sends CRV\n        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) +\n            crvRewardsContract.earned(address(this)) -\n            _crvLastEarned;\n        uint256 cvxEarned = getCvxMintAmount(crvEarned);\n\n        if (!killed && totalStaked > 0) {\n            if (inflationRecipient == address(0)) {\n                ammStakedIntegral_ +=\n                    (IController(controller).inflationManager().getAmmRateForToken(ammToken)) *\n                    (timeElapsed).scaledDiv(totalStaked);\n            }\n            crvStakedIntegral_ += (crvEarned).scaledDiv(totalStaked);\n            cvxStakedIntegral_ += (cvxEarned).scaledDiv(totalStaked);\n        }\n        uint256 bkdRewards;\n        if (user == inflationRecipient) {\n            bkdRewards =\n                perUserShare[user] +\n                IController(controller).inflationManager().getAmmRateForToken(ammToken) *\n                timeElapsed;\n        } else {\n            bkdRewards =\n                perUserShare[user] +\n                balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n        }\n        uint256 crvRewards = perUserShareCrv[user] +\n            balances[user].scaledMul(crvStakedIntegral_ - perUserCrvStakedIntegral[user]);\n        uint256 cvxRewards = perUserShareCvx[user] +\n            balances[user].scaledMul(cvxStakedIntegral_ - perUserCvxStakedIntegral[user]);\n        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];\n        return allRewards;\n    }\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/AmmConvexGauge.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Potential DoS when removing keeper gauge",
    "Severity": "Medium",
    "Description": "When _removeKeeperGauge is called, there is no guarantee that the keeper gauge isn't currently in use by any TopUpActionFeeHandler. If it's still in use, any top up action executions will be disabled as reporting fees in KeeperGauge.sol will revert:\n\n```solidity \n function reportFees(\n    address beneficiary,\n    uint256 amount,\n    address lpTokenAddress\n) external override returns (bool) {\n    ...\n    require(!killed, Error.CONTRACT_PAUSED); // gauge is killed by InflationManager\n    ...\n    return true;\n}\n\n    function _removeKeeperGauge(address pool) internal {\n        address keeperGauge = _keeperGauges.get(pool);\n        bytes32 key = _getKeeperGaugeKey(pool);\n        _prepare(key, 0);\n        _executeKeeperPoolWeight(key, pool, true);\n        _keeperGauges.remove(pool);\n        IKeeperGauge(keeperGauge).kill();\n        // Do not delete from the gauges map to allow claiming of remaining balances\n        emit KeeperGaugeDelisted(pool, keeperGauge);\n    }\n\nfunction reportFees(\n        address beneficiary,\n        uint256 amount,\n        address lpTokenAddress\n    ) external override returns (bool) {\n        lpTokenAddress; // silencing compiler warning\n        require(\n            IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender),\n            Error.ADDRESS_NOT_WHITELISTED\n        );\n        require(!killed, Error.CONTRACT_PAUSED);\n        if (!keeperRecords[beneficiary].firstEpochSet) {\n            keeperRecords[beneficiary].firstEpochSet = true;\n            keeperRecords[beneficiary].nextEpochToClaim = epoch;\n        }\n        keeperRecords[beneficiary].feesInPeriod[epoch] += amount;\n        perPeriodTotalFees[epoch] += amount;\n        return true;\n    }\n\nfunction payFees(\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        address lpTokenAddress\n    ) external override returns (bool) {\n        require(msg.sender == actionContract, Error.UNAUTHORIZED_ACCESS);\n        // Handle keeper fees\n        uint256 keeperAmount = amount.scaledMul(getKeeperFeeFraction());\n        uint256 treasuryAmount = amount.scaledMul(getTreasuryFeeFraction());\n        LpToken lpToken = LpToken(lpTokenAddress);\n\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        address keeperGauge = getKeeperGauge(lpTokenAddress);\n        if (keeperGauge != address(0)) {\n            IKeeperGauge(keeperGauge).reportFees(beneficiary, keeperAmount, lpTokenAddress);\n        }\n\n        // Accrue keeper and treasury fees here for periodic claiming\n        keeperRecords[beneficiary][lpTokenAddress] += keeperAmount;\n        treasuryAmounts[lpTokenAddress] += treasuryAmount;\n\n        // Handle LP fees\n        uint256 lpAmount = amount - keeperAmount - treasuryAmount;\n        lpToken.burn(lpAmount);\n        emit FeesPayed(payer, beneficiary, lpTokenAddress, amount, keeperAmount, lpAmount);\n        return true;\n    }\n\nfunction _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n```\n\nIf this happened during extreme market movements, some positions that require a top up will not be executed and be in risk of being liquidated.\n\n",
    "Contract": [
      "protocol/contracts/tokenomics/InflationManager.sol",
      "protocol/contracts/tokenomics/KeeperGauge.sol",
      "protocol/contracts/actions/topup/TopUpActionFeeHandler.sol",
      "protocol/contracts/actions/topup/TopUpAction.sol"
    ],
    "Recommendation": ""
  },
  {
    "Issue": "it's possible to initialize contract BkdLocker for multiple times by sending startBoost=0 and each time different values for other parameters",
    "Severity": "Medium",
    "Description": "function initialize() of BkdLocker suppose to be called one time and contract initialize one time. but if it's called by startBoost=0 then it's possible to call it again with different values for other parameters. there are some logics based on the values function initilize() sets which is in calculating boost and withdraw delay. by initializing multiple times different users get different values for those logics and because rewards are distributed based on boosts so those logics will be wrong too.\n\nThis is initiliaze() code in BkdLocker:\n\n```solidity\n  function initialize(\n        uint256 startBoost,\n        uint256 maxBoost,\n        uint256 increasePeriod,\n        uint256 withdrawDelay\n    ) external override onlyGovernance {\n        require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);\n        _setConfig(_START_BOOST, startBoost);\n        _setConfig(_MAX_BOOST, maxBoost);\n        _setConfig(_INCREASE_PERIOD, increasePeriod);\n        _setConfig(_WITHDRAW_DELAY, withdrawDelay);\n    }\n```\n\nAs you can see it checks the initialization statue by currentUInts256[_START_BOOST]'s value but it's not correct way to do and initializer can set currentUInts256[_START_BOOST] value as 0 and set other parameters values and call this function multiple times with different values for _MAX_BOOST and _INCREASE_PERIOD and _WITHDRAW_DELAY. setting different values for those parameters can cause different calculation in computeNewBoost() and prepareUnlock(). function computeNewBoost() is used to calculate users boost parameters which is used on reward distribution. so by changing _MAX_BOOST the rewards will be distributed wrongly between old users and new users.\n\n",
    "Contract": ["protocol/contracts/BkdLocker.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards",
    "Severity": "Medium",
    "Description": "Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards.\nAlso there will be a problem with a rewarding system in LpGauge.sol so that some normal users wouldn't get rewards properly.\n\nStrategy A staked amount x and x will be added to StakerVault.strategiesTotalStaked.\ncontracts\\StakerVault.sol#L312\n\nStrategy A transferred the amount x to non-strategy B and StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked won't be updated.\ncontracts\\StakerVault.sol#L111\n\nAfter some time for the larger LpGauge.poolStakedIntegral, B claims rewards using the LpGauge.claimRewards() function.\ncontracts\\tokenomics\\LpGauge.sol#L52\nInside LpGauge.userCheckPoint(), it's designed not to calculate LpGauge.perUserShare for strategy, but it will pass this condition because B is not a strategy.\n\n```solidity\n /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used if a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n\n    function claimRewards(address beneficiary) external override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        _mintRewards(beneficiary, amount);\n        return amount;\n    }\n```\n\n",
    "Contract": ["protocol/contracts/tokenomics/LpGauge.sol", "protocol/contracts/StakerVault.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Fees from delisted pool still in reward handler will become stuck after delisting",
    "Severity": "Medium",
    "Description": "Unclaimed fees from pool will be stuck\n\n```solidity\n/**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyGovernance returns (bool) {\n        if (!addressProvider.removePool(pool)) {\n            return false;\n        }\n        address lpToken = ILiquidityPool(pool).getLpToken();\n\n        if (address(inflationManager) != address(0)) {\n            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);\n            if (exists) {\n                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);\n            }\n        }\n\n        return true;\n    }\n```\n\nWhen delisting a pool the pool's reference is removed from address provider:\n`if (!addressProvider.removePool(pool)) {`\n\nBurning fees calls a dynamic list of all pools which no longer contains the delisted pool:\n\n`address[] memory pools = addressProvider.allPools();`\n\n\nSince the list no longer contains the pool those fees will not be processed and will remain stuck in the contract\n\n\n",
    "Contract": ["protocol/contracts/Controller.sol"],
    "Recommendation": ""
  }
]
