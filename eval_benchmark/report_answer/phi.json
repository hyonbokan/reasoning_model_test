[
  {
    "Issue": "Signature replay in signatureClaim results in unauthorized claiming of rewards",
    "Severity": "High",
    "Description": "Loss of funds due to unauthorized and multiple claiming of art rewards: signature obtained from the Phi signer on one chain can be employed to claim NFT rewards on any other chain.\n\n```solidity\n    /// @notice Claims a art reward using a signature.\n    /// @param signature_ The signature of the claim data.\n    /// @param encodeData_ The encoded claim data.\n    /// @param mintArgs_ The minting arguments.\n    function signatureClaim(\n        bytes calldata signature_,\n        bytes calldata encodeData_,\n        MintArgs calldata mintArgs_\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        (uint256 expiresIn_, address minter_, address ref_, address verifier_, uint256 artId_,, bytes32 data_) =\n            abi.decode(encodeData_, (uint256, address, address, address, uint256, uint256, bytes32));\n        if (expiresIn_ <= block.timestamp) revert SignatureExpired();\n        if (_recoverSigner(keccak256(encodeData_), signature_) != phiSignerAddress) revert AddressNotSigned();\n        _validateAndUpdateClaimState(artId_, minter_, mintArgs_.quantity);\n        _processClaim(artId_, minter_, ref_, verifier_, mintArgs_.quantity, data_, mintArgs_.imageURI, msg.value);\n        emit ArtClaimedData(artId_, \"SIGNATURE\", minter_, ref_, verifier_, arts[artId_].artAddress, mintArgs_.quantity);\n    }\n```\n\nContract PhiFactory includes the function signatureClaim, which is intended for claiming art rewards using a signature obtained from the Phi signing authority. Unfortunately, the signature validation in this function is faulty, as it doesn't validate the chain id for which the signature has been issued:\n\n```solidity\n(uint256 expiresIn_, address minter_, address ref_, address verifier_, uint256 artId_,, bytes32 data_) =\n    abi.decode(encodeData_, (uint256, address, address, address, uint256, uint256, bytes32));\nif (expiresIn_ <= block.timestamp) revert SignatureExpired();\nif (_recoverSigner(keccak256(encodeData_), signature_) != phiSignerAddress) revert AddressNotSigned();\n```\n\nNotice the fragmen uint256 artId_,, bytes32 data_: in between of artId and data_ there is the encoded chainId, which is ignored.\n\n```solidity\n    function signatureClaim() external payable {\n        (\n            bytes32 r_,\n            bytes32 vs_,\n            address ref_,\n            address verifier_,\n            address minter_,\n            uint256 tokenId_,\n            uint256 quantity_,\n            uint256 expiresIn_,\n            string memory imageURI_,\n            bytes32 data_\n        ) = abi.decode(\n            msg.data[4:], (bytes32, bytes32, address, address, address, uint256, uint256, uint256, string, bytes32)\n        );\n        uint256 artId = getFactoryArtId(tokenId_);\n        bytes memory claimData_ = abi.encode(expiresIn_, minter_, ref_, verifier_, artId, block.chainid, data_);\n        bytes memory signature = abi.encodePacked(r_, vs_);\n        IPhiFactory phiFactoryContract = getPhiFactoryContract();\n        IPhiFactory.MintArgs memory mintArgs_ = IPhiFactory.MintArgs(tokenId_, quantity_, imageURI_);\n        phiFactoryContract.signatureClaim{ value: msg.value }(signature, claimData_, mintArgs_);\n    }\n```\n\nThere is a correct path for signature claims, which goes via PhiNFT1155 -> Claimable::signatureClaim, which unpacks the supplied data, but submits to PhiFactory::signatureClaim the data with the chain id substituted with block.chainid. Unfortunately, PhiFactory::signatureClaim can be called directly, thus bypassing this crucial step. As a result the signature obtained for one chain can be reused for multiple chains. As PhiFactory and art contracts on multiple chains are independent, the artId referring to some cheap art work on one chain, may refer on another chain to a very valuable art work; claiming this art work without proper authorization leads to direct loss of funds. Here is the scenario:\n1. An attacker observes that a valuable art piece exists on chain A with artId\n2. They find a chain B where such artId is not yet used, and create a bunch of arts till they reach this artId\n3. They correctly claim artId on chain B\n4. They reuse the obtained signature to claim the art piece with artId on chain A, thus effectively stealing it.",
    "Contract": ["src/abstract/Claimable.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Signature replay in createArt allows to impersonate artist and steal royalties",
    "Severity": "High",
    "Description": "Loss of funds: anyone can frontrun the createArt transaction, reusing the original signature but supplying their own config. As a result the artist, the royalties recipient, as well the the royalty BPS can be set arbitrarily, leading to stealing the royalties from the artist, and achieving other impacts.\n\n```solidity\n    function createArt(\n        bytes calldata signedData_,\n        bytes calldata signature_,\n        CreateConfig memory createConfig_\n    )\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        returns (address)\n    {\n        _validateArtCreationSignature(signedData_, signature_);\n        (, string memory uri_, bytes memory credData) = abi.decode(signedData_, (uint256, string, bytes));\n        ERC1155Data memory erc1155Data = _createERC1155Data(artIdCounter, createConfig_, uri_, credData);\n        address artAddress = createERC1155Internal(artIdCounter, erc1155Data);\n        artIdCounter++;\n        return artAddress;\n    }\n```\n\n \n\n```solidity\n    function createERC1155Internal(uint256 newArtId, ERC1155Data memory createData_) internal returns (address) {\n        // Todo check if artid exists, if artid exists, reverts\n        _validateArtCreation(createData_);\n        PhiArt storage currentArt = arts[newArtId];\n        _initializePhiArt(currentArt, createData_);\n        (uint256 credId,, string memory verificationType, uint256 credChainId,) =\n            abi.decode(createData_.credData, (uint256, address, string, uint256, bytes32));\n        address artAddress;\n        if (credNFTContracts[credChainId][credId] == address(0)) {\n            artAddress = _createNewNFTContract(currentArt, newArtId, createData_, credId, credChainId, verificationType);\n        } else {\n            artAddress = _useExistingNFTContract(currentArt, newArtId, createData_, credId, credChainId);\n        }\n        return artAddress;\n    }\n```\n\nFunction PhiFactory::createArt() doesn't limit the signature to either the specific submitter, nor does it include into the signed data the CreateConfig parameters, which in particular include the artist, the royalties receiver, as well as other parameters. Other impacts are possible but here is one specific scenario:\n    1. The legitimate party creates a valid signature, config, and submits the createArt transaction.\n    2. An attacker observes createArt transaction in the mempool, and frontruns it, reusing the signature, but with their own config where they are the royalties recipient.\n    3. Attacker's transaction succeeds, setting them as the royalties recipient.\n    4. The original transaction gets executed, and also succeeds, because createERC1155Internal succeeds both when a new PhiNFT1155 contract is created, as well as when it exists already.\n    5. The legitimate user doesn't notice the difference: both ArtContractCreated and NewArtCreated events are emitted correctly (only NewArtCreated is emitted twice).\n    6. As a result, the attacker gets all rewards sent to the PhiRewards contract from PhiNFT1155 when the legitimate party claims an NFT token PhiNFT1155::claimFromFactory().\n",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "`shareBalance` bloating eventually blocks curator rewards distribution",
    "Severity": "High",
    "Description": "Cred curator share balances are tracked by the following data structure in the Cred:\n\n```solidity\nmapping(uint256 credId => EnumerableMap.AddressToUintMap balance) private shareBalance;\n```\n\nThere may be MAX_SUPPLY = 999 maximum curators of a cred. However, when a curator sells all their shares, the curator\nentry still remains in the data structure with a zero shares number. Because of that the mapping grows unlimited.\nAs soon as about 4000 different addresses owned (for any time period) a cred's share, the current shareholders\n(regardless of their current number) will be no longer enumerable by CuratorRewardsDistributor. Rewards\ndistribution for this cred will be blocked because gas usage hits the block gas limit.\nHave a look at the curator share balance update code:\n\n```solidity\nfunction _updateCuratorShareBalance(uint256 credId_, address sender_, uint256 amount_, bool isBuy) internal {\n        (, uint256 currentNum) = shareBalance[credId_].tryGet(sender_);\n        if (isBuy) {\n            if (currentNum == 0 && !_credIdExistsPerAddress[sender_][credId_]) {\n                _addCredIdPerAddress(credId_, sender_);\n                _credIdExistsPerAddress[sender_][credId_] = true;\n            }\n            shareBalance[credId_].set(sender_, currentNum + amount_);\n        } else {\n            if ((currentNum - amount_) == 0) {\n                _removeCredIdPerAddress(credId_, sender_);\n                _credIdExistsPerAddress[sender_][credId_] = false;\n            }\n            shareBalance[credId_].set(sender_, currentNum - amount_);\n        }\n    }\n```\n\nWhen all shares are sold by the curator, its balance is set to 0 rather than deleted from the EnumerableMap.\nDuring rewards distribution, a call to getCuratorAddresses is made. The control goes to _getCuratorData function\nwhich enumerates all entries of shareBalance[credId]:\n\n```solidity\nuint256 stopIndex;\n        if (stop_ == 0 || stop_ > shareBalance[credId_].length()) {\n            stopIndex = shareBalance[credId_].length();\n        } else {\n            stopIndex = stop_;\n        }\n        // ...\n        for (uint256 i = start_; i < stopIndex; ++i) {\n            (address key, uint256 shareAmount) = shareBalance[credId_].at(i);\n```\n\nReading storage slots is quite an expensive operation nowadays. The execution will eventually hit the block gas limit and\nthe transaction will be reverted. Details of sload costs and block gas limit may vary from chain to chain, but the DoS\npossibility never goes away.\nBesides, take into account that storage access costs may increase significantly, rendering the discussed code unexecutable. Such a change may be introduced in a hardfork, e.g. the cost of the sload opcode was increased 10 times recently.\n\n**Impact**\nIf a cred is used and traded long enough (which is the intended state of the matter, presumably), the rewards of such a cred\nwill be undistributable. Besides that, a griefing may be executed to block existing rewards (please see discussion in the\nPoC). Assets (rewards) of curators can be lost in that case until a code upgrade is made. If the contract was not\nupgradeable, that would be a high-risk situation in my opinion.\n",
    "Contract": ["src/Cred.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Forced endTime extension in updateArtSettings() allows attacker to mint more tokens",
    "Severity": "High",
    "Description": "The function updateArtSettings() allows an artist to update the art settings for their art work at any time. Specifically, it allows updating the receiver, maxSupply, mintFee, startTime, endTime, soulBounded and uri of the PhiArt struct as well as the royalty configuration.\nThe issue is that if the artist wants to update the art settings after the claiming/minting event from startTime to endTime is over, the artist is forced to extend the endTime to atleast the current block.timestamp. The artist would be wanting to update the uri or the soulBounded value (in case it might be the artist's idea to keep or not keep soulbounded initially and then later on change the value to make it not soulbounded or soulbounded) or even updating the configuration for royalties for secondary sales post the event.\n\n```solidity\nfunction updateArtSettings(\n        uint256 artId_,\n        string memory url_,\n        address receiver_,\n        uint256 maxSupply_,\n        uint256 mintFee_,\n        uint256 startTime_,\n        uint256 endTime_,\n        bool soulBounded_,\n        IPhiNFT1155Ownable.RoyaltyConfiguration memory configuration\n    )\n        external\n        onlyArtCreator(artId_)\n    {\n        if (receiver_ == address(0)) {\n            revert InvalidAddressZero();\n        }\n        if (endTime_ < startTime_) {\n            revert InvalidTimeRange();\n        }\n        if (endTime_ < block.timestamp) {\n            revert EndTimeInPast();\n        }\n        PhiArt storage art = arts[artId_];\n        if (art.numberMinted > maxSupply_) {\n            revert ExceedMaxSupply();\n        }\n        art.receiver = receiver_;\n        art.maxSupply = maxSupply_;\n        art.mintFee = mintFee_;\n        art.startTime = startTime_;\n        art.endTime = endTime_;\n        art.soulBounded = soulBounded_;\n        art.uri = url_;\n        uint256 tokenId = IPhiNFT1155Ownable(art.artAddress).getTokenIdFromFactoryArtId(artId_);\n        IPhiNFT1155Ownable(art.artAddress).updateRoyalties(tokenId, configuration);\n        emit ArtUpdated(artId_, url_, receiver_, maxSupply_, mintFee_, startTime_, endTime_, soulBounded_);\n    }\n```\n\n \n\n```solidity\nif (block.timestamp > art.endTime) revert ArtEnded();\n```\n\nSince the artist is forced to extend the endTime to block.timestamp, a malicious user keeping track of such calls to updateArtSettings() can backrun the artist's transaction with a merkleClaim() call to mint any amount of tokens for that artId. Since the validation here would not cause a revert, the call goes through successfully.\n",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Exposed _removeCredIdPerAddress & _addCredIdPerAddress allows anyone to cause issues to current holders as well as upcoming ones",
    "Severity": "High",
    "Description": "The _addCredIdPerAddress & _removeCredIdPerAddress allows anyone to interrupt users who are attempting to hold cred shares & sell already held cred shares.\n\n```solidity\nfunction _addCredIdPerAddress(uint256 credId_, address sender_) public {\n        // Add the new credId to the array\n        _credIdsPerAddress[sender_].push(credId_);\n        // Store the index of the new credId\n        _credIdsPerAddressCredIdIndex[sender_][credId_] = _credIdsPerAddressArrLength[sender_];\n        // Increment the array length counter\n        _credIdsPerAddressArrLength[sender_]++;\n    }\n    // Function to remove a credId from the address's list\n    function _removeCredIdPerAddress(uint256 credId_, address sender_) public {\n        // Check if the array is empty\n        if (_credIdsPerAddress[sender_].length == 0) revert EmptyArray();\n        // Get the index of the credId to remove\n        uint256 indexToRemove = _credIdsPerAddressCredIdIndex[sender_][credId_];\n        // Check if the index is valid\n        if (indexToRemove >= _credIdsPerAddress[sender_].length) revert IndexOutofBounds();\n        // Verify that the credId at the index matches the one we want to remove\n        uint256 credIdToRemove = _credIdsPerAddress[sender_][indexToRemove];\n        if (credId_ != credIdToRemove) revert WrongCredId();\n        // Get the last element in the array\n        uint256 lastIndex = _credIdsPerAddress[sender_].length - 1;\n        uint256 lastCredId = _credIdsPerAddress[sender_][lastIndex];\n        // Move the last element to the position of the element we're removing\n        _credIdsPerAddress[sender_][indexToRemove] = lastCredId;\n        // Update the index of the moved element, if it's not the one we're removing\n        if (indexToRemove < lastIndex) {\n            _credIdsPerAddressCredIdIndex[sender_][lastCredId] = indexToRemove;\n        }\n        // Remove the last element (which is now a duplicate)\n        _credIdsPerAddress[sender_].pop();\n        // Remove the index mapping for the removed credId\n        delete _credIdsPerAddressCredIdIndex[sender_][credIdToRemove];\n        // Decrement the array length counter, if it's greater than 0\n        if (_credIdsPerAddressArrLength[sender_] > 0) {\n            _credIdsPerAddressArrLength[sender_]--;\n        }\n    }\n```\n\n",
    "Contract": ["src/Cred.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Reentrancy Vulnerability Allows Bypass of Cooldown, Leading to Unfair Reward Extraction Through Flash Loan",
    "Severity": "High",
    "Description": "\n\n```solidity    \nfunction buyShareCred(uint256 credId_, uint256 amount_, uint256 maxPrice_) public payable {\n        _handleTrade(credId_, amount_, true, _msgSender(), maxPrice_);\n    }\n    function sellShareCred(uint256 credId_, uint256 amount_, uint256 minPrice_) public {\n        _handleTrade(credId_, amount_, false, _msgSender(), minPrice_);\n    }\n    function distribute(uint256 credId) external {\n        if (!credContract.isExist(credId)) revert InvalidCredId();\n        uint256 totalBalance = balanceOf[credId];\n        if (totalBalance == 0) {\n            revert NoBalanceToDistribute();\n        }\n        address[] memory distributeAddresses = credContract.getCuratorAddresses(credId, 0, 0);\n        uint256 totalNum;\n        for (uint256 i = 0; i < distributeAddresses.length; i++) {\n            totalNum += credContract.getShareNumber(credId, distributeAddresses[i]);\n        }\n        if (totalNum == 0) {\n            revert NoSharesToDistribute();\n        }\n        uint256[] memory amounts = new uint256[](distributeAddresses.length);\n        bytes4[] memory reasons = new bytes4[](distributeAddresses.length);\n        uint256 royaltyfee = (totalBalance * withdrawRoyalty) / RATIO_BASE;\n        uint256 distributeAmount = totalBalance - royaltyfee;\n        // actualDistributeAmount is used to avoid rounding errors\n        // amount[0] = 333 333 333 333 333 333\n        // amount[1] = 333 333 333 333 333 333\n        // amount[2] = 333 333 333 333 333 333\n        uint256 actualDistributeAmount = 0;\n        for (uint256 i = 0; i < distributeAddresses.length; i++) {\n            address user = distributeAddresses[i];\n            uint256 userAmounts = credContract.getShareNumber(credId, user);\n            uint256 userRewards = (distributeAmount * userAmounts) / totalNum;\n            if (userRewards > 0) {\n                amounts[i] = userRewards;\n                actualDistributeAmount += userRewards;\n            }\n        }\n        balanceOf[credId] -= totalBalance;\n        _msgSender().safeTransferETH(royaltyfee + distributeAmount - actualDistributeAmount);\n        //slither-disable-next-line arbitrary-send-eth\n        phiRewardsContract.depositBatch{ value: actualDistributeAmount }(\n            distributeAddresses, amounts, reasons, \"deposit from curator rewards distributor\"\n        );\n        emit RewardsDistributed(\n            credId, _msgSender(), royaltyfee + distributeAmount - actualDistributeAmount, distributeAmount, totalBalance\n        );\n    }\n    function _handleTrade(\n        uint256 credId_,\n        uint256 amount_,\n        bool isBuy,\n        address curator_,\n        uint256 priceLimit\n    )\n        internal\n        whenNotPaused\n    {\n        if (amount_ == 0) {\n            revert InvalidAmount();\n        }\n        if (!isExist(credId_)) {\n            revert InvalidCredId();\n        }\n        PhiCred storage cred = creds[credId_];\n        uint256 supply = cred.currentSupply;\n        address creator = cred.creator;\n        (uint256 price, uint256 protocolFee, uint256 creatorFee) =\n            IBondingCurve(cred.bondingCurve).getPriceData(credId_, supply, amount_, isBuy);\n        if (isBuy) {\n            if (priceLimit != 0 && price + protocolFee + creatorFee > priceLimit) revert PriceExceedsLimit();\n            if (supply + amount_ > MAX_SUPPLY) {\n                revert MaxSupplyReached();\n            }\n            if (msg.value < price + protocolFee + creatorFee) {\n                revert InsufficientPayment();\n            }\n        } else {\n            if (priceLimit != 0 && price - protocolFee - creatorFee < priceLimit) revert PriceBelowLimit();\n            if (block.timestamp <= lastTradeTimestamp[credId_][curator_] + SHARE_LOCK_PERIOD) {\n                revert ShareLockPeriodNotPassed(\n                    block.timestamp, lastTradeTimestamp[credId_][curator_] + SHARE_LOCK_PERIOD\n                );\n            }\n            (, uint256 nums) = shareBalance[credId_].tryGet(curator_);\n            if (nums < amount_) {\n                revert InsufficientShares();\n            }\n        }\n        _updateCuratorShareBalance(credId_, curator_, amount_, isBuy);\n        if (isBuy) {\n            cred.currentSupply += amount_;\n            uint256 excessPayment = msg.value - price - protocolFee - creatorFee;\n            if (excessPayment > 0) {\n                _msgSender().safeTransferETH(excessPayment);\n            }\n            lastTradeTimestamp[credId_][curator_] = block.timestamp;\n        } else {\n            cred.currentSupply -= amount_;\n            curator_.safeTransferETH(price - protocolFee - creatorFee);\n        }\n        protocolFeeDestination.safeTransferETH(protocolFee);\n        IPhiRewards(phiRewardsAddress).deposit{ value: creatorFee }(\n            creator, bytes4(keccak256(\"CREATOR_ROYALTY_FEE\")), \"\"\n        );\n        emit Royalty(creator, credId_, creatorFee);\n        cred.latestActiveTimestamp = block.timestamp;\n        emit Trade(curator_, credId_, isBuy, amount_, price, protocolFee, cred.currentSupply);\n    }\n```\n\nThe distribute function in the CuratorRewardsDistributor contract is responsible for distributing curator rewards accumulated for a specified credId. These rewards are distributed based on the number of shares a user owns in a cred. The function can be called by anyone, and the caller earns a fee for doing so.\nTo prevent flash loan attacks where an attacker could buy a large number of shares, call the distribute function, and then immediately sell the shares to capture most of the rewards, the buyShareCred function in the Cred contract implements a cooldown period. This cooldown is intended to prevent a user from immediately selling their shares after buying them.\nHowever, the cooldown mechanism is flawed. Specifically, the _handleTrade function, which is called internally by buyShareCred, refunds any excess payment before updating the lastTradeTimestamp used to enforce the cooldown period. This sequence allows for a reentrancy attack, where the attacker can exploit the refund callback to bypass the cooldown period and sell the shares immediately after purchasing them, thereby executing a flash loan attack.\n",
    "Contract": ["src/Cred.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Unrestricted Changes to Token Settings Allow Artists to Alter Critical Features",
    "Severity": "High",
    "Description": "\n\n```solidity    \nfunction updateArtSettings(\n        uint256 artId_,\n        string memory url_,\n        address receiver_,\n        uint256 maxSupply_,\n        uint256 mintFee_,\n        uint256 startTime_,\n        uint256 endTime_,\n        bool soulBounded_,\n        IPhiNFT1155Ownable.RoyaltyConfiguration memory configuration\n    )\n        external\n        onlyArtCreator(artId_)\n    {\n        if (receiver_ == address(0)) {\n            revert InvalidAddressZero();\n        }\n        if (endTime_ < startTime_) {\n            revert InvalidTimeRange();\n        }\n        if (endTime_ < block.timestamp) {\n            revert EndTimeInPast();\n        }\n        PhiArt storage art = arts[artId_];\n        if (art.numberMinted > maxSupply_) {\n            revert ExceedMaxSupply();\n        }\n        art.receiver = receiver_;\n        art.maxSupply = maxSupply_;\n        art.mintFee = mintFee_;\n        art.startTime = startTime_;\n        art.endTime = endTime_;\n        art.soulBounded = soulBounded_;\n        art.uri = url_;\n        uint256 tokenId = IPhiNFT1155Ownable(art.artAddress).getTokenIdFromFactoryArtId(artId_);\n        IPhiNFT1155Ownable(art.artAddress).updateRoyalties(tokenId, configuration);\n        emit ArtUpdated(artId_, url_, receiver_, maxSupply_, mintFee_, startTime_, endTime_, soulBounded_);\n    }\n```\n\nThe updateArtSettings function in the PhiFactory contract allows artists to modify several key settings of their art at any time. These settings include the URI link, royalty fee and soulBounded (non-transferable) feature.\nThe problem is that there are no restrictions or limitations on how these settings can be changed after the art has been created and minted. This flexibility allows artists to alter critical functionalities in ways that could negatively impact existing holders:\nChanging Soulbound Status: Artists can toggle the soulBounded status to lock transfers, effectively trapping users who purchased NFTs under the assumption they were transferable.\n\nModifying Royalties: Artists can set royalty fees to extremely high values after initial sales, forcing holders to pay unexpected fees upon resale.\nUpdating URLs: Artists can change the linkURI, potentially misleading users or affecting the NFT's perceived value by altering the associated content. In the worst case, the URL could be changed to a malicious link, posing security risks to users who interact with it.\nThese changes can be made at any time, without prior notice to holders, leaving users vulnerable to unfavourable adjustments.\nAllowing unrestricted changes to critical token settings poses a significant risk to the stability and trustworthiness of the NFTs. Users who have already minted or purchased NFTs could be adversely affected by changes they did not agree to, such as increased fees or transfer restrictions.\n",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Contract PhiNFT1155 can't be paused",
    "Severity": "Medium",
    "Description": "The pausing mechanism of PhiNFT1155 contract is implemented incorrectly and doesn't work. Users are still able to transfer NFTs in paused state.\n\n```solidity\ncontract PhiNFT1155 is\n    Initializable,\n    UUPSUpgradeable,\n    ERC1155SupplyUpgradeable,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    Ownable2StepUpgradeable,\n    IPhiNFT1155,\n    Claimable,\n    CreatorRoyaltiesControl\n{\n```\n\nThe problem with the above is that inheriting from PausableUpgradeable is not effective in the scope of OZ ERC1155 contracts",
    "Contract": ["src/PhiNFT1155.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Incorrect Fee Handling Prevents Protocol from Updating Fees",
    "Severity": "Medium",
    "Description": "The primary impact of this bug is that the protocol cannot change the mint and art creation fees as intended. This limitation has the following consequences:\n\n```solidity\n    function setProtocolFee(uint256 protocolFee_) external onlyOwner {\n        if (protocolFee_ > 10_000) revert ProtocolFeeTooHigh();\n        mintProtocolFee = protocolFee_;\n        emit ProtocolFeeSet(protocolFee_);\n    }\n    /// @notice Sets the art creation fee percentage.\n    /// @param artCreateFee_ The new art creation fee percentage (in basis points).\n    function setArtCreatFee(uint256 artCreateFee_) external onlyOwner {\n        if (artCreateFee_ > 10_000) revert ArtCreatFeeTooHigh();\n        artCreateFee = artCreateFee_;\n        emit ArtCreatFeeSet(artCreateFee_);\n    }\n```\n\nThe protocol is unable to set the correct mint fee of 0.00005 ETH per NFT minted, as documented in the specifications:\n   Mint Fee\n   This fee is applied when a Minter wants to mint a Cred NFT.\n   Protocol will have a mint price/fee of 0.00005 ETH.\nThis discrepancy between the intended fee (0.00005 ETH) and the maximum settable fee (10,000 wei) renders the fee adjustment mechanism ineffective.\nThe protocol loses the ability to adjust its revenue model in response to market conditions or strategic decisions, as both the mint fee and art creation fee are effectively locked at their initial values.\nBelow lines demonstrate that the fees are being applied as direct values rather than percentages, contrary to the setter functions' assumptions.\nFrom src/PhiFactory.sol:\n\n```solidity\n   function _processClaim(\n        uint256 artId_,\n        address minter_,\n        address ref_,\n        address verifier_,\n        uint256 quantity_,\n        bytes32 data_,\n        string memory imageURI_,\n        uint256 etherValue_\n    )\n        private\n    {\n        PhiArt storage art = arts[artId_];\n        // Handle refund\n        uint256 mintFee = getArtMintFee(artId_, quantity_);\n        if ((etherValue_ - mintFee) > 0) {\n            _msgSender().safeTransferETH(etherValue_ - mintFee);\n        }\n        protocolFeeDestination.safeTransferETH(mintProtocolFee * quantity_); // @audit\n```\n\n \n\n```solidity\n   function createArtFromFactory(uint256 artId_) external payable onlyPhiFactory whenNotPaused returns (uint256) {\n        _artIdToTokenId[artId_] = tokenIdCounter;\n        _tokenIdToArtId[tokenIdCounter] = artId_;\n        uint256 artFee = phiFactoryContract.artCreateFee();\n        protocolFeeDestination.safeTransferETH(artFee); // @audit\n```\n\nIt's important to note that while the immediate financial impact may be limited if the initial fees were set correctly, the long-term implications of this inflexibility could be significant for the protocol's adaptability and financial management.",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "PhiFactory:claim Potentially Causing Loss of Funds If mintFee Changed Beforehand",
    "Severity": "Medium",
    "Description": "1. If the mintFee was lowered by the Art creator via updateArtSettings before the claim was executed, the msg.value from user would become larger than the updated value of mintFee. As the function does not validate msg.value and consumes the mintFee directly, the excess ETH sent by the user will not be refunded, causing a loss of funds for user.\n2. If PhiFactory still holds positive ETH balance, a malicious user can exploit this by sending less msg.value than expected (or no ETH at all). This results in PhiFactory's ETH being used for the mintFee payment instead, causing a loss for the protocol.    \n\n```solidity\nfunction claim(bytes calldata encodeData_) external payable {\n        bytes memory encodedata_ = LibZip.cdDecompress(encodeData_);\n        (uint256 artId) = abi.decode(encodedata_, (uint256));\n        PhiArt storage art = arts[artId];\n        uint256 tokenId = IPhiNFT1155Ownable(art.artAddress).getTokenIdFromFactoryArtId(artId);\n        if (art.verificationType.eq(\"MERKLE\")) {\n            (\n                ,\n                address minter_,\n                bytes32[] memory proof,\n                address ref_,\n                uint256 quantity_,\n                bytes32 leafPart_,\n                string memory imageURI_\n            ) = abi.decode(encodedata_, (uint256, address, bytes32[], address, uint256, bytes32, string));\n            bytes memory claimData = abi.encode(minter_, ref_, artId);\n            MintArgs memory mintArgs = MintArgs({ tokenId: tokenId, quantity: quantity_, imageURI: imageURI_ });\n            uint256 mintFee = getArtMintFee(artId, quantity_);\n            this.merkleClaim{ value: mintFee }(proof, claimData, mintArgs, leafPart_);\n        } else if (art.verificationType.eq(\"SIGNATURE\")) {\n            (\n                ,\n                address minter_,\n                address ref_,\n                address verifier_,\n                uint256 expiresIn_,\n                uint256 quantity_,\n                bytes32 data_,\n                string memory imageURI_,\n                bytes memory signature_\n            ) = abi.decode(encodedata_, (uint256, address, address, address, uint256, uint256, bytes32, string, bytes));\n            bytes memory claimData = abi.encode(expiresIn_, minter_, ref_, verifier_, artId, block.chainid, data_);\n            MintArgs memory mintArgs = MintArgs({ tokenId: tokenId, quantity: quantity_, imageURI: imageURI_ });\n            uint256 mintFee = getArtMintFee(artId, quantity_);\n            this.signatureClaim{ value: mintFee }(signature_, claimData, mintArgs);\n        } else {\n            revert InvalidVerificationType();\n        }\n    }\n```\n\n",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Cred creator could stuck funds",
    "Severity": "Medium",
    "Description": "Update of cred can be triggered by the cred creator. If there are already issued shares for users, and the cred creator decides to update the sellShareRoyalty_ this will lead users to pay up to 50% fee depending on the value. And users will be in situation that to withdraw their funds, they need to pay 50% to the cred creator and additionally some fee to the protocol.\n\n```solidity\n    /// @notice Updates the URL of a cred.\n    function updateCred(\n        bytes calldata signedData_,\n        bytes calldata signature_,\n        uint16 buyShareRoyalty_,\n        uint16 sellShareRoyalty_\n    )\n        external\n        whenNotPaused\n    {\n        if (_recoverSigner(keccak256(signedData_), signature_) != phiSignerAddress) revert AddressNotSigned();\n        (uint256 expiresIn_, address sender,, uint256 credId, string memory credURL) =\n            abi.decode(signedData_, (uint256, address, uint256, uint256, string));\n        if (expiresIn_ <= block.timestamp) revert SignatureExpired();\n        if (sender != _msgSender()) revert Unauthorized();\n        if (creds[credId].creator != _msgSender()) revert Unauthorized();\n        if (buyShareRoyalty_ > MAX_ROYALTY_RANGE || sellShareRoyalty_ > MAX_ROYALTY_RANGE) {\n            revert InvalidRoyaltyRange();\n        }\n        creds[credId].credURL = credURL;\n        creds[credId].updatedAt = uint40(block.timestamp);\n        creds[credId].buyShareRoyalty = buyShareRoyalty_;\n        creds[credId].sellShareRoyalty = sellShareRoyalty_;\n        emit CredUpdated(_msgSender(), credId, credURL, buyShareRoyalty_, sellShareRoyalty_);\n    }\n```\n\n",
    "Contract": ["src/Cred.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Lack of data validation when users are claiming their art allows malicious user to bypass signature/merkle hash to provide unapproved ref_, artId_ and imageURI",
    "Severity": "Medium",
    "Description": "\n\n```solidity    \nfunction merkleClaim(\n        bytes32[] calldata proof_,\n        bytes calldata encodeData_,\n        MintArgs calldata mintArgs_,\n        bytes32 leafPart_\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        (address minter_, address ref_, uint256 artId_) = abi.decode(encodeData_, (address, address, uint256));\n        PhiArt storage art = arts[artId_];\n        bytes32 credMerkleRootHash = credMerkleRoot[art.credChainId][art.credId];\n        if (minter_ == address(0) || !art.verificationType.eq(\"MERKLE\") || credMerkleRootHash == bytes32(0)) {\n            revert InvalidMerkleProof();\n        }\n        if (\n            !MerkleProofLib.verifyCalldata(\n                proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_))))\n            )\n        ) {\n            revert InvalidMerkleProof();\n        }\n        _validateAndUpdateClaimState(artId_, minter_, mintArgs_.quantity);\n        _processClaim(\n            artId_, minter_, ref_, art.credCreator, mintArgs_.quantity, leafPart_, mintArgs_.imageURI, msg.value\n        );\n        emit ArtClaimedData(artId_, \"MERKLE\", minter_, ref_, art.credCreator, art.artAddress, mintArgs_.quantity);\n    }\n    function signatureClaim(\n        bytes calldata signature_,\n        bytes calldata encodeData_,\n        MintArgs calldata mintArgs_\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        (uint256 expiresIn_, address minter_, address ref_, address verifier_, uint256 artId_,, bytes32 data_) =\n            abi.decode(encodeData_, (uint256, address, address, address, uint256, uint256, bytes32));\n        if (expiresIn_ <= block.timestamp) revert SignatureExpired();\n        if (_recoverSigner(keccak256(encodeData_), signature_) != phiSignerAddress) revert AddressNotSigned();\n        _validateAndUpdateClaimState(artId_, minter_, mintArgs_.quantity);\n        _processClaim(artId_, minter_, ref_, verifier_, mintArgs_.quantity, data_, mintArgs_.imageURI, msg.value);\n        emit ArtClaimedData(artId_, \"SIGNATURE\", minter_, ref_, verifier_, arts[artId_].artAddress, mintArgs_.quantity);\n    }\n```\n\nThe lack of checks in merkleClaim allows malicious users to bypass the hash check to pass in their own parameter of choice. The 3 variables that could possibly be manipulated (referral, artId and imageURI) and their impact will be each discussed below.\nMissing ref_ and artId_ in validation.\nAs we can see in merkleClaim:\n\n```solidity\n(address minter_, address ref_, uint256 artId_) = abi.decode(encodeData_, (address, address, uint256));\n  PhiArt storage art = arts[artId_];\n  ......\n  if (\n      !MerkleProofLib.verifyCalldata(\n          proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_))))\n      )\n  ) {\n      revert InvalidMerkleProof();\n  }\n  ......\n\n```\naddress ref_ and uint256 artId_ is decoded from encodeData_ which is simbly a bytes data type passed into the function parameter by the user.\nObserving the line where the merkle hash is cross-checked:\n`!MerkleProofLib.verifyCalldata( proof_, credMerkleRootHash, keccak256(bytes.concat(keccak256(abi.encode(minter_, leafPart_)))) )`\nIt becomes clear that only minter_ from encodeData_ is checked, leaving ref_ and artId_ to whatever values passed by the user.\nBy the way, both ref_ and artId_ are explicitly checked in the signatureClaim function:\n\n```solidity\nfunction signatureClaim(.....) external payable whenNotPaused {\n  (uint256 expiresIn_, address minter_, address ref_, address verifier_, uint256 artId_,, bytes32 data_) =\n      abi.decode(encodeData_, (uint256, address, address, address, uint256, uint256, bytes32));\n      \n  if (expiresIn_ <= block.timestamp) revert SignatureExpired();\n  if (_recoverSigner(keccak256(encodeData_), signature_) != phiSignerAddress) revert AddressNotSigned();\n  .....\n}\n```\n\nHence, to forge ref_ and artId_, malicious users will have to use merkleClaim instead of signatureClaim.\n\n**Impact of forging ref_**\nMalicious users can pass in their own other account address as ref_, successfully stealing the referral fee from the real ref_ or the artist(who will receive the referal fee if ref_ is set to null).\nSuppose Alice has 2 accounts, when she calls merkleClaim to claim on account 1, she can pass in account 2 as the ref_ to illegally steal the referral fees to offset the cost of minting.\nThe reason why Alice has to pass in account 2 instead of account 1 as the ref_ is because in PhiRewards.sol's depositRewards, referral has to be different from minter address in order for Alice to receive the referral fees.\n\n**Impact of forging artId_**\nUnlike signatureClaim which checks artId_ explicitly, merkleClaim only verifies minter_ and leafPart_ to the credId's merkle root hash.\nSince a Cred can have multiple art linked to it, this becomes a problem.\nSuppose Cred A has Art 1 and Art 2.\nNow, Alice got approval to claim Art 1.\nIf the art's verification type was set to \"SIGNATURE\" and Alice had to call signatureClaim, Alice would only be able to claim Art 1 with that approval signature.\nHowever if the art's verification type was \"MERKLE\" instead, when she calls merkleClaim, she will be able to claim Art 2 with only approval for Art 1 by passing the artId_ of Art 2.\n\n**Missing imageURI in validation.**\nWe can see in both signatureClaimLine 330 and merkleClaimLine 355, imageURI is passed into the function parameter rather than extracted from the signature and is not involved in the merkle hash check as well.\nSince imageURI contains important information about the art details(such as location/directory). This could have a severe impact. When the malicious user is trying to claim an art that he has permission to, he could pass in an imageURI with the location directory of the picture image file pointing to another art which he does not have permission for.\nThe line `advancedTokenURI[tokenId_][to_] = imageURI_;` in PhiNFT1155.sol will also be set to an unapproved value.\nThis will lead to undefined/unsupported behaviours when interacting with the smart contract regarding trying to render an user's art URI.",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "PhiNFT1155 contracts continue sending fees/royalties to old protocol destination address",
    "Severity": "Medium",
    "Description": "When a PhiNFT1155.sol contract instance is created from the PhiFactory contract, the initialize() function is called to setup it. One of the parameters passed along is the protocolFeeDestination address, which is used as the default royalty recipient (see here) and the address that will receive the artCreate fees (see here). The issue is that if the protocolFeeDestinationAddress contract is changed in the PhiFactory contract by the owner using function setProtocolFeeDestination(), the existing PhiNFT1155.sol contract instances created would still be using the old protocol fee destination address stored in them since it is not being dynamically retrieved from the PhiFactory contract. The protocolFeeDestination address could be updated for several reasons such as in case it is compromised, becomes malicious or there has been a decision made to make the address non-privileged. Due to this, the old protocol fee destination address would still be receiving all the royalties (i.e. 500 bps = 5%) from all PhiNFT1155.sol contract instances. It would also be receiving all the artCreateFee amount of tokens when art is created through the createArtFromFactory() function.",
    "Contract": ["art/PhiNFT1155.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Attacker can DOS user from selling shares of a credId",
    "Severity": "Medium",
    "Description": "The Cred.sol contract provides a buyShareCredFor() function which anyone can use to buy shares for another curator. We also know that once a share is bought, the curator needs to serve a 10 minute share lock period before being able to sell those tokens.\nImpact\nThe issue is that an attacker can purchase 1 share every 10 minutes on behalf of the curator to DOS them from selling. As we can see on the bonding share price curve docs here, the price to buy 1 share starts from 2.46 USD and barely increases. Each share bought = 10 minutes of delay for the victim user.\nDelaying the user from selling is not the only problem though. During these delays, the price of the share can drop, which could ruin a user's trade strategy causing to incur more loss.",
    "Contract": ["src/Cred.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Refunds sent to incorrect addresses in certain cases",
    "Severity": "Medium",
    "Description": "The _processClaim internal function is responsible for calling the claimFromFactory function in the art contract, transferring the protocol fees to the protocolFeeDestination, and handling any applicable refunds.\n\n```solidity\nfunction _processClaim(\n        ...\n    )\n        private\n    {\n        PhiArt storage art = arts[artId_];\n        // Handle refund\n        uint256 mintFee = getArtMintFee(artId_, quantity_);\n        if ((etherValue_ - mintFee) > 0) {\n            _msgSender().safeTransferETH(etherValue_ - mintFee);\n        }\n        protocolFeeDestination.safeTransferETH(mintProtocolFee * quantity_);\n        (bool success_,) = art.artAddress.call{ value: mintFee - mintProtocolFee * quantity_ }(\n            abi.encodeWithSignature(\n                \"claimFromFactory(uint256,address,address,address,uint256,bytes32,string)\",\n                artId_,\n                minter_,\n                ref_,\n                verifier_,\n                quantity_,\n                data_,\n                imageURI_\n            )\n        );\n        if (!success_) revert ClaimFailed();\n    }\n```\n\nWhen a user sends excess funds (msg.value) over the required mintFee, the difference is intended to be refunded to the user. This works as expected when the signatureClaim or merkleClaim functions are called directly in the PhiFactory contract by the user since msg.sender is the correct address (User). However, in some cases refunds are sent to the wrong address.\n\n**Case 1: Claim function and batchClaim** function\nIn the batchClaim function, multiple claims are processed by calling the claim function with this (the current contract) as the caller, resulting in the msg.sender being the PhiFactory contract rather than the actual user.\n\n```solidity\nfunction batchClaim(bytes[] calldata encodeDatas_, uint256[] calldata ethValue_) external payable {\n        if (encodeDatas_.length != ethValue_.length) revert ArrayLengthMismatch();\n        // calc claim fee\n        uint256 totalEthValue;\n        for (uint256 i = 0; i < encodeDatas_.length; i++) {\n            totalEthValue = totalEthValue + ethValue_[i];\n        }\n        if (msg.value != totalEthValue) revert InvalidEthValue();\n        for (uint256 i = 0; i < encodeDatas_.length; i++) {\n            this.claim{ value: ethValue_[i] }(encodeDatas_[i]);\n        }\n    }\n```\n\nSimilarly, the claim function also uses this when calling either the signatureClaim or merkleClaim functions, further propagating the incorrect msg.sender value. Consequently, any refunds are sent to the PhiFactory contract instead of the actual user, causing an incorrect refund.\n\n**Case 2: signatureClaim function and merkleClaim function in the Claimable contract**\nThe signatureClaim and merkleClaim functions are also callable through the Claimable contract, which is part of the PhiNFT1155 contract. However, like in the previous case, the msg.sender will be incorrect being the PhiNFT1155 contract itself, rather than the actual user who initiated the call. This results in refunds being directed to the PhiNFT1155 contract rather than the user. In this case, funds are also not able to be pulled out by the owner, effectively locking them in the contract.\n\n**Impact**\nIncorrect handling of msg.sender results in refunds being sent to contracts (PhiFactory or PhiNFT1155) rather than the intended users.\nWhile the loss of funds due to overpayment is more of a user error, the primary concern here is that the intended logic for refunding users is incorrect which was specifically mentioned by the protocol to look out for.\nFunction Reliability: Ensure the contract behaves consistently under various conditions.\nFunction Correctness: Ensure the smart contract logic correctly implements the intended functionality without errors.",
    "Contract": ["src/PhiFactory.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "RewardsDeposit and Deposit events can be spam emitted with 0 value deposits through external function",
    "Severity": "Low",
    "Description": "The `handleRewardsAndGetValueSent()` function is called from the PhiNFT1155.sol contracts deployed. This function currently is externally exposed which means events can be spam emitted by directly calling the function. These emission is possible by passing quantity as 0 and msg.value as 0. Performing this spam is easy on low fee chains that the protocol is currently planning to deploy on.\nThis is also an attack idea mentioned in the README - “Are there any potential issues with emitting events or executing functions when using Decent or relayer protocols?” and “Does the contract emit all necessary events correctly and include appropriate data?“. Since we do not know how the events are going to be used by relayer protocols due to being out of scope, the issue is being submitted as QA.\n\n```solidity\nfunction depositRewards(\n        uint256 artId_,\n        uint256 credId_,\n        bytes calldata addressesData_,\n        uint256 artistTotalReward_,\n        uint256 referralTotalReward_,\n        uint256 verifierTotalReward_,\n        uint256 curateTotalReward_,\n        bool chainSync_\n    )\n        internal\n    {\n        ...\n        bytes memory rewardsData;\n        if (chainSync_ && address(curatorRewardsDistributor) != address(0)) {\n            \n            curatorRewardsDistributor.deposit{ value: curateTotalReward_ }(credId_, curateTotalReward_);\n            ...\n        } else {\n            ...\n        }\n        ...\n        emit RewardsDeposit(credData, minter_, receiver_, referral_, verifier_, rewardsData);\n    }\n    function handleRewardsAndGetValueSent(\n        uint256 artId_,\n        uint256 credId_,\n        uint256 quantity_,\n        uint256 mintFee_,\n        bytes calldata addressesData_,\n        bool chainSync_\n    )\n        external\n        payable\n    {\n        if (computeMintReward(quantity_, mintFee_) != msg.value) {\n            revert InvalidDeposit();\n        }\n        depositRewards(\n            artId_,\n            credId_,\n            addressesData_,\n            quantity_ * (mintFee_ + artistReward),\n            quantity_ * referralReward,\n            quantity_ * verifierReward,\n            quantity_ * curateReward,\n            chainSync_\n        );\n    }\n```\n\nThe depositRewards() function from PhiRewards contract above calls the deposit() function in the CuratorRewardsDistributor.sol contract, which would also spam emit the Deposit events.\n\n```solidity\nfunction deposit(uint256 credId, uint256 amount) external payable {\n        if (!credContract.isExist(credId)) revert InvalidCredId();\n        if (msg.value != amount) {\n            revert InvalidValue(msg.value, amount);\n        }\n        balanceOf[credId] += amount;\n        emit Deposit(credId, amount);\n```\n\n",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Function distribute() in CuratorRewardsDistributor is prone to frontrunning",
    "Severity": "Low",
    "Description": "In the CuratorRewardsDistributor contract, any user can call the distribute() function through the frontend (as seen on the demo site). The user would earn 1% (currently) of the total balance as the royalty reward.\nThe issue is that all distribute() function calls occurring from the frontend would be made by normal users, which a bot can frontrun by calling the distribute() function itself. This means normal users would never be able to receive royalty fees.   ",
    "Contract": ["src/CuratorRewardsDistributor.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Malicious user can game curator rewards distribution model in certain conditions",
    "Severity": "Low",
    "Description": "The distribute() function in CuratorRewardsDistributor distributes curator rewards accumulated through different artId mints under a credId. The balanceOf[credId] is distributed to users who hold non-zero amount of shares of that credId.\nA malicious user could frontrun a distribute(credId) function call to buy a huge amount of shares of that credId. This would put the user into the curator addresses list that is eligible to receive the rewards.\nIf we check lines 114-115 in the snippet below, we can see that it uses the shares of a curator and divides it by the total number of shares to determine the % of distributeAmount to give to the curator. Since the malicious user frontran the distribute() call by buying a large amount of shares, the rewards would be diluted and distributed when the distribute() function call goes through.\nThrough this, we can see that although the malicious user just bought the shares, the user is immediately eligible for the curator rewards. Many malicious users could exploit this opportunity to earn a good chunk of distributeAmount.\nTo note, there is obviously the 10 minute share lock period that the malicious user will have to adhere to, during which some curators can sell to profit from the malicious user's buy that increased the price. Since there is a tradeoff introduced with the 10 minute delay, the net profit an attacker could make through this won't be much but the possibility still exists since previous curators may not sell.",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Creator does not receive fees when supply = 0",
    "Severity": "Low",
    "Description": "Creator does not receive creator fees when supply = 0, which is for the initial case when a share is bought during cred creation. This is an issue since the msg.sender that receives the first share can be a party other than the creator supplied in the cred that is being created.",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Missing receiver address validation during artId creation in _initializePhiArt() could DOS future claiming",
    "Severity": "Low",
    "Description": "When an artId is being created, the _initializeArt() function is called as part of the process. In this function the receiver address is stored in the PhiArt struct. The issue is that this address is not validated to not be address(0).\nDue to this, during merkle or signature claiming from factory, the call would revert. This is because the handleRewardsAndGetValueSent() function calls the depositRewards() function that expects the receiver address of the artist to be non-zero as seen here.\n\n```solidity\nfunction claimFromFactory(\n        uint256 artId_,\n        address minter_,\n        address ref_,\n        address verifier_,\n        uint256 quantity_,\n        bytes32 data_,\n        string calldata imageURI_\n    )\n        external\n        payable\n        whenNotPaused\n        onlyPhiFactory\n    {\n        ...\n        IPhiRewards(payable(phiFactoryContract.phiRewardsAddress())).handleRewardsAndGetValueSent{ value: msg.value }(\n            artId_, credId, quantity_, mintFee(tokenId_), addressesData_, credChainId == block.chainid\n        );\n    }\n```\n\n",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "PhiNFT1155.sol contract will not be upgradeable contrary to documentation",
    "Severity": "Low",
    "Description": "According to the docs here on upgradeability, the PhiNFT1155 contracts use the UUPS upgradeability pattern and can be upgraded by the owner.\nCurrently though, it is not possible to upgrade them since msg.sender has to be the owner, which would be the factory contract and the factory contract does not have a mechanism to upgrade contracts, i.e., call the upgrade functionality in the UUPSUpgradeable contract inherited by PhiNFT1155.\nIt's not clear how the factory contract could have and support multiple implementation contracts of PhiNFT1155 (since many contracts can be created through function createArt() in the PhiFactory contract). If upgradeability needs to be supported, introduce a proxy for each PhiNFT1155 contract deployed and a mechanism upgrade it through the factory. If not, correct the documentation.",
    "Contract": ["art/PhiNFT1155.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Attacker can use function withdrawFor() to DOS users from withdrawing",
    "Severity": "Low",
    "Description": "Attacker can frontrun a user's withdraw() or withdrawWithSig() function full balance withdrawals with small withdrawFor() calls to grief users. For example, if user A tries to withdraw 100 tokens using function withdraw() or withdrawWithSig(), the attacker can frontrun and withdraw a 1 wei amount using function withdrawFor(). This would cause A's call to revert since now only 100 - 1 wei amount of tokens are withdrawable.\nAnother issue that arises is that the withdrawFor() function defaults the destination to the “from” address. This is an issue since if the “from” address cannot deal with withdrawing msg.value (which is unlikely though) or if the user wanted to withdraw to another address, the tokens could be stuck in the “from” address contract or just simply sent to the “from” address EOA that was not supposed to receive the tokens. Due to this, an attacker is able to force a withdrawal to the “from” address.",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Royalties would round down to 0 when the unit of exchange has low decimals",
    "Severity": "Low",
    "Description": "In CreatorRoyaltiesControl.sol contract (which is inherited by PhiNFT1155.sol contract), rounding down of royalties is possible if salePrice is denominated in a token that has low decimals. For example, royaltybps = 10 (i.e. 0.1%) and salePrice = up to 999 (meaning up to 0.999 tokens for a token with two decimals). When we perform calculations, the royaltyAmount would be returned as 10 * 999 (max) / 10000 = 9990/10000 = 0. This is optional to the protocol as mentioned by the spec but since it could result in the royalties not being received by the artist, it is a valid issue to consider. ",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Missing whenNotPaused() modifier on function",
    "Severity": "Low",
    "Description": "Missing whenNotPaused() modifier on updateArtSettings() allows any artist to update their art settings when the contract is paused. Although there does not seem to be a risk currently, it should be disallowed if the factory itself is paused.",
    "Contract": [],
    "Recommendation": ""
  }
]
