[
  {
    "Issue": "Single plot can be occupied by multiple renters",
    "Severity": "High",
    "Description": "The LandManager contract allows users to stake their munchables to a other user's plots to earn schnibbles. There's a functionality to transfer a staked token from one plot to another.\nThis functionality is flawed as it allows a user to transfer his token to another plot but doesn't update the plotId field in the ToilerState struct. This means that the user can move his token but the contract still thinks it's in the original plot.\n\n```solidity\n    function transferToUnoccupiedPlot(\n        uint256 tokenId,\n        uint256 plotId\n    ) external override forceFarmPlots(msg.sender) notPaused {\n        (address mainAccount, ) = _getMainAccountRequireRegistered(msg.sender);\n        ToilerState memory _toiler = toilerState[tokenId];\n        uint256 oldPlotId = _toiler.plotId; // @audit plotId isn't update inside toilerState\n        uint256 totalPlotsAvail = _getNumPlots(_toiler.landlord);\n        if (_toiler.landlord == address(0)) revert NotStakedError();\n        if (munchableOwner[tokenId] != mainAccount) revert InvalidOwnerError();\n        if (plotOccupied[_toiler.landlord][plotId].occupied)\n            revert OccupiedPlotError(_toiler.landlord, plotId);\n        if (plotId >= totalPlotsAvail) revert PlotTooHighError();\n        toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord]\n            .currentTaxRate;\n        ❌@>    // @audit missing toilerState[tokenId].plotId = plotId;\n        plotOccupied[_toiler.landlord][oldPlotId] = Plot({\n            occupied: false,\n            tokenId: 0\n        });\n```\n\n**Impact:**\nIf the amount of landlord's plots is decreased and user's token is inside a plot outside of the new range, the token won't be set as dirty.\nThis can lead to a situation where a user can stake initially on the first plots but after that move his token to a plot that is in the end of the range. When the plots are decreased, the contract will still think the token is in the first plot and won't set it as dirty and another user can stake his token in the same plot which breaks the intended functionality for LandManager.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Invalid validation in _farmPlots function allowing a malicious user repeated farming without locked funds",
    "Severity": "High",
    "Description": "This vulnerability allows for repeated farming and reward collection from a plot even after the landlord has unlocked funds, leading to an imbalance in the game economy and unfair advantage to certain players.\nThe _farmPlots function has a vulnerability where a plot with a plotId 0 can continue to be farmed and receive rewards even after the landlord has unlocked all funds.\nThe code snippet:\n\n```solidity\n            if (_getNumPlots(landlord) < _toiler.plotId) {\n                timestamp = plotMetadata[landlord].lastUpdated;\n                toilerState[tokenId].dirty = true;\n            }\n```\n\nThe _getNumPlots function should return zero when all funds are unlocked, invalidating the plot and setting the dirty flag.\nHowever, the current implementation fails to do so, it only determines if NumPlots is less than the plotId and allows plot 0 to remain farmable.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Miscalculation in _farmPlots function could lead to a user unable to unstake all NFTs",
    "Description": "The function _farmPlots() is used to calculate rewards farming rewards. This function is used in different scenarios, including like a modifier in the function unstakeMunchable() function when a user unstakes their NFT. Let's have a look at how finalBonus is calculated in the function:\n\n```solidity\nfinalBonus =\n    int16(\n        REALM_BONUSES[\n            (uint256(immutableAttributes.realm) * 5) +\n                uint256(landlordMetadata.snuggeryRealm)\n        ]\n    ) +\n    int16(\n        int8(RARITY_BONUSES[uint256(immutableAttributes.rarity)])\n    );\n```\n\nThe finalBonus consists of bonus from the realm (REALM_BONUSES), as well as a rarity bonus (RARITY_BONUSES).\nREALM_BONUSES can be either -10, -5, 0, 5 or 10, and RARITY_BONUSES can be either 0, 10, 20, 30 or 50.\nfinalBonus is meant to incentivize staking Munchables in a plot in a suitable realm. It can either be a positive bonus or reduction in the amount of schnibblesTotal. An example of a negative scenario is when REALM_BONUSES is -10 and RARITY_BONUSES is 0.\nLet's look at the calculation of schnibblesTotal:\n\n```solidity\nschnibblesTotal =\n        (timestamp - _toiler.lastToilDate) *\n        BASE_SCHNIBBLE_RATE;\nschnibblesTotal = uint256(\n    (int256(schnibblesTotal) +\n        (int256(schnibblesTotal) * finalBonus)) / 100\n    );\n```\n\nschnibblesTotal is typed as uint256; therefore, it is meant as always positive. The current calculation, however, will result in a negative value of schnibblesTotal, when finalBonus < 0, the conversion to uint256 will cause the value to evaluate to something near type(uint256).max. In that case the next calculation of schnibblesLandlord will revert due to overflow:\n\n```solidity\nschnibblesLandlord =\n    (schnibblesTotal * _toiler.latestTaxRate) /\n    1e18;\nThis is due to the fact that _toiler.latestTaxRate > 1e16.\n```\n\nSince unstakeMunchable() has a modifier forceFarmPlots(), the unstaking will be blocked if _farmPlots() reverts.",
    "Severity": "High",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "In `farmPlots()` an underflow in edge case leading to freeze of funds (NFT)",
    "Severity": "High",
    "Description": "The user won't be able to farm their plots or unstake due to the txn always panic reverting. Leading to loss of funds and DOS.\nThe problem arises whenever PRICE_PER_PLOT gets increased through configUpdated. Whenever it gets increased, then _getNumPlots will return less numbers for that LandLord, because its denominated by PRICE_PER_PLOT.\n\n```solidity \nfunction _getNumPlots(address _account) internal view returns (uint256) {\n       return lockManager.getLockedWeightedValue(_account) / PRICE_PER_PLOT;\n}\n```\n\nNow, the problem here is that NumPlots is not decreased due to LandLord unlocking funds but instead due to PRICE_PER_PLOT getting increased -> meaning that plotMetadata[landlord].lastUpdated is too old.\nwe check for NumPlots if it's lower than plotId of the user we then assign timeStamp variable to landlord.lastUpdated which is too old timeStamp (the last time the user locked funds).\nThen in Line 281, we subtract timestamp (which is now landlord.lastUpdated which is too old timeStamp) from _toiler.lastToilDate which is larger than timestamp that will lead to panic revert.\nLet's see why lastToilDate is larger:\nWe set this variable in stakeMunchable to block.timestamp here:\n\n```solidity\n         toilerState[tokenId] = ToilerState({\n             lastToilDate: block.timestamp,\n             plotId: plotId,\n             landlord: landlord,\n             latestTaxRate: plotMetadata[landlord].currentTaxRate,\n             dirty: false\n         });\n```\n\nThe `landlord.lastUpdated` is only updated when he lock or unlock funds (which in our case, didn't lock or unlock any funds before the user stake to him).",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Failure to update dirty flag in transferToUnoccupiedPlot prevents reward accumulation on valid plot",
    "Severity": "High",
    "Description": "The transferToUnoccupiedPlot function allows a user to transfer their Munchable to another unoccupied plot from the same landlord. This can be used for example by users currently staked in an invalid plot marked as “dirty”, meaning they will not be earning any rewards, to transfer to a valid plot so they can start earning rewards again.\nSince the function checks that the transfer is to a valid plot, it should mean users are now eligible to start earning rewards again. However, it doesn't update the user's dirty flag back to false, meaning the user will still not be earning any rewards even after they have moved to a valid plot.\n\n```solidity\n    function transferToUnoccupiedPlot(uint256 tokenId, uint256 plotId)\n        external\n        override\n        forceFarmPlots(msg.sender)\n        notPaused\n    {\n        (address mainAccount,) = _getMainAccountRequireRegistered(msg.sender);\n        ToilerState memory _toiler = toilerState[tokenId];\n        uint256 oldPlotId = _toiler.plotId;\n        uint256 totalPlotsAvail = _getNumPlots(_toiler.landlord);\n        if (_toiler.landlord == address(0)) revert NotStakedError();\n        if (munchableOwner[tokenId] != mainAccount) revert InvalidOwnerError();\n        if (plotOccupied[_toiler.landlord][plotId].occupied) {\n            revert OccupiedPlotError(_toiler.landlord, plotId);\n        }\n        if (plotId >= totalPlotsAvail) revert PlotTooHighError();\n        toilerState[tokenId].latestTaxRate = plotMetadata[_toiler.landlord].currentTaxRate;\n        plotOccupied[_toiler.landlord][oldPlotId] = Plot({occupied: false, tokenId: 0});\n        plotOccupied[_toiler.landlord][plotId] = Plot({occupied: true, tokenId: tokenId});\n        emit FarmPlotLeave(_toiler.landlord, tokenId, oldPlotId);\n        emit FarmPlotTaken(toilerState[tokenId], tokenId);\n    }\n```\n\nThe next time _farmPlots is called, since dirty is still true, it'll be skipped, accumulating no rewards.\n\n```solidity\n    function _farmPlots(address _sender) internal {\n        ...\n        for (uint8 i = 0; i < staked.length; i++) {\n            ...\n            if (_toiler.dirty) continue;\n            ...\n            );\n        }\n        accountManager.updatePlayer(mainAccount, renterMetadata);\n    }\n```\n\n**Impact:**\nUpdate the transferToUnoccupiedPlot function to reset the dirty flag to false and update the lastToilDate if it was previously marked as dirty when a user successfully transfers to a valid plot. This will ensure that users start earning rewards again once they are on a valid plot.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Users can farm on zero-tax land if the landlord locked tokens before the LandManager deployment",
    "Severity": "Medium",
    "Description": "The LandManager::stakeMunchable() does not verify whether the plotMetadata[landlord] is set or not.\nSince the LockManager contract is already deployed on-chain (on Blast), accounts that have locked their tokens before the LandManager deployment will need to trigger LandManager::triggerPlotMetadata() to update their LandManager.plotMetadata after the LandManager is deployed.\nThe current AccountManager interacts with the LockManager on-chain but does not introduce interaction with the LandManager during AccountManager::forceHarvest(). As a result, users can stake their tokens on land with a 0% tax rate if the landlord has not updated their plotMetadata and farm schnibbles without paying tax to the landlord until the landlord's plot metadata is initialized in the LandManager contract (via triggerPlotMetadata() and updatePlotMetadata()).\n**Impact:**\nUsers can farm schnibbles on plots with a 0% tax rate without paying any tax to the landlord, which disrupts the platform's revenue model and incentives.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Lingering token approvals in LandManager may lead to unauthorized staking of Munchables",
    "Severity": "Low",
    "Description": "The LandManager contract lacks a mechanism to revoke or reset token approvals after they are granted. This could potentially allow the contract to stake Munchables without the current intent of the token owner, if they forget to revoke approvals directly through the MunchNFT contract.\nIn the stakeMunchable function of the LandManager contract, there's a check for token approval:\n\n```solidity\nif (!munchNFT.isApprovedForAll(mainAccount, address(this)) &&\n    munchNFT.getApproved(tokenId) != address(this)\n) revert NotApprovedError();\n```\n\nThis check allows the staking operation to proceed if either a blanket approval for all tokens or a specific token approval is in place. However, there are two key issues:\nThe contract doesn't provide a way to revoke these approvals within its own functions.\nThere's no mechanism to reset or check for revoked approvals before subsequent staking operations.\nFor example, if a user grants approval and then later wants to revoke it, they must do so through the MunchNFT contract directly. If they forget to do this, the LandManager contract will still consider itself approved for future staking operations.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Tax rate updates bypass Timestamp refresh, distorting Schnibble calculations for invalid plots",
    "Severity": "Low",
    "Description": "The updateTaxRate function fails to update the lastUpdated timestamp when changing a landlord's tax rate. This can lead to incorrect Schnibble calculations in the _farmPlots function. The impact is particularly significant when dealing with plots that are no longer valid, as the function relies on the outdated lastUpdated timestamp for calculations.\n\n```solidity\nfunction updateTaxRate(uint256 newTaxRate) external override notPaused {\n    (address landlord, ) = _getMainAccountRequireRegistered(msg.sender);\n    if (newTaxRate < MIN_TAX_RATE || newTaxRate > MAX_TAX_RATE)\n        revert InvalidTaxRateError();\n    if (plotMetadata[landlord].lastUpdated == 0)\n        revert PlotMetadataNotUpdatedError();\n    uint256 oldTaxRate = plotMetadata[landlord].currentTaxRate;\n    plotMetadata[landlord].currentTaxRate = newTaxRate;\n    emit TaxRateChanged(landlord, oldTaxRate, newTaxRate);\n```\n\nThis function updates the currentTaxRate but doesn't update the lastUpdated timestamp in plotMetadata.\nThe problem manifests in the _farmPlots function:\n\n```solidity\nif (_getNumPlots(landlord) < _toiler.plotId) {\n    timestamp = plotMetadata[landlord].lastUpdated;\n    toilerState[tokenId].dirty = true;\n}\n```\n\nHere, for plots that are no longer valid, the function uses plotMetadata[landlord].lastUpdated as the timestamp. If tax rates have changed since the last update which is possible to lastUpdated, this could lead to incorrect Schnibble calculations.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Inaccurate timestamp handling in _farmPlots function leading to potential inaccurate Schnibbles calculation",
    "Severity": "Low",
    "Description": "The _farmPlots function in the LandManager contract uses the lastUpdated timestamp from plotMetadata to calculate the schnibbles earned by a renter. However, if the plot ID is greater than the number of plots available to the landlord, the function uses the latest lastUpdated timestamp, which can lead to inaccurate calculations if the landlord has updated the plots multiple times.\n\n```solidity\nfunction _farmPlots(address _sender) internal {\n    (\n        address mainAccount,\n        MunchablesCommonLib.Player memory renterMetadata\n    ) = _getMainAccountRequireRegistered(_sender);\n    uint256[] memory staked = munchablesStaked[mainAccount];\n    MunchablesCommonLib.NFTImmutableAttributes memory immutableAttributes;\n    ToilerState memory _toiler;\n    uint256 timestamp;\n    address landlord;\n    uint256 tokenId;\n    int256 finalBonus;\n    uint256 schnibblesTotal;\n    uint256 schnibblesLandlord;\n    for (uint8 i = 0; i < staked.length; i++) {\n        timestamp = block.timestamp;\n        tokenId = staked[i];\n        _toiler = toilerState[tokenId];\n        if (_toiler.dirty) continue;\n        landlord = _toiler.landlord;\n        // use last updated plot metadata time if the plot id doesn't fit\n        // track a dirty bool to signify this was done once\n        // the edge case where this doesn't work is if the user hasn't farmed in a while and the landlord\n        // updates their plots multiple times. then the last updated time will be the last time they updated their plot details\n        // instead of the first\n        if (_getNumPlots(landlord) < _toiler.plotId) {\n            timestamp = plotMetadata[landlord].lastUpdated;\n            toilerState[tokenId].dirty = true;\n        }\n        // existing code...\n    }\n    // existing code...\n}\n```\n\n**Impact:**\nThe impact of this issue is that the schnibblesTotal calculation may be based on an incorrect timestamp, leading to either overestimating or underestimating the schnibbles earned by the renter and the landlord. This can result in unfair distribution of rewards and potential dissatisfaction among users.",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Incorrect staking limit check allows users to stake 11 munchables instead of intended 10",
    "Severity": "Low",
    "Description": "The current implementation allows users to stake up to 11 Munchables, exceeding the intended maximum of 10. This could lead to an imbalance in the game protocol, potentially giving some users an unfair advantage by allowing them to earn more rewards than intended.\n\n```solidity\n    function stakeMunchable(\n        address landlord,\n        uint256 tokenId,\n        uint256 plotId\n    ) external override forceFarmPlots(msg.sender) notPaused {\n        // ... other checks ...\n @>     if (munchablesStaked[mainAccount].length > 10)\n            revert TooManyStakedMunchiesError();\n        // ... rest of the function\n}\n```\n\nThe condition munchablesStaked[mainAccount].length > 10 only reverts when trying to stake the 12th Munchable. This means:\n1. A user can successfully stake their 1st to 10th Munchable.\n2. They can also stake their 11th Munchable, as 11 is not greater than 10.\n3. The error is only thrown when trying to stake the 12th Munchable.\nAs a result, users can stake 11 Munchables instead of the intended maximum of 10.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Precision loss in landlord Schnibble calculation",
    "Severity": "Low",
    "Description": "The current implementation of the schnibble calculation for landlords can result in significant precision loss, potentially leading to landlords receiving fewer schnibbles than they should. In extreme cases, particularly with small schnibblesTotal values or low tax rates, landlords might receive no schnibbles at all when they should have received a small amount.\n\n```solidity\n schnibblesTotal =\n        (timestamp - _toiler.lastToilDate) *\n        BASE_SCHNIBBLE_RATE;\n    schnibblesTotal = uint256(\n        (int256(schnibblesTotal) +\n            (int256(schnibblesTotal) * finalBonus)) / 100\n    );\n```\n\nThe issue lies in how the calculation of schnibblesLandlord is done. The _toiler.latestTaxRate is likely represented as a value between 0 and 1e18 (where 1e18 is 100%). When multiplying schnibblesTotal by _toiler.latestTaxRate, the result is a very large number due to the tax rate's 18 decimal places. The subsequent division by 1e18 can lead to significant loss of precision or even round down to zero for small values of schnibblesTotal or low tax rates.\nFor example, let’s say schnibblesTotal is 100 and the tax rate is 1% (represented as 1e16 in LandManager):\nThe current calculation will be: schnibblesLandlord = (100 * 1e16) / 1e18 = 1000000000000000000 / 1e18 = 1\nThe expected calculation should be: schnibblesLandlord = 100 * (1e16 / 1e18) = 100 * 0.01 = 1\nAlthough in this case, the result is correct. Albeit, if schnibblesTotal were 99 instead:\nCurrent calculation: schnibblesLandlord = (99 * 1e16) / 1e18 = 990000000000000000 / 1e18 = 0\nExpected calculation: schnibblesLandlord = 99 * (1e16 / 1e18) = 99 * 0.01 = 0.99\nIn this case, the landlord receives 0 schnibbles instead of the expected 0.99 and will be on the losing end.",
    "Contract": ["src/managers/LandManager.sol"],
    "Recommendation": ""
  }
]
