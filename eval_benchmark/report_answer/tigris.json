[
  {
    "Issue": "assets deposited with Lock.extendLock function are lost",
    "Severity": "High",
    "Description": "The Lock contract allows end-users to interact with bonds.\n\nThere are two functions that allow to lock some amount of assets. The first function is Lock.lock  which creates a new bond. The second function is Lock.extendLock . This function extends the lock for some _period and / or increases the locked amount by some _amount.\n\nThe issue is that the Lock.extendLock function does not increase the value in totalLocked[_asset]. This however is necessary because totalLocked[_asset] is reduced when Lock.release is called.\n\nTherefore only the amount of assets deposited via Lock.lock can be released again. The amount of assets deposited using Lock.extendLock can never be released again because reducing totalLocked[_asset] will cause a revert due to underflow.\n\nSo the amount of assets deposited using Lock.extendLock is lost. \n\n```solidity \n  /**\n     * @notice Lock up tokens to create a bond\n     * @param _asset tigAsset being locked\n     * @param _amount tigAsset amount\n     * @param _period number of days to be locked for\n     */\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Reset the lock time and extend the period and/or token amount\n     * @param _id Bond id being extended\n     * @param _amount tigAsset amount being added\n     * @param _period number of days being added\n     */\n    function extendLock(\n        uint _id,\n        uint _amount,\n        uint _period\n    ) public {\n        address _asset = claim(_id);\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);\n    }\n\n    /**\n     * @notice Release the bond once it's expired\n     * @param _id Bond id being released\n     */\n    function release(\n        uint _id\n    ) public {\n        claimGovFees();\n        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);\n        totalLocked[asset] -= lockAmount;\n        IERC20(asset).transfer(_owner, amount);\n    }\n```\n\n",
    "Contract": ["contracts/Lock.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Riskless trades due to delay check",
    "Severity": "High",
    "Description": "Trading.limitClose() uses _checkDelay(). This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay. A malicious trader can exploit the Trading contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.\n\nThe exploit is based on three principles:\n\nThe stop-loss of a position can be updated without any delay checks, due to _checkDelay() not being called in updateTpSl()\nPositions can only be closed by MEV bots or other third parties after the block delay has been passed due to limitClose calling _checkDelay()\nThe block delay can be continuously renewed for a negligible cost\nBased on these three principles, the following method can be used to perform riskless trades:\nAssuming a current market price of 1,000 DAI, begin by opening a long limit order through initiateLimitOrder() at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through executeLimitOrder.\n\nAfter the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call limitClose. However, we can prevent them from doing so by continuously calling addToPosition with 1 wei when the block delay comes close to running out [1], which will renew the delay and thus stops limitClose from being called.\n\nWhile the trader keeps renewing the delay to stop his position from being closed, he watches the price development:\n\nIf the price goes down, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through liquidatePosition(). If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again.\nIf the price goes up, the trader calls updateTpSl() to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls updateTpSl() with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to _checkDelay().\nThe trader keeps calling updateTpSl() when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls limitClose() to close the order at the peak stop-loss.\n\nNotes\n[1]: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to addToPosition after every few transactions on the chain. However, block.number, which is used by the contract, actually returns the L1 block number and not the L2 block number.",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Certain fee configuration enables vaults to be drained",
    "Severity": "High",
    "Description": "An overflow in TradingLibrary.pnl() enables all funds from the vault contracts to be drained given a certain fee configuration is present. When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an unchecked block. Setting this value specifically to attack the vault leads to the Trading contract minting a huge (in the example below 10^36) Tigris tokens, which can then be given to the vault to withdraw assets.\n\nThe exploiter starts by setting himself as referrer, in order to later receive the referrer fees.\nThe next step is to open a short position at the current market price by calling initiateLimitOrder(). Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be 115792089237316195423570985008687907854269984665640564039467 for this specific market price, leverage and margin.\nThe order is then immediately executed through executeLimitOrder().\nThe final step is to close the order through limitClose(), which will then mint over 10^36 Tigris tokens to the attacker.\n\nThe bug takes place in TradingLibrary.pnl(), line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as _currentPrice and the order's original opening price is passed as _price. The take-profit has been specifically calculated so that 1e18 * _currentPrice / _price - 1e18 results in 0, meaning _payout = _margin (accInterest is negligible for this PoC).\nLine 48 then calculates the position size. Margin and leverage have been chosen so that _initPositionSize * _currentPrice does not overflow, resulting in a huge _positionSize which is returned from the function.\n\nLater, Trading._handleCloseFees() is called, under the condition that _payout > 0, which is why the overflow had to be calculated so precisely, as to not subtract from the _payout but still create a large _positionSize. _positionSize is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be daoFees = 2*referralFees -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge referralFees are directly minted and not included in the calculation in line 805.",
    "Contract": ["contracts/utils/TradingLibrary.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Bypass the maximum PnL check to take extra profit",
    "Severity": "High",
    "Description": "To protect the fund of vault, the protocol has a security mechanism which limits Maximum PnL is +500%. But the implementation is missing to check this limitation while addToPosition(), an attacker can exploit it to get more profit than expected. \n\n```solidity \n function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n```\n\n",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Malicious user can steal all assets in BondNFT",
    "Severity": "High",
    "Description": "Malicious user can drain all assets in BondNFT, and other users will lose their rewards. When calling BondNFT.claim() for an expired bond, it will recalculate accRewardsPerShare. This is because the reward after the expireEpoch does not belong to that expired bond and needs to be redistributed to all other bonds. \n\n```solidity \n function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n```\n\n \n\n```solidity \n  if (bond.expired) {\n      uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n      if (totalShares[bond.asset] > 0) {\n          accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n      }\n  }\n```\n\n According to the formula in the above code, we can find that although each subsequent claim() of the expired bond will transfer 0 reward, the accRewardsPerShare will be updated cumulatively. Thus, the pending rewards of all other users will increase every time the expired bond is claim()ed.\n\nA malicious user can exploit this vulnerability to steal all assets in BondNFT contract:\n\nCreate two bonds (B1, B2) with different expireEpoch\nAt some time after B1 has expired (B2 has not), keep calling Lock.claim(B1) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.\nCall Lock.claim(B2) to claim all pending rewards of B2.",
    "Contract": ["contracts/BondNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Incorrect calculation of new price while adding position",
    "Severity": "High",
    "Description": "The formula used for calculating `_newPrice in addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.\n\nThe wrong formula\n\n```solidity\n uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\nThe correct formula is\n\nuint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\nWhy this workS?\nGiven\n\nP1 = _trade.price\nP2 = _price\nP = _newPrice\nM1 = _trade.margin\nM2 = _addMargin\nM =  M1 + M2 = _newMargin\nL = _trade.leverage\nU1 = M1 * L  = old position in USD\nU2 = M2 * L = new position in USD\nU = U1 + U2 = total position in USD\nE1 = U1 / P1 = old position of base asset, such as ETH, of the pair\nE2 = U2 / P2 = new position of base asset of the pair\nE = E1 + E2 = total position of base asset of the pair\nThen\n\nP = U / E\n  = (U1 + U2) / (E1 + E2)\n  = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)\n  = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)\n  = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)\n  = P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]\n  = P1 * P2 * M / (M1 * P2 + M2 * P1)\nproven.\n```\n\n  \n\n```solidity\n function addToPosition(\n        uint _id,\n        uint _addMargin,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        address _stableVault,\n        address _marginAsset,\n        ERC20PermitData calldata _permitData,\n        address _trader\n    )\n        external\n    {\n        _validateProxy(_trader);\n        _checkOwner(_id, _trader);\n        _checkDelay(_id, true);\n        IPosition.Trade memory _trade = position.trades(_id);\n        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);\n        _checkVault(_stableVault, _marginAsset);\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n        _handleDeposit(\n            _trade.tigAsset,\n            _marginAsset,\n            _addMargin - _fee,\n            _stableVault,\n            _permitData,\n            _trader\n        );\n        position.setAccInterest(_id);\n        unchecked {\n            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);\n            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;\n            if (_trade.direction) {\n                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);\n            } else {\n                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     \n            }\n            _updateFunding(_trade.asset, _trade.tigAsset);\n            _addMargin -= _fee;\n            uint _newMargin = _trade.margin + _addMargin;\n            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\n            position.addToPosition(\n                _trade.id,\n                _newMargin,\n                _newPrice\n            );\n            \n            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);\n        }\n    }\n```\n\n",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "reentrancy attack during mint() function in Position contract which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value",
    "Severity": "High",
    "Description": "Function Position.mint() has been used in initiateLimitOrder() and initiateMarketOrder() and it doesn't follow check-effect-interaction pattern and code updates the values of _limitOrders, initId, _openPositions and position _tokenIds variables after making external call by using safeMint(). This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass _checkDelay() checks. attacker can perform this action:\n\ncall initiateLimitOrder() and create limit order with id equal to ID1 reenter (while _limitOrders for ID1 is not yet settled) with cancelLimitOrder(ID1) (no checkDelay() check) and remove other users limit orders because code would try to remove _limitOrderIndexes[_asset][ID1] position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the Position.burn() code.\ncall initiateMarketOrder() and create a position with ID1 and while initId[ID1] has not yet settled reenter the Trading with addToPosition(ID1) function (bypass checkDelay() because both action is opening) and increase the position size which would set initId[ID1] according to new position values but then when code execution returns to rest of mint() logic initId[ID1] would set by initial values of the positions which is very lower than what it should be and initId[ID1] has been used for calculating accuredInterest of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\nAs you can see by calling _safeMint() code would make external call to onERC721Received() function of the account address and the code sets the values for _limitOrders[], _limitOrderIndexes[], initId[], _openPositions[], _openPositionsIndexes[], _assetOpenPositions[], _assetOpenPositionsIndexes[] and _tokenIds. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\nthere could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:\n\n**scenario #1 where attacker remove other users limit orders and create broken storage state**\n\nattacker contract would call initiateLimitOrder() and code would create the limit order and mint it in the Position._safeMint() with ID1.\nthen code would call attacker address in _safeMint() function because of the onERC721Received() call check.\nvariables _limitOrders[], _limitOrderIndexes[ID1] are not yet updated for ID1 and _limitOrderIndexes[ID1] is 0x0 and ID1 is not in _limitOrder[] list.\nattacker contract would reenter the Trading contract by calling cancelLimitOrder(ID1).\ncancelLimitOrder() checks would pass and would tries to call Position.burn(ID1).\nburn() function would tries to remove ID1 from _limitOrders[] list but because _limitOrderIndexes[ID1] is 0 so code would remove the 0 index limit order which is belongs to another user.\nexecution would return to Position.mint() logic and code would add burned id token to _limitOrder[] list.\nso there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.\n\n**scenario #2 where attacker steal contract/users funds by wrong profit calculation**\n\nattacker's contract would call initiateMarketOrder(lowMargin) to create position with ID1 while the margin is low.\ncode would mint position token for attacker and in _safeMint() would make external call and call onERC721Received() function of attacker address.\nthe value of initId[ID1] is not yet set for ID1.\nattacker contract would call addToPosition(ID1, bigMargin) to increase the margin of the position the _checkDelay() check would pass because both actions are opening position.\ncode would increase the margin of the position and set the value of the initId[ID1] by calling position.addToPosition() and the value were be based on the newMargin.\nthe execution flow would receive the rest of Position.mint() function and code would set initId[ID1] based on old margin value.\nthen the value of initId[ID1] for attacker position would be very low which would cause accInterest to be very higher than it supposed to be for position(in Position.trades() function calculations ) and would cause _payout value to be very high (in pnl() function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\nso attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nthere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n```solidity\n function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n```\n\n",
    "Contract": ["contracts/Position.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Users can bypass the maxWinPercent limit using a partially closing",
    "Severity": "High",
    "Description": "Users can bypass the maxWinPercent limit using a partial closing.\n\nAs a result, users can receive more funds than their upper limit from the protocol.\n\nAs we can see from the documentation, there is limitation of a maximum PnL.\n\nMaximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\nAnd this logic was implemented like below in _closePosition().\n\nFile: 2022-12-tigris\\contracts\\Trading.sol\n\n```solidity\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n```\n\nBut it checks the maxWinPercent between the partial payout and full margin so the below scenario is possible.\n\nAlice opened an order of margin = 100 and PnL = 1000 after taking closing fees.\nIf maxWinPercent = 500%, Alice should receive 500 at most.\nBut Alice closed 50% of the position and she got 500 for a 50% margin because it checks maxWinPercent with _toMint = 500 and _trade.margin = 100\nAfter she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.\nAs a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\n\n```solidity\n function _closePosition(\n        uint _id,\n        uint _percent,\n        uint _price,\n        address _stableVault,\n        address _outputToken,\n        bool _isBot\n    )\n        internal\n    {\n        (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) = tradingExtension._closePosition(_id, _price, _percent);\n        position.setAccInterest(_id);\n        _updateFunding(_trade.asset, _trade.tigAsset);\n        if (_percent < DIVISION_CONSTANT) {\n            if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n            position.reducePosition(_id, _percent);\n        } else {\n            position.burn(_id);\n        }\n        uint256 _toMint;\n        if (_payout > 0) {\n            unchecked {\n                _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n                if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n                    _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n                }\n            }\n            _handleWithdraw(_trade, _stableVault, _outputToken, _toMint);\n        }\n        emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n    }\n```\n\n",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Incorrect Assumption of Stablecoin Market Stability",
    "Severity": "High",
    "Description": "\n\n```solidity\n/**\n    * @notice deposit an allowed token and receive tigAsset\n    * @param _token address of the allowed token\n    * @param _amount amount of _token\n    */\n    function deposit(address _token, uint256 _amount) public {\n        require(allowed[_token], \"Token not listed\");\n        IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n        IERC20Mintable(stable).mintFor(\n            _msgSender(),\n            _amount*(10**(18-IERC20Mintable(_token).decimals()))\n        );\n    }\n    /**\n    * @notice swap tigAsset to _token\n    * @param _token address of the token to receive\n    * @param _amount amount of _token\n    */\n    function withdraw(address _token, uint256 _amount) external returns (uint256 _output) {\n        IERC20Mintable(stable).burnFrom(_msgSender(), _amount);\n        _output = _amount/10**(18-IERC20Mintable(_token).decimals());\n        IERC20(_token).transfer(\n            _msgSender(),\n            _output\n        );\n    }\n```\n\nThe StableVault contract attempts to group all types of stablecoins under a single token which can be minted for any of the stablecoins supported by the system as well as burned for any of them.\n\nThis is at minimum a medium-severity vulnerability as the balance sheet of the StableVault will consist of multiple assets which do not have a one-to-one exchange ratio between them as can be observed by trading pools such as Curve as well as the Chainlink oracle reported prices themselves.\n\nGiven that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset (i.e. USDC which at the time of submission was valued at 0.99994853 USD) for a more desirable asset (i.e. USDT which at the time of submission was valued at 1.00000000 USD) acquiring an arbitrage in the price by selling the traded asset.\n\nTo illustrate the issue, simply view the exchange output you would get for swapping your USDC to USDT in a stablecoin pool (i.e. CurveFi) and then proceed to invoke deposit with your USDC asset and retrieve your incorrectly calculated USDT equivalent via withdraw.\n\nThe arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling our newly acquired USDT for USDC on the stablecoin pair we assessed earlier, ultimately ending up with a greater amount of USDC than we started with. This type of attack can be extrapolated by utilizing a flash-loan rather than our personal funds.\n\n",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "User can abuse tight stop losses and high leverage to make risk free trades",
    "Severity": "High",
    "Description": "User can abuse how stop losses are priced to open high leverage trades with huge upside and very little downside \n\n```solidity\n function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external view returns(uint _limitPrice, address _tigAsset) {\n        _checkGas();\n        IPosition.Trade memory _trade = position.trades(_id);\n        _tigAsset = _trade.tigAsset;\n\n        getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        uint256 _price = _priceData.price;\n\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n\n        if (_tp) {\n            if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n            _limitPrice = _trade.tpPrice;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n            _limitPrice = _trade.slPrice;\n        }\n    }\n```\n\n When closing a position with a stop loss the user is closed at their SL price rather than the current price of the asset. A user could abuse this in directional markets with high leverage to make nearly risk free trades. A user could open a long with a stop loss that in $0.01 below the current price. If the price tanks immediately on the next update then they will be closed out at their entrance price, only out the fees to open and close their position. If the price goes up then they can make a large gain.",
    "Contract": ["contracts/TradingExtension.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Not enough margin pulled or burned from user when adding to a position",
    "Severity": "High",
    "Description": "When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of tigAsset. In Trading.addToPosition the _handleDeposit function is called like this:\n\n```solidity\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin - _fee,\n    _stableVault,\n    _permitData,\n    _trader\n);\n```\n\nThe third parameter with the value of _addMargin - _fee is the amount pulled (or burned in the case of using tigAsset) from the user. The _fee value is calculated as part of the position size like this:\n\nuint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\nThe _handleOpenFees function mints _tigAsset to the referrer, to the msg.sender (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the _addMargin value paid by the user. Hence using _addMargin - _fee as the third parameter to _handleDeposit is going to pull or burn less margin than what was accounted for.\n\nAn example for correct usage can be seen in initiateMarketOrder:\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n```\n\nHere the third parameter to _handleDeposit is not _marginAfterFees but _tradeInfo.margin which is what the user has input on and is supposed to pay.",
    "Contract": ["contracts/Trading.sol"]
  },
  {
    "Issue": "`claimGovFees` function can cause assets to be stuck in the Lock contract",
    "Severity": "Medium",
    "Description": "When calling Lock.claimGovFees\n\n```solidity\nfunction claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n```\n\nassets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in BondNFT.distribute\n\n```solidity\n/**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n```\n\nThe funds from the GovNFT contract will get transferred into the Lock contract and then will be stuck there. They cannot be recovered.",
    "Contract": ["contracts/BondNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Bypass the delay security check to win risk free funds",
    "Severity": "Medium",
    "Description": "The current implementation uses _checkDelay() function to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\". But the protection is not enough, an attacker can long with low price and short with high price at the same tx but two orders to lock profit and take risk free funds.\n\n```solidity\nfunction _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n```\n\n",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Approved operators of Position token can't call Trading.initiateCloseOrder",
    "Severity": "Medium",
    "Description": "Approved operators of owner of Position token can't call several function in Trading. \n\n```solidity \n_checkOwner(_id, _trader);\n\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n```\n\n As you can see this function doesn't allow to approved operators of token's owner to pass the check. As result functions are not possible to call for them on behalf of owner.",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Failure in endpoint can cause minting more than one NFT with the same token id in different chains",
    "Severity": "Medium",
    "Description": "In the contract GovNFT, it is possible to bridge the governance NFT to other chains. It is also stated in the document that:\n\nNFT holders only earn the profits generated by the platform on the chain that the NFT is on.\n\nIt is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.\n\n```solidity\n function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```\n\nSuppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function crossChain to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A.\n\nThe endpoint is responsible to complete the bridging task on chain A.\nSuppose the endpoint calls the function lzReceive with low gas on chain A, so that the transaction will be not successful.\n\nSince the transaction was not successful, the message will be added as a failed message.\n\n`failedMessages[chainB][Bob's address][_nonce] = keccak256(_payload);`\n\nThen, due to network lag (or any server issue, or any failure in endpoint), the endpoint assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows:\nlzReceive ==> nonblockingLzReceive ==> _nonblockingLzReceive ==> _bridgeMint\nNow Bob has the NFT on chain A. Moreover, he has a failed message on chain A.\nThen Bob calls the function crossChain to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.\nNow, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.\nHe calls the function retryMessage to retry the failed message on chain A.\n\n```solidity\nfunction retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n```\n\nBy doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows:\nretryMessage ==> _nonblockingLzReceive ==> _bridgeMint\nNow Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability.\nNow he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\nPlease note that Bob can not call the function retryMessage while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.\nThe vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in endpoint it is possible to both having failed message and being able to mint it at the same time.\n\n",
    "Contract": ["contracts/GovNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "BondNFTs can revert when transferred",
    "Severity": "Medium",
    "Description": "BondNFTs should be transferrable. According the the proposal and the sponsor, BondNFTs should could be sold and borrowed against. The current implementation limits selling/depositing to only the same day that rewards are distributed for the tigAsset of the bond.\n\nThe impact if no rewards are distributed in the same day:\n\nBondNFTs listed on open markets will not be able to fulfil the orders\nBondNFTs deposited as collateral will not be release the collateral\nBecause other market/platforms used for selling/depositing will not call claimGovFees to distribute rewards, they will revert when trying to transfer the BondNFT.\n\nRealistic examples could be BondNFTs listed on opensea.\n\nExample of reasons why rewards would not be distributed in the same day:\n\nLow activity from investors, rewards are distirbuted when users lock/release/extend\ntigAsset is blacklisted in BondNFT, rewards will not be distributed in such case. BondNFT has a mechanism to update the time tigAsset rewards are distributed. It uses a map that points to the last timestamp rewards were distributed for epoch[tigAsset].\n\n```solidity\nfunction distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n```\n\n(Please note that if the asset is blacklisted through allowedAsset the epoch[tigAsset] will not be updated)\n\nWhen BondNFTs are transfered, a check is implemented to make sure epoch[tigAsset] is updated to the current day.\nAccording to the sponsor the reason for this check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated.\n\n```solidity\nfunction _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n```\n\nAs can be seen above, if epoch[tigAsset] is not set to the same day of the transfer, the transfer will fail and the impacts in the impact section will happen.\n\n",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "Trading will not work on ethereum if USDT is used",
    "Severity": "Medium",
    "Description": "Traders will not be able to:\n\nInitiate a market order\nAdd margin\nAdd to position\ninitiate limit order\nIf USDT is set as the margin asset and protocol is deployed on ethereum.\n\n(Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on ethereum)\n\n```solidity\nfunction _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault, ERC20PermitData calldata _permitData, address _trader) internal {\n        IStable tigAsset = IStable(_tigAsset);\n        if (_tigAsset != _marginAsset) {\n            if (_permitData.usePermit) {\n                ERC20Permit(_marginAsset).permit(_trader, address(this), _permitData.amount, _permitData.deadline, _permitData.v, _permitData.r, _permitData.s);\n            }\n            uint256 _balBefore = tigAsset.balanceOf(address(this));\n            uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n            IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n            IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n            IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n            if (tigAsset.balanceOf(address(this)) != _balBefore + _margin) revert BadDeposit();\n            tigAsset.burnFrom(address(this), tigAsset.balanceOf(address(this)));\n        } else {\n            tigAsset.burnFrom(_trader, _margin);\n        }        \n    }\n```\n\n",
    "Contract": ["contracts/BondNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "maxBridge has no effect",
    "Severity": "Medium",
    "Description": "In GovNFT, setMaxBridge function is provided to set maxBridge, but this variable is not used, literally it should be used to limit the number of GovNFTs crossing chain, but it doesn't work in GovNFT.\n\n```solidity \n    uint256 public maxBridge = 20;\n...\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n\nuint256 public maxBridge = 20;\nILayerZeroEndpoint public endpoint;\n\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n```\n\n",
    "Contract": ["contracts/GovNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "safeTransferMany() doesn't actually use safe transfer",
    "Severity": "Medium",
    "Description": "Both BondNFT and GovNFT are an ERC721 implementation, they both also have a function named safeTransferMany() which its name implies is supposed to safe transfer many tokens at once. However the function doesn't actually safe transfer (doesn't ) Users might use this function, expecting it to verify that the receiver is an ERC721Receiver, but will get their funds stuck in a contract that doesn't support ERC721.\n\n```solidity\n function safeTransferMany(address _to, uint[] calldata _ids) external {\n        for (uint i=0; i<_ids.length; i++) {\n            _transfer(_msgSender(), _to, _ids[i]);\n        }\n    }\n```\n\n",
    "Contract": ["contracts/GovNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "extendLock force a user to extend the bond at least for current bond.period",
    "Severity": "Medium",
    "Description": "The current implementation forces a user to extend their bonds for at least they current bond period. These mean that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nIf we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current BondNFT.extendLock function should be refactored.\n\nCurrent BondNFT.extendLock function does not work as expected, forcing user who want to extend their bond to extend them at least for their current bond.period.\nFor bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.\n\n```solidity\nfunction extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n```\n\n",
    "Contract": ["contracts/BondNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "BondNFT.sol#claim() needs to correct all the missing epochs",
    "Severity": "Medium",
    "Description": "In BondNFT.sol#claim(), accRewardsPerShare[][] is amended to reflect the expired shares. But only accRewardsPerShare[bond.asset][epoch[bond.asset]] is updated. All the epochs between bond.expireEpoch-1 and epoch[bond.asset] are missed.\n\nHowever, some users claimable rewards calculation could be based on the missed epochs. As a result, the impact might be:\n\naccRewardsPerShare is inaccurate for the epochs in between.\nSome users could lose reward due to wrong accRewardsPerShare, some users might receive undeserved rewards.\nSome rewards will be locked in the contract.\n\n```solidity\nfunction claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n\nfunction idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n```\n\n",
    "Contract": [],
    "Recommendation": ""
  },
  {
    "Issue": "_handleOpenFees returns an incorrect value for _feePaid. This directly impacts margin calculations",
    "Severity": "Medium",
    "Description": "\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\n\n_feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n```\n\nFormula for fee paid in Line 734 is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk\n\nOn initiating a market order, Margin is adjusted for the fees that is charged by protocol. This adjustment is in Line 178 of Trading. Fees computed by _handleOpenFees  is deducted from Initial margin posted by user.\n\nformula misses to account the 2*referralFee component while calculaing _feePaid\n\nNote that _feePaid as per formula in Line 734 is the sum of _daoFeesPaid', and sum of burnerFee&botFee. _daoFeesPaidis calculated from_fees.daoFeeswhich itself is calculated by subtracting2*referralFeeandbotFee`.\n\nSo when we add back burnerFee and botFee to _feePaid, we are missing to add back the 2*referralFee which was earlier excluded when calculating _daoFeesPaid. While botFee is added back correctly, same adjustment is not being done viz-a-viz referral fee.\n\nThis results in under calculating the _feePaid and impacts the rewards paid to the protocol NFT holders.",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "_checkDelay will not work properly for Arbitrum or Optimism due to block.number",
    "Severity": "Medium",
    "Description": "Trade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices.\n\n```solidity\nfunction _checkDelay(uint _id, bool _type) internal {\n    unchecked {\n        Delay memory _delay = blockDelayPassed[_id];\n        //in those situations\n        if (_delay.actionType == _type) {\n            blockDelayPassed[_id].delay = block.number + blockDelay;\n        } else {\n            if (block.number < _delay.delay) revert(\"0\"); //Wait\n            blockDelayPassed[_id].delay = block.number + blockDelay;\n            blockDelayPassed[_id].actionType = _type;\n        }\n    }\n}\n```\n\n_checkDelay enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. According to Arbitrum Docs block.number returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. The user would open their position 1 Arbitrum block before the sync happens, the close it the very next block. It would appear that there has been 5 block (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks I would be impossible to block this behavior through parameter changes.\n\nIt also presents an issue for Optimism because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately.",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "distribute() won't update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch",
    "Severity": "Medium",
    "Description": "Function BondNFT.createLock() creates a bond and it sets bond's mint epoch as epoch[asset], function Lock.lock() first calls claimGovFees() which calls BondNFT.distribute() for all assets and updates the epoch[assets] for all assets. so during normal bond creation the value of epoch[asset] would be updated and bond would be created from today epoch to today+period epoch. but if totalShares[tigAsset] == 0 for an asset, then distribute() won't update epoch[asset] for that asset and epoch[asset] will be some old epoch(will be the start time where asset is added or the time where totalShares[_tigAsset] != 0). This would make createLock() to set very wrong value for bond's mint epoch when totalShares[tigAsset] == 0.\nThis would happen for the first bond that has been created for that asset always and it will happen again if for some period totalShares[asset] become 0, then the next bond would have wrong mint epoch. or setAllowedAsset(asset, false) has been called for that asset.\n\nThis is distribute() code in BondNFT contract:\n\n```solidity\nfunction distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n```\n\nAs you can see when totalShares[_tigAsset] == 0 then the value of epoch[_tigAsset] won't get updated to the today. and there is no other logics in the code to update epoch[tigAsset]. so when totalShares[_tigAsset] == 0 then the value of the epoch[tigAsset] would be out dated. this would happen when asset is recently added to the BondNFT assets or when in some time there is no bond left.\nWhen this condition happens and a user call Lock.lock() to create a bond the lock() function would call claimGovFees() to update rewards in BondNFT but because for that asset the value of totalShares are 0 so for that asset epoch[] won't get updated and in the BondNFT.createLock() the wrong value would set as bond't mint epoch.\nThis is Lock.lock() code:\n\n```solidity\nfunction lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\nAnd this is BondNFT.createLock() code:\n\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n```\n\nif a bond get wrong value for mint epoch it would have wrong value for expire epoch and user would get a lot of share by lock for small time. for example this scenario:\n\nlet's assume epoch[asset1] is out dated and it shows 30 days ago epoch. (allowedAsset[asset1] was false so locking was not possible and then is set as true after 30 days)\nduring this time because totalShare[asset1] was 0 so distribute() function won't udpate epoch[asset1] and epoch[asset1] would show 30 days ago.\nattacker would create a lock for 32 days by calling Lock.lock(asset1). code would call BondNFT.createLock() and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days.\nsome reward would get distributed into the BondNFT for the asset1.\nother users would create lock too.\nattacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.\nso attacker was able to create lock for long time and get shares and rewards based on that but attacker can release lock after short time.",
    "Contract": ["contracts/BondNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "User can close an order via limitClose(), and take bot fees to themselves",
    "Severity": "Medium",
    "Description": "Bot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the DAO fee and sent to the closing bot. A user can use that to reduce the DAO fees for closing an order and keeping it to themselves. Instead of closing the order via initiateClose(), the user can use a proxy contract to update the stop-loss value and then limitClose() the order. Since that is done in one function call, no bot can run the limitClose() and the bot fee will go to the user.",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referredTrading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred",
    "Severity": "Medium",
    "Description": "When initiateMarketOrder is called, _marginAfterFees are calculated and then use it to calculate _positionSize:\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\nThe problem is that _handleOpenFees does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected.\n\nFor a referred trade, initiateMarketOrder always opens a position greater than the one supposed, by allowing to use more margin than the one expected.\n\n\nThe output of _handleOpenFees is _feePaid, which is calculated once, and it does not consider referralFees\n\n```solidity\n// No refferal fees are considered\n_feePaid =\n    _positionSize\n    * (_fees.burnFees + _fees.botFees) // get total fee%\n    / DIVISION_CONSTANT // divide by 100%\n    + _daoFeesPaid;\nThen we can notice that, if the output of _handleOpenFees did not consider referral fees, neither would _marginAfterFees do\n\nuint256 _marginAfterFees =\n    _tradeInfo.margin-\n    _handleOpenFees(\n        _tradeInfo.asset,\n        _tradeInfo.margin*_tradeInfo.leverage/1e18, \n        _trader,\n        _tigAsset,\n        false);\n\n// @audit Then _positionSize would be greater than what is supposed to be, allowing to create a position greater than expected\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\n",
    "Contract": ["contracts/Trading.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "executeLimitOrder() modifies open-interest with a wrong position value",
    "Severity": "Medium",
    "Description": "After a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the totalShares value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.\n\nA bond can be released after it expired by the owner of it. If the owner doesn't release it for 7 days, anybody else can release it as well. As long as the owner doesn't release it, the issue will be in effect for at least 7 epochs.\n\nSince this causes a loss of funds for every bond holder I rate it as HIGH. It's likely to be an issue since you can't guarantee that bonds will be released the day they expire.\n\n```solidity\ntotalShares[bond.asset] -= bond.shares;\naccRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n```\n\n",
    "Contract": ["contracts/BondNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called",
    "Severity": "Medium",
    "Description": "Calling the following Trading._handleOpenFees function does not approve the GovNFT contract for spending any of the Trading contract's _tigAsset balance, which is unlike calling the Trading._handleCloseFees function below that executes IStable(_tigAsset).approve(address(gov), type(uint).max). Due to this lack of approval, when calling the Trading._handleOpenFees function without the Trading._handleCloseFees function being called for the same _tigAsset beforehand, the GovNFT.distribute function's execution of IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) in the try...catch... block will not transfer any _tigAsset amount as the trade's DAO fees to the GovNFT contract. In this case, although the Governance NFT holder, whose NFT was minted before the Trading._handleOpenFees function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such Trading._handleOpenFees function call because none of the DAO fees were transferred to the GovNFT contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.\n\n```solidity\nfunction _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = openFees;\n        unchecked {\n            _fees.daoFees = _fees.daoFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.burnFees = _fees.burnFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.referralFees = _fees.referralFees * asset.feeMultiplier / DIVISION_CONSTANT;\n            _fees.botFees = _fees.botFees * asset.feeMultiplier / DIVISION_CONSTANT;\n        }\n        address _referrer = tradingExtension.getRef(_trader); //referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _referrer,\n                    _positionSize\n                    * _fees.referralFees // get referral fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.referralFees*2;\n        }\n        if (_isBot) {\n            unchecked {\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _positionSize\n                    * _fees.botFees // get bot fee%\n                    / DIVISION_CONSTANT // divide by 100%\n                );\n            }\n            _fees.daoFees = _fees.daoFees - _fees.botFees;\n        } else {\n            _fees.botFees = 0;\n        }\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees) // get total fee%\n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n            emit FeesDistributed(\n                _tigAsset,\n                _daoFeesPaid,\n                _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n                _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n                _positionSize * _fees.botFees / DIVISION_CONSTANT,\n                _referrer\n            );\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n\nfunction _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n        Fees memory _fees = closeFees;\n        uint _daoFeesPaid;\n        uint _burnFeesPaid;\n        uint _referralFeesPaid;\n        unchecked {\n            _daoFeesPaid = (_positionSize*_fees.daoFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            _burnFeesPaid = (_positionSize*_fees.burnFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n        }\n        uint _botFeesPaid;\n        address _referrer = tradingExtension.getRef(_trader);//referrals.getReferral(referrals.getReferred(_trader));\n        if (_referrer != address(0)) {\n            unchecked {\n                _referralFeesPaid = (_positionSize*_fees.referralFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n            }\n            IStable(_tigAsset).mintFor(\n                _referrer,\n                _referralFeesPaid\n            );\n             _daoFeesPaid = _daoFeesPaid-_referralFeesPaid*2;\n        }\n        if (_isBot) {\n            unchecked {\n                _botFeesPaid = (_positionSize*_fees.botFees/DIVISION_CONSTANT)*asset.feeMultiplier/DIVISION_CONSTANT;\n                IStable(_tigAsset).mintFor(\n                    _msgSender(),\n                    _botFeesPaid\n                );\n            }\n            _daoFeesPaid = _daoFeesPaid - _botFeesPaid;\n        }\n        emit FeesDistributed(_tigAsset, _daoFeesPaid, _burnFeesPaid, _referralFeesPaid, _botFeesPaid, _referrer);\n        payout_ = _payout - _daoFeesPaid - _burnFeesPaid - _botFeesPaid;\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n\n\nfunction distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n```\n\nFunctions like Trading.initiateMarketOrder further call the Trading._handleOpenFees function so this POC uses the Trading.initiateMarketOrder function.",
    "Contract": ["contracts/Trading.sol", "contracts/GovNFT.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Chainlink price feed is not sufficiently validated and can return stale price",
    "Severity": "Medium",
    "Description": "As mentioned by https://docs.tigris.trade/protocol/oracle, Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted. The Chainlink price verification logic in the following TradingLibrary.verifyPrice function serves this purpose. However, besides that IPrice(_chainlinkFeed).latestAnswer() uses Chainlink's deprecated latestAnswer function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When assetChainlinkPriceInt != 0 is true, it is still possible that assetChainlinkPriceInt is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.\n\n```solidity  \n   function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        ...\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n```\n\n",
    "Contract": ["contracts/TradingLibrary.sol"],
    "Recommendation": ""
  }
]
