[
  {
    "Issue": "Most users won't be able to claim their share of Uniswap fees",
    "Severity": "High",
    "Description": "Users should be able to claim Uniswap fees for their current liquidity position regardless of their pending vestings, or cliff. But most users won't be able to claim those Uniswap fees.\n\nIt is also possible that they won't be able to claim their vesting if they accumulate sufficient unclaimed Uniswap fees.\n\nThe root issue is that the claim() function collects ALL the owed tokens at once, including the ones from the burnt liquidity, but also the fees corresponding to ALL positions:\n\n```solidity\n    (uint128 amountCollected0, uint128 amountCollected1) = pool.collect(\n\n        address(this),\n\n        TICK_LOWER,\n\n        TICK_UPPER,\n\n@>      type(uint128).max,\n\n@>      type(uint128).max\n);\n```\n\nThen the platform fees are sent alongside the Uniswap fees from the users that still didn't claim amountCollected - amount:\n\n```solidity\nTransferHelper.safeTransfer(_cachedPoolKey.token0, feeTaker, amountCollected0-amount0);\n\nTransferHelper.safeTransfer(_cachedPoolKey.token1, feeTaker, amountCollected1-amount1);\n```\n\nThe next time a user calls claim(), pool.collect() will not contain any Uniswap fees as all of them have already been claimed and sent to the first claimer and the rest to the fee taker. If the platform fees are enough to cover the owed fees for the claiming user, the transaction might succeed (this may be possible if the burnt liquidity is enough).\n\nAs time passes, more fees will be accumulated, and when Uniswap fees > platform fees, the transaction will also revert even for unclaimed vestings with liquidity to burn. In addition, in most cases after the initial vesting, users won't be able to claim Uniswap fees, as no fees will be collected, and the contract doesn't hold those assets (they have been sent to the fee taker).",
    "Contract": ["src/ILOPool.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Vultisig whitelisting can be bypassed by anyone",
    "Severity": "High",
    "Description": "Whitelist launch will be bricked. Anyone can buy tokens, and also bypass the 3 ETH limit by buying via other non-whitelisted accounts. This will have an impact on price and ruin the opportunities of legit whitelisted users.\n\n```solidity\nif (_allowedWhitelistIndex == 0 || _whitelistIndex[to] > _allowedWhitelistIndex) {\n        revert NotWhitelisted();\n}\n```\n\n_allowedWhitelistIndex is the max index allowed, and works as a limit, not a whitelist flag. Once it is set (which must happen for all whitelists), any non-whitelisted user can bypass it. This is because _whitelistIndex[to] will be 0, and _whitelistIndex[to] > _allowedWhitelistIndex will never revert (0 > 1000, for example).",
    "Contract": ["hardhat-vultisig/contracts/Whitelist.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Adversary can prevent the launch of any ILO pool with enough raised capital at any moment by providing single-sided liquidity",
    "Severity": "High",
    "Description": "It is possible to prevent the launch of any ILO pool at any time, including pools that have reached their total raised amount. This can be done at any time and the cost for the attacker is negligible.\n\nNot only this is a DOS of the whole protocol, but the attack can be performed at the very end of the sale, making users lose a lot on gas fees, considering it will be deployed on Ethereum Mainnet. Hundreds or thousands of users will participate in ILO pools via buy(), and will have to later call claimRefund() to get their “raise” tokens back.\n\nToken launches that were deemed to be successful will be blocked after raising funds from many users, and this will most certainly affect the perception of the token, and its pricing on any attempt of a future launch/sale.\n\nThe ILOManager contract has a check to assert that the price at the time of the token launch is the same as the one initialized by the project. If they differ the transaction will revert, and the token launch will fail:\n\n```solidity \nfunction launch(address uniV3PoolAddress) external override {\n    require(block.timestamp > _cachedProject[uniV3PoolAddress].launchTime, \"LT\");\n    (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(uniV3PoolAddress).slot0();\n@>  require(_cachedProject[uniV3PoolAddress].initialPoolPriceX96 == sqrtPriceX96, \"UV3P\");\n    address[] memory initializedPools = _initializedILOPools[uniV3PoolAddress];\n    require(initializedPools.length > 0, \"NP\");\n    for (uint256 i = 0; i < initializedPools.length; i++) {\n        IILOPool(initializedPools[i]).launch();\n    }\n    emit ProjectLaunch(uniV3PoolAddress);\n}\n```\n\nThe problem is that sqrtPriceX96 can be easily manipulated in Uniswap v3 Pools when there is no liquidity in it via a swap with no cost. In theory, this could be mitigated by anyone by swapping back to get back to the original price. But there is an additional problem which makes the severity of the attack even higher. The attacker can add single-sided liquidity to the pool (just the Raise Token) after the price was manipulated.\n\nBy adding liquidity in ticks greater than the manipulated price, but lower than the expected initial price, it would require the swapper to provide some SALE_TOKEN, which should not be available at this moment, since they should all be in the ILO pool.\n\nEven if the project admin has some SALE_TOKEN, the attacker can mint a higher amount of liquidity by providing more single-sided RAISE_TOKEN liquidity, making the needed amount of SALE_TOKEN even higher.",
    "Contract": ["src/ILOManager.sol", "src/ILOPool.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Vultisig should be burnable",
    "Severity": "Medium",
    "Description": "The Vultisig token, as described in its documentation, is expected to include a burnable feature. However, the current implementation of the Vultisig token contract lacks the necessary functions to support token burning. This report identifies the impact of this missing functionality and provides a recommended solution to implement the burn feature. The vultisig stated that they forgot to add this functionality. Non-compliance with Documentation: Users and developers relying on the documentation will expect burn functionality, leading to confusion and potential loss of trust when they find it missing.",
    "Contract": ["hardhat-vultisig/contracts/Vultisig.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "claim function lacks slippage controls for amount0 and amount1 returned by pool.burn function call",
    "Severity": "Medium",
    "Description": "Because the claim function does not have slippage controls for amount0 and amount1 returned by the pool.burn function call, the claim function call can suffer from price manipulation on the associated Uniswap v3 pool. If a price manipulation frontruns the claim transaction, the claimed token amounts can be much less than what they should be.\n\nWhen calling the following claim function, there are no slippage controls for amount0 and amount1 returned by the pool.burn function call. This is unlike Uniswap's decreaseLiquidity function below that does execute require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check'), where amount0 and amount1 are also returned by the pool.burn function call. Thus, if a price manipulation on the associated Uniswap v3 pool frontruns the claim transaction, amount0 and amount1 can be much less than what they should be when the claim transaction is executed, which would cause the investor to claim token amounts that are much less than what they should be.\n\n```solidity\n  function claim(uint256 tokenId) external payable override\n        isAuthorizedForToken(tokenId)\n        returns (uint256 amount0, uint256 amount1)\n    {\n        // only can claim if the launch is successfully\n        require(_launchSucceeded, \"PNL\");\n        // calculate amount of unlocked liquidity for the position\n        uint128 liquidity2Claim = _claimableLiquidity(tokenId);\n        IUniswapV3Pool pool = IUniswapV3Pool(_cachedUniV3PoolAddress);\n        Position storage position = _positions[tokenId];\n        {\n            IILOManager.Project memory _project = IILOManager(MANAGER).project(address(pool));\n            uint128 positionLiquidity = position.liquidity;\n            require(positionLiquidity >= liquidity2Claim);\n            // get amount of token0 and token1 that pool will return for us\n            (amount0, amount1) = pool.burn(TICK_LOWER, TICK_UPPER, liquidity2Claim);\n            // get amount of token0 and token1 after deduct platform fee\n            (amount0, amount1) = _deductFees(amount0, amount1, _project.platformFee);\n            bytes32 positionKey = PositionKey.compute(address(this), TICK_LOWER, TICK_UPPER);\n            // calculate amount of fees that position generated\n            (, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, , ) = pool.positions(positionKey);\n            uint256 fees0 = FullMath.mulDiv(\n                                feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128,\n                                positionLiquidity,\n                                FixedPoint128.Q128\n     );\n          uint256 fees1 = FullMath.mulDiv(feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128,\n                                positionLiquidity,FixedPoint128.Q128);\n            // amount of fees after deduct performance fee\n            (fees0, fees1) = _deductFees(fees0, fees1, _project.performanceFee);\n           // fees is combined with liquidity token amount to return to the user\n            amount0 += fees0;\n            amount1 += fees1;\n            position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128;\n            position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128;\n            // subtraction is safe because we checked positionLiquidity is gte liquidity2Claim\n            position.liquidity = positionLiquidity - liquidity2Claim;\n            ...\n        }\n        // real amount collected from uintswap pool\n        (uint128 amountCollected0, uint128 amountCollected1) = pool.collect(\n            address(this),\n            TICK_LOWER,\n            TICK_UPPER,\n            type(uint128).max,\n            type(uint128).max\n        );\n        ...\n        // transfer token for user\n        TransferHelper.safeTransfer(_cachedPoolKey.token0, ownerOf(tokenId), amount0);\n        TransferHelper.safeTransfer(_cachedPoolKey.token1, ownerOf(tokenId), amount1);\n        ...\n        address feeTaker = IILOManager(MANAGER).FEE_TAKER();\n        // transfer fee to fee taker\n        TransferHelper.safeTransfer(_cachedPoolKey.token0, feeTaker, amountCollected0-amount0);\n        TransferHelper.safeTransfer(_cachedPoolKey.token1, feeTaker, amountCollected1-amount1);\n    }\n```\n\n \n\n```solidity\n\nfunction decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        override\n        isAuthorizedForToken(params.tokenId)\n        checkDeadline(params.deadline)\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(params.liquidity > 0);\n        Position storage position = _positions[params.tokenId];\n        uint128 positionLiquidity = position.liquidity;\n        require(positionLiquidity >= params.liquidity);\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n        (amount0, amount1) = pool.burn(position.tickLower, position.tickUpper, params.liquidity);\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');\n        ...\n    }\n```\n\n",
    "Contract": ["src/ILOPool.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Transfer of ILOPool NFT token to different account allows for users to bypass the pool's maxCapPerUser invariant",
    "Severity": "Medium",
    "Description": "The ILOPool smart contract enables investors to acquire a locked liquidity position represented as an NFT. When an investor invokes the buy() function, they transfer a specified amount of RAISE TOKENS into the pool, thereby opening a position and receiving an ILOPool NFT token that signifies their ownership. The protocol enforces certain invariants related to the minimum and maximum amounts of RAISE TOKENS required for the sale. Furthermore, there is a restriction on the maximum number of tokens each investor can contribute per sale, defined by maxCapPerUser.\n\n```solidity\nstruct InitPoolParams {\n\n        address uniV3Pool;\n\n        int24 tickLower; \n\n        int24 tickUpper;\n\n        uint160 sqrtRatioLowerX96; \n\n        uint160 sqrtRatioUpperX96;\n\n        uint256 hardCap; // total amount of raise tokens\n\n        uint256 softCap; // minimum amount of raise token needed for launch pool\n\n        uint256 maxCapPerUser; // TODO: user tiers\n\n        uint64 start;\n\n        uint64 end;\n\n\n        // config for vests and shares. \n\n        // First element is always for investor \n\n        // and will mint nft when investor buy ilo\n\n        VestingConfig[] vestingConfigs;\n\n    }\n```\n\nEach subsequent call to buy() is intended to increase the investor's raised amount for their position, ensuring that the user's total raised amount does not surpass the sale's maxCapPerUser. However, this restriction can be circumvented by transferring an existing ILOPool NFT token to another account and invoking buy() again. This action results in the protocol minting a new NFT (thus creating a new position) for the investor. Consequently, the maxCapPerUser check applies to the new position's raised amount, rather than the total amount contributed by the investor.\n\n```solidity\n// If the investor already has a position, increase the raise amount and liquidity\n\n// Otherwise, mint a new NFT for the investor and assign vesting schedules\n\n@> if (balanceOf(recipient) == 0) { // The user can easily set their balance to 0\n\n   _mint(recipient, (tokenId = _nextId++));\n\n   _positionVests[tokenId].schedule = _vestingConfigs[0].schedule;\n\n} else {\n\n   tokenId = tokenOfOwnerByIndex(recipient, 0);\n\n}\n\n\nPosition storage _position = _positions[tokenId];\n\n@> require(raiseAmount <= saleInfo.maxCapPerUser - _position.raiseAmount, \"UC\"); // User can open multiple positions bypassing the `maxCapPerUser` constraint\n\n_position.raiseAmount += raiseAmount;\n\n```\n\nThis vulnerability allows an investor to:\n\nBypass the maxCapPerUser constraint by transferring their NFT to another account and purchasing additional tokens, thus minting new NFTs and opening new positions, which in turn breaks a core invariant.\nPrevent other investors from participating in the pool by monopolizing the contributions and reaching the pool's hardCap.",
    "Contract": ["src/ILOPool.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Pools can be initialized with a price outside of the expected tick ranges",
    "Severity": "Low",
    "Description": "There is a wrong check in initILOPool() here: sqrtRatioLowerX96 < sqrtRatioUpperX96.\n\n```solidity\nrequire(sqrtRatioLowerX96 < _project.initialPoolPriceX96 && sqrtRatioLowerX96 < sqrtRatioUpperX96, \"RANGE\");\n```\n\nThis means that an ILO Pool can be initialized with a price outside of the tick range, and it will be impossible for users to buy liquidity in the ILO Pool as the slippage check in buy() will revert.\n\nIt can be tested by replacing this line to tickUpper: MIN_TICK_500 + 10 and run any test that launches a pool.",
    "Contract": ["src/ILOManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Vestings can be created with end time lower than their start time",
    "Severity": "Low",
    "Description": "There is no check in _validateVestSchedule() to prevent setting an end date before the start date. This could potentially be dangerous as it could cause an underflow when calculating the unlocked liquidity.",
    "Contract": ["src/ILOPool.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "Adversary can squat whitelist spots",
    "Severity": "Low",
    "Description": "checkWhitelist() verifies that _whitelistIndex[to] > _allowedWhitelistIndex:\n\n    if (_allowedWhitelistIndex == 0 || _whitelistIndex[to] > _allowedWhitelistIndex) {\n\n        revert NotWhitelisted();\n\n    }\nThis works correctly while an admin whitelist is currently running. But the problem arrives when the whitelist is disabled, and allows anyone to register as a whitelisted user:\n\n```solidity\n    receive() external payable {\n\n@>      if (_isSelfWhitelistDisabled) {\n\n            revert SelfWhitelistDisabled();\n\n        }\n\n        if (_isBlacklisted[_msgSender()]) {\n\n            revert Blacklisted();\n\n        }\n\n        _addWhitelistedAddress(_msgSender());\n\n        payable(_msgSender()).transfer(msg.value);\n\n    }\n\n```\n\nThis allows an attacker to squat whitelist spots, as the _allowedWhitelistIndex may not have been updated, not allowing more users to register as whitelist addresses.",
    "Contract": ["hardhat-vultisig/contracts/Whitelist.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "New ILO Pools can be created and initialized after a previous launch with the same Uniswap Pool",
    "Severity": "Low",
    "Description": "ILOManager::initILOPool() lets project owners create and initiate new ILO Pools after a successful previous launch. Note: launch() requires that all pools are launched successfully, which won't be possible for the new one.",
    "Contract": ["src/ILOManager.sol"],
    "Recommendation": ""
  },
  {
    "Issue": "launchTime and refundDeadline can be initialized in the past",
    "Severity": "Low",
    "Description": "launchTime can be set to a value < block.timestamp, and so refundDeadline as well in initProject(). Although, launchTime is validated against the project.end value in ILOManager::initILOPool() and against the vesting start in ILOVest::_validateVestSchedule().\n\nAlso, refundDeadline can overflow (as Solidity v0.7.6 is used), so a launchTime can be set into the far future, and overflow refundDeadline to be in the past.",
    "Contract": ["src/ILOPool.sol"],
    "Recommendation": ""
  }
]
